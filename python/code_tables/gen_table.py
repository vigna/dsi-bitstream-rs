from math import log2, ceil
from .generators.gen_merged_tables import gen_merged_table, funcs_merged_table
from .generators.gen_two_tables import gen_two_table, funcs_two_table
from .generators.gen_packed_be_tables import gen_packed_be_table, funcs_packed_be
from .generators.gen_packed_le_tables import gen_packed_le_table, funcs_packed_le
from .utils import get_best_fitting_type

def gen_table_partial(name, read_func, write_func):
    def wrapped(path, read_bits, write_max_val, table_type="merged"):
        """Configuration of `gen_table` for gamma"""
        assert read_bits > 0
        return gen_table(
            path,
            table_type,
            read_bits,
            write_max_val,
            name,
            read_func,
            write_func,
        )
    return wrapped


def gen_table(
    path,
    table_type,
    read_bits,
    write_max_val,
    code_name,
    read_func,
    write_func,
):
    """Main routine that generates the tables for a given code."""

    if table_type not in ["merged", "separated", "packed_be", "packed_le"]:
        raise ValueError("Invalid table type {}".format(table_type))
    

    with open(path, "w") as f:
        f.write("#![doc(hidden)]\n// THIS FILE HAS BEEN GENERATED BY A SCRIPT\n")
        f.write("// ~~~~~~~~~~~~~~~~~~~ DO NOT MODIFY ~~~~~~~~~~~~~~~~~~~~~~\n")
        f.write(
            "// Methods for reading and writing values using precomputed tables for {} codes\n".format(  # NoQA
                code_name
            )
        )
        f.write("use crate::traits::{BitRead, BitWrite, BE, LE};\n")
        f.write("use common_traits::CastableInto;\n")

        f.write("pub const TABLES_TYPE: &str = \"{}\";\n".format(table_type))
        
        f.write("/// How many bits are needed to read the tables in this\n")
        f.write("pub const READ_BITS: usize = {};\n".format(read_bits))
        f.write("/// Maximum value writable using the table(s)\n")
        f.write("pub const WRITE_MAX: u64 = {};\n".format(write_max_val))

        for BO in ["BE", "LE"]:
            read_codes = []
            for value in range(0, 2**read_bits):
                bits = ("{:0%sb}" % read_bits).format(value)
                try:
                    value, bits_left = read_func(bits, BO == "BE")
                    read_codes.append((value, read_bits - len(bits_left)))
                except ValueError:
                    read_codes.append((None, None))
                    
            
            write_codes = []
            for value in range(write_max_val + 1):
                bits = write_func(value, "", BO == "BE")
                write_codes.append((int(bits, 2), len(bits)))
                    
            read_max_val = max(x[0] or 0 for x in read_codes)
            read_max_len = max(x[1] or 0 for x in read_codes)
            write_max_code = max(x[0] or 0 for x in write_codes)
            write_max_len = max(x[1] or 0 for x in write_codes)
            
            metadata = {
                "bo": BO.lower(), 
                "BO": BO.upper(),
                "missing": read_max_len + 1,
                "read": log2(read_max_val + 1),
                "read_len": log2(read_max_len + 2),
                "write": log2(write_max_code + 1),
                "write_len": log2(write_max_len + 1),
            }
            metadata.update({
                "read_ty": get_best_fitting_type(metadata["read"]),
                "read_len_ty": get_best_fitting_type(metadata["read_len"]),
                "write_ty": get_best_fitting_type(metadata["write"]),
                "write_len_ty": get_best_fitting_type(metadata["write_len"]),
            })
            metadata.update({
                "read_bytes": ceil(metadata["read"] / 8),
                "read_len_bytes": ceil(metadata["read_len"] / 8),
                "write_bytes": ceil(metadata["write"] / 8),
                "write_len_bytes": ceil(metadata["write_len"] / 8),
            })
            
            f.write("/// The len we assign to a code that cannot be decoded through the read table\n")
            f.write("pub const MISSING_VALUE_LEN_{BO}: {read_len_ty} = {missing};\n".format(**metadata))
            f.write({
                    "merged": funcs_merged_table,
                    "separated": funcs_two_table,
                    "packed_be": funcs_packed_be,
                    "packed_le": funcs_packed_le,
                }[table_type]%metadata
            )
            
            {
                "merged": gen_merged_table,
                "separated": gen_two_table,
                "packed_be": gen_packed_be_table,
                "packed_le": gen_packed_le_table,
            }[table_type](f, read_codes, write_codes, metadata)

