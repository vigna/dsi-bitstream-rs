Project Path: /home/zom/Github/dsi-bitstream-rs/src

Source Tree:

```
src
├── codes
│   ├── minimal_binary.rs
│   ├── delta.rs
│   ├── delta_tables.rs
│   ├── exp_golomb.rs
│   ├── gamma.rs
│   ├── gamma_tables.rs
│   ├── golomb.rs
│   ├── mod.rs
│   ├── omega.rs
│   ├── params.rs
│   ├── pi.rs
│   ├── rice.rs
│   ├── table_params.rs
│   ├── vbyte.rs
│   ├── zeta.rs
│   ├── zeta_tables.rs
│   └── code.rs
├── fuzz
│   ├── mem_word_reader.rs
│   ├── mem_word_reader_strict.rs
│   ├── mem_word_writer.rs
│   ├── mem_word_writer_vec.rs
│   ├── mod.rs
│   └── codes.rs
├── impls
│   ├── mem_word_reader.rs
│   ├── mem_word_writer.rs
│   ├── mod.rs
│   ├── word_adapter.rs
│   ├── bit_reader.rs
│   ├── buf_bit_reader.rs
│   └── buf_bit_writer.rs
├── lib.rs
├── traits
│   ├── endianness.rs
│   ├── mod.rs
│   ├── words.rs
│   └── bits.rs
└── utils
    ├── stats.rs
    ├── count.rs
    ├── dbg_codes.rs
    └── mod.rs

```

`/home/zom/Github/dsi-bitstream-rs/src/codes/minimal_binary.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

//! Minimal binary codes.
//!
//! A minimal binary code with upper bound `u > 0` (AKA [truncated binary
//! encoding](https://en.wikipedia.org/wiki/Truncated_binary_encoding)) is an
//! optimal prefix-free code for the first `u` natural numbers with uniform distribution.
//!
//! There are several such prefix-free codes, and the one implemented here is
//! defined as follows: if `s = ⌊log₂u⌋`, then the first `2^(s+1) - u` codewords are
//! the first binary numbers of length `s – 1`, and the remaining codewords
//! are the last `2u - 2^(s+1)` binary numbers of length `s`.

use crate::traits::*;

/// Returns the length of the minimal binary code for `n` with upper bound `max`.
#[must_use]
#[inline]
pub fn len_minimal_binary(n: u64, max: u64) -> usize {
    if max == 0 {
        return 0;
    }
    let l = max.ilog2();
    let limit = (1 << (l + 1)) - max;
    let mut result = l as usize;
    if n >= limit {
        result += 1;
    }
    result
}

/// Trait for reading minimal binary codes.
pub trait MinimalBinaryRead<E: Endianness>: BitRead<E> {
    #[inline(always)]
    fn read_minimal_binary(&mut self, max: u64) -> Result<u64, Self::Error> {
        let l = max.ilog2();
        let mut prefix = self.read_bits(l as _)?;
        let limit = (1 << (l + 1)) - max;

        Ok(if prefix < limit {
            prefix
        } else {
            prefix <<= 1;
            prefix |= self.read_bits(1)?;
            prefix - limit
        })
    }
}

/// Trait for writing minimal binary codes.
pub trait MinimalBinaryWrite<E: Endianness>: BitWrite<E> {
    #[inline]
    fn write_minimal_binary(&mut self, n: u64, max: u64) -> Result<usize, Self::Error> {
        let l = max.ilog2();
        let limit = (1 << (l + 1)) - max;

        if n < limit {
            self.write_bits(n, l as _)?;
            Ok(l as usize)
        } else {
            let to_write = n + limit;
            self.write_bits(to_write >> 1, l as _)?;
            self.write_bits(to_write & 1, 1)?;
            Ok((l + 1) as usize)
        }
    }
}

impl<E: Endianness, B: BitRead<E>> MinimalBinaryRead<E> for B {}
impl<E: Endianness, B: BitWrite<E>> MinimalBinaryWrite<E> for B {}

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/delta.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

//! Elias δ code.
//!
//! The δ code of a natural number `n` is the concatenation of the [γ](crate::codes::gamma)
//! code of `⌊log₂(n + 1)⌋` and the binary representation of `n + 1` with the
//! most significant bit removed.
//!
//! The `USE_DELTA_TABLE` parameter enables or disables the use of
//! pre-computed tables for decoding δ codes, and the `USE_GAMMA_TABLE` parameter
//! enables or disables the use of pre-computed tables for decoding the
//! the initial γ code in case the whole δ code could not be decoded
//! by tables.
//!
//! ## Reference
//! Peter Elias,
//! "Universal codeword sets and representations of the integers,"
//! IEEE Transactions on Information Theory, vol. 21, no. 2, pp. 194-203, March
//! 1975, doi:  <https://doi.org/10.1109/TIT.1975.1055349>.
//!
use super::{delta_tables, len_gamma_param, GammaReadParam, GammaWriteParam};
use crate::traits::*;

/// Returns the length of the δ code for `n`.
#[must_use]
#[inline]
pub fn len_delta_param<const USE_DELTA_TABLE: bool, const USE_GAMMA_TABLE: bool>(n: u64) -> usize {
    if USE_DELTA_TABLE {
        if let Some(idx) = delta_tables::LEN.get(n as usize) {
            return *idx as usize;
        }
    }
    let l = (n + 1).ilog2();
    l as usize + len_gamma_param::<USE_GAMMA_TABLE>(l as _)
}

/// Returns the length of the δ code for `n` using
/// a default value for `USE_DELTA_TABLE` and `USE_GAMMA_TABLE`.
#[inline(always)]
pub fn len_delta(n: u64) -> usize {
    #[cfg(target_arch = "arm")]
    return len_delta_param::<false, false>(n);
    #[cfg(not(target_arch = "arm"))]
    return len_delta_param::<false, true>(n);
}

/// Trait for reading δ codes.
///
/// This is the trait you should usually pull in scope to read δ codes.
pub trait DeltaRead<E: Endianness>: BitRead<E> {
    fn read_delta(&mut self) -> Result<u64, Self::Error>;
}

/// Parametric trait for reading δ codes.
///
/// This trait is is more general than [`DeltaRead`], as it makes it possible
/// to specify how to use tables using const parameters.
///
/// We provide an implementation of this trait for [`BitRead`]. An implementation
/// of [`DeltaRead`] using default values is usually provided exploiting the
/// [`crate::codes::params::ReadParams`] mechanism.
pub trait DeltaReadParam<E: Endianness>: GammaReadParam<E> {
    fn read_delta_param<const USE_DELTA_TABLE: bool, const USE_GAMMA_TABLE: bool>(
        &mut self,
    ) -> Result<u64, Self::Error>;
}

/// Default, internal non-table based implementation that works
/// for any endianness.
#[inline(always)]
fn default_read_delta<E: Endianness, B: GammaReadParam<E>, const USE_GAMMA_TABLE: bool>(
    backend: &mut B,
) -> Result<u64, B::Error> {
    let len = backend.read_gamma_param::<USE_GAMMA_TABLE>()?;
    debug_assert!(len <= 64);
    Ok(backend.read_bits(len as usize)? + (1 << len) - 1)
}

impl<B: GammaReadParam<BE>> DeltaReadParam<BE> for B {
    #[inline]
    fn read_delta_param<const USE_DELTA_TABLE: bool, const USE_GAMMA_TABLE: bool>(
        &mut self,
    ) -> Result<u64, B::Error> {
        if USE_DELTA_TABLE {
            if let Some((res, _)) = delta_tables::read_table_be(self) {
                return Ok(res);
            }
        }
        default_read_delta::<BE, _, USE_GAMMA_TABLE>(self)
    }
}

impl<B: GammaReadParam<LE>> DeltaReadParam<LE> for B {
    #[inline]
    fn read_delta_param<const USE_DELTA_TABLE: bool, const USE_GAMMA_TABLE: bool>(
        &mut self,
    ) -> Result<u64, B::Error> {
        if USE_DELTA_TABLE {
            if let Some((res, _)) = delta_tables::read_table_le(self) {
                return Ok(res);
            }
        }
        default_read_delta::<LE, _, USE_GAMMA_TABLE>(self)
    }
}

/// Trait for writing δ codes.
///
/// This is the trait you should usually pull in scope to write δ codes.
pub trait DeltaWrite<E: Endianness>: BitWrite<E> {
    fn write_delta(&mut self, n: u64) -> Result<usize, Self::Error>;
}

/// Parametric trait for writing δ codes.
///
/// This trait is is more general than [`DeltaWrite`], as it makes it possible
/// to specify how to use tables using const parameters.
///
/// We provide an implementation of this trait for [`BitWrite`]. An implementation
/// of [`DeltaWrite`] using default values is usually provided exploiting the
/// [`crate::codes::params::WriteParams`] mechanism.
pub trait DeltaWriteParam<E: Endianness>: GammaWriteParam<E> {
    fn write_delta_param<const USE_DELTA_TABLE: bool, const USE_GAMMA_TABLE: bool>(
        &mut self,
        n: u64,
    ) -> Result<usize, Self::Error>;
}

impl<B: GammaWriteParam<BE>> DeltaWriteParam<BE> for B {
    #[inline]
    #[allow(clippy::collapsible_if)]
    fn write_delta_param<const USE_DELTA_TABLE: bool, const USE_GAMMA_TABLE: bool>(
        &mut self,
        n: u64,
    ) -> Result<usize, Self::Error> {
        if USE_DELTA_TABLE {
            if let Some(len) = delta_tables::write_table_be(self, n)? {
                return Ok(len);
            }
        }
        default_write_delta::<BE, _, USE_GAMMA_TABLE>(self, n)
    }
}

impl<B: GammaWriteParam<LE>> DeltaWriteParam<LE> for B {
    #[inline]
    #[allow(clippy::collapsible_if)]
    fn write_delta_param<const USE_DELTA_TABLE: bool, const USE_GAMMA_TABLE: bool>(
        &mut self,
        n: u64,
    ) -> Result<usize, Self::Error> {
        if USE_DELTA_TABLE {
            if let Some(len) = delta_tables::write_table_le(self, n)? {
                return Ok(len);
            }
        }
        default_write_delta::<LE, _, USE_GAMMA_TABLE>(self, n)
    }
}

/// Default, internal non-table based implementation that works
/// for any endianness.
#[inline(always)]
fn default_write_delta<E: Endianness, B: GammaWriteParam<E>, const USE_GAMMA_TABLE: bool>(
    backend: &mut B,
    mut n: u64,
) -> Result<usize, B::Error> {
    n += 1;
    let number_of_bits_to_write = n.ilog2();

    #[cfg(feature = "checks")]
    {
        // Clean up n in case checks are enabled
        n ^= 1 << number_of_bits_to_write;
    }

    Ok(
        backend.write_gamma_param::<USE_GAMMA_TABLE>(number_of_bits_to_write as _)?
            + backend.write_bits(n, number_of_bits_to_write as _)?,
    )
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/delta_tables.rs`:

```````rs
#![doc(hidden)]
// THIS FILE HAS BEEN GENERATED BY THE SCRIPT gen_code_tables.py
// ~~~~~~~~~~~~~~~~~~~ DO NOT MODIFY ~~~~~~~~~~~~~~~~~~~~~~
// Methods for reading and writing values using precomputed tables for delta codes
use crate::traits::{BitRead, BitWrite, BE, LE};
use common_traits::*;
/// How many bits are needed to read the tables in this
pub const READ_BITS: usize = 11;
/// Maximum value writable using the table(s)
pub const WRITE_MAX: u64 = 1023;

#[inline(always)]
/// Read a value using a decoding table.
///
/// If the result is `Some` the decoding was successful, and
/// the decoded value and the length of the code are returned.
pub fn read_table_le<B: BitRead<LE>>(backend: &mut B) -> Option<(u64, usize)> {
    if let Ok(idx) = backend.peek_bits(READ_BITS) {
        let idx: u64 = idx.cast();
        let len = READ_LEN_LE[idx as usize];
        if len != MISSING_VALUE_LEN_LE {
            backend.skip_bits_after_table_lookup(len as usize);
            return Some((READ_LE[idx as usize] as u64, len as usize));
        }
    }
    None
}
#[inline(always)]
/// Compute the length of the code representing a value using a decoding table.
///
/// If the result is `Some` the lookup was successful, and
/// the length of the code is returned.
pub fn len_table_le<B: BitRead<LE>>(backend: &mut B) -> Option<usize> {
    if let Ok(idx) = backend.peek_bits(READ_BITS) {
        let idx: u64 = idx.cast();
        let len = READ_LEN_LE[idx as usize];
        if len != MISSING_VALUE_LEN_LE {
            backend.skip_bits_after_table_lookup(len as usize);
            return Some(len as usize);
        }
    }
    None
}

#[inline(always)]
/// Write a value using an encoding table.
///
/// If the result is `Some` the encoding was successful, and
/// length of the code is returned.
pub fn write_table_le<B: BitWrite<LE>>(
    backend: &mut B,
    value: u64,
) -> Result<Option<usize>, B::Error> {
    Ok(if let Some(bits) = WRITE_LE.get(value as usize) {
        let len = WRITE_LEN_LE[value as usize] as usize;
        backend.write_bits(*bits as u64, len)?;
        Some(len)
    } else {
        None
    })
}

#[inline(always)]
/// Read a value using a decoding table.
///
/// If the result is `Some` the decoding was successful, and
/// the decoded value and the length of the code are returned.
pub fn read_table_be<B: BitRead<BE>>(backend: &mut B) -> Option<(u64, usize)> {
    if let Ok(idx) = backend.peek_bits(READ_BITS) {
        let idx: u64 = idx.cast();
        let len = READ_LEN_BE[idx as usize];
        if len != MISSING_VALUE_LEN_BE {
            backend.skip_bits_after_table_lookup(len as usize);
            return Some((READ_BE[idx as usize] as u64, len as usize));
        }
    }
    None
}
#[inline(always)]
/// Compute the length of the code representing a value using a decoding table.
///
/// If the result is `Some` the lookup was successful, and
/// the length of the code is returned.
pub fn len_table_be<B: BitRead<BE>>(backend: &mut B) -> Option<usize> {
    if let Ok(idx) = backend.peek_bits(READ_BITS) {
        let idx: u64 = idx.cast();
        let len = READ_LEN_BE[idx as usize];
        if len != MISSING_VALUE_LEN_BE {
            backend.skip_bits_after_table_lookup(len as usize);
            return Some(len as usize);
        }
    }
    None
}

#[inline(always)]
/// Write a value using an encoding table.
///
/// If the result is `Some` the encoding was successful, and
/// length of the code is returned.
pub fn write_table_be<B: BitWrite<BE>>(
    backend: &mut B,
    value: u64,
) -> Result<Option<usize>, B::Error> {
    Ok(if let Some(bits) = WRITE_BE.get(value as usize) {
        let len = WRITE_LEN_BE[value as usize] as usize;
        backend.write_bits(*bits as u64, len)?;
        Some(len)
    } else {
        None
    })
}
/// The len we assign to a code that cannot be decoded through the table
pub const MISSING_VALUE_LEN_BE: u8 = 12;
/// Precomputed table for writing delta codes
pub const READ_BE: &[u8] = &[
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10,
    10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13,
    13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18,
    18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24,
    24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30,
    30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37, 38, 38, 39, 39, 40, 40, 41, 41,
    42, 42, 43, 43, 44, 44, 45, 45, 46, 46, 47, 47, 48, 48, 49, 49, 50, 50, 51, 51, 52, 52, 53, 53,
    54, 54, 55, 55, 56, 56, 57, 57, 58, 58, 59, 59, 60, 60, 61, 61, 62, 62, 63, 64, 65, 66, 67, 68,
    69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92,
    93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
    113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];
/// Precomputed lengths table for reading delta codes
pub const READ_LEN_BE: &[u8] = &[
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1,
];
/// The len we assign to a code that cannot be decoded through the table
pub const MISSING_VALUE_LEN_LE: u8 = 12;
/// Precomputed table for writing delta codes
pub const READ_LE: &[u8] = &[
    0, 0, 1, 0, 7, 0, 3, 0, 0, 0, 2, 0, 15, 0, 4, 0, 0, 0, 1, 0, 31, 0, 5, 0, 0, 0, 2, 0, 63, 0, 6,
    0, 0, 0, 1, 0, 8, 0, 3, 0, 0, 0, 2, 0, 16, 0, 4, 0, 0, 0, 1, 0, 32, 0, 5, 0, 0, 0, 2, 0, 64, 0,
    6, 0, 0, 0, 1, 0, 9, 0, 3, 0, 0, 0, 2, 0, 17, 0, 4, 0, 0, 0, 1, 0, 33, 0, 5, 0, 0, 0, 2, 0, 65,
    0, 6, 0, 0, 0, 1, 0, 10, 0, 3, 0, 0, 0, 2, 0, 18, 0, 4, 0, 0, 0, 1, 0, 34, 0, 5, 0, 0, 0, 2, 0,
    66, 0, 6, 0, 0, 0, 1, 0, 11, 0, 3, 0, 0, 0, 2, 0, 19, 0, 4, 0, 0, 0, 1, 0, 35, 0, 5, 0, 0, 0,
    2, 0, 67, 0, 6, 0, 0, 0, 1, 0, 12, 0, 3, 0, 0, 0, 2, 0, 20, 0, 4, 0, 0, 0, 1, 0, 36, 0, 5, 0,
    0, 0, 2, 0, 68, 0, 6, 0, 0, 0, 1, 0, 13, 0, 3, 0, 0, 0, 2, 0, 21, 0, 4, 0, 0, 0, 1, 0, 37, 0,
    5, 0, 0, 0, 2, 0, 69, 0, 6, 0, 0, 0, 1, 0, 14, 0, 3, 0, 0, 0, 2, 0, 22, 0, 4, 0, 0, 0, 1, 0,
    38, 0, 5, 0, 0, 0, 2, 0, 70, 0, 6, 0, 0, 0, 1, 0, 7, 0, 3, 0, 0, 0, 2, 0, 23, 0, 4, 0, 0, 0, 1,
    0, 39, 0, 5, 0, 0, 0, 2, 0, 71, 0, 6, 0, 0, 0, 1, 0, 8, 0, 3, 0, 0, 0, 2, 0, 24, 0, 4, 0, 0, 0,
    1, 0, 40, 0, 5, 0, 0, 0, 2, 0, 72, 0, 6, 0, 0, 0, 1, 0, 9, 0, 3, 0, 0, 0, 2, 0, 25, 0, 4, 0, 0,
    0, 1, 0, 41, 0, 5, 0, 0, 0, 2, 0, 73, 0, 6, 0, 0, 0, 1, 0, 10, 0, 3, 0, 0, 0, 2, 0, 26, 0, 4,
    0, 0, 0, 1, 0, 42, 0, 5, 0, 0, 0, 2, 0, 74, 0, 6, 0, 0, 0, 1, 0, 11, 0, 3, 0, 0, 0, 2, 0, 27,
    0, 4, 0, 0, 0, 1, 0, 43, 0, 5, 0, 0, 0, 2, 0, 75, 0, 6, 0, 0, 0, 1, 0, 12, 0, 3, 0, 0, 0, 2, 0,
    28, 0, 4, 0, 0, 0, 1, 0, 44, 0, 5, 0, 0, 0, 2, 0, 76, 0, 6, 0, 0, 0, 1, 0, 13, 0, 3, 0, 0, 0,
    2, 0, 29, 0, 4, 0, 0, 0, 1, 0, 45, 0, 5, 0, 0, 0, 2, 0, 77, 0, 6, 0, 0, 0, 1, 0, 14, 0, 3, 0,
    0, 0, 2, 0, 30, 0, 4, 0, 0, 0, 1, 0, 46, 0, 5, 0, 0, 0, 2, 0, 78, 0, 6, 0, 0, 0, 1, 0, 7, 0, 3,
    0, 0, 0, 2, 0, 15, 0, 4, 0, 0, 0, 1, 0, 47, 0, 5, 0, 0, 0, 2, 0, 79, 0, 6, 0, 0, 0, 1, 0, 8, 0,
    3, 0, 0, 0, 2, 0, 16, 0, 4, 0, 0, 0, 1, 0, 48, 0, 5, 0, 0, 0, 2, 0, 80, 0, 6, 0, 0, 0, 1, 0, 9,
    0, 3, 0, 0, 0, 2, 0, 17, 0, 4, 0, 0, 0, 1, 0, 49, 0, 5, 0, 0, 0, 2, 0, 81, 0, 6, 0, 0, 0, 1, 0,
    10, 0, 3, 0, 0, 0, 2, 0, 18, 0, 4, 0, 0, 0, 1, 0, 50, 0, 5, 0, 0, 0, 2, 0, 82, 0, 6, 0, 0, 0,
    1, 0, 11, 0, 3, 0, 0, 0, 2, 0, 19, 0, 4, 0, 0, 0, 1, 0, 51, 0, 5, 0, 0, 0, 2, 0, 83, 0, 6, 0,
    0, 0, 1, 0, 12, 0, 3, 0, 0, 0, 2, 0, 20, 0, 4, 0, 0, 0, 1, 0, 52, 0, 5, 0, 0, 0, 2, 0, 84, 0,
    6, 0, 0, 0, 1, 0, 13, 0, 3, 0, 0, 0, 2, 0, 21, 0, 4, 0, 0, 0, 1, 0, 53, 0, 5, 0, 0, 0, 2, 0,
    85, 0, 6, 0, 0, 0, 1, 0, 14, 0, 3, 0, 0, 0, 2, 0, 22, 0, 4, 0, 0, 0, 1, 0, 54, 0, 5, 0, 0, 0,
    2, 0, 86, 0, 6, 0, 0, 0, 1, 0, 7, 0, 3, 0, 0, 0, 2, 0, 23, 0, 4, 0, 0, 0, 1, 0, 55, 0, 5, 0, 0,
    0, 2, 0, 87, 0, 6, 0, 0, 0, 1, 0, 8, 0, 3, 0, 0, 0, 2, 0, 24, 0, 4, 0, 0, 0, 1, 0, 56, 0, 5, 0,
    0, 0, 2, 0, 88, 0, 6, 0, 0, 0, 1, 0, 9, 0, 3, 0, 0, 0, 2, 0, 25, 0, 4, 0, 0, 0, 1, 0, 57, 0, 5,
    0, 0, 0, 2, 0, 89, 0, 6, 0, 0, 0, 1, 0, 10, 0, 3, 0, 0, 0, 2, 0, 26, 0, 4, 0, 0, 0, 1, 0, 58,
    0, 5, 0, 0, 0, 2, 0, 90, 0, 6, 0, 0, 0, 1, 0, 11, 0, 3, 0, 0, 0, 2, 0, 27, 0, 4, 0, 0, 0, 1, 0,
    59, 0, 5, 0, 0, 0, 2, 0, 91, 0, 6, 0, 0, 0, 1, 0, 12, 0, 3, 0, 0, 0, 2, 0, 28, 0, 4, 0, 0, 0,
    1, 0, 60, 0, 5, 0, 0, 0, 2, 0, 92, 0, 6, 0, 0, 0, 1, 0, 13, 0, 3, 0, 0, 0, 2, 0, 29, 0, 4, 0,
    0, 0, 1, 0, 61, 0, 5, 0, 0, 0, 2, 0, 93, 0, 6, 0, 0, 0, 1, 0, 14, 0, 3, 0, 0, 0, 2, 0, 30, 0,
    4, 0, 0, 0, 1, 0, 62, 0, 5, 0, 0, 0, 2, 0, 94, 0, 6, 0, 0, 0, 1, 0, 7, 0, 3, 0, 0, 0, 2, 0, 15,
    0, 4, 0, 0, 0, 1, 0, 31, 0, 5, 0, 0, 0, 2, 0, 95, 0, 6, 0, 0, 0, 1, 0, 8, 0, 3, 0, 0, 0, 2, 0,
    16, 0, 4, 0, 0, 0, 1, 0, 32, 0, 5, 0, 0, 0, 2, 0, 96, 0, 6, 0, 0, 0, 1, 0, 9, 0, 3, 0, 0, 0, 2,
    0, 17, 0, 4, 0, 0, 0, 1, 0, 33, 0, 5, 0, 0, 0, 2, 0, 97, 0, 6, 0, 0, 0, 1, 0, 10, 0, 3, 0, 0,
    0, 2, 0, 18, 0, 4, 0, 0, 0, 1, 0, 34, 0, 5, 0, 0, 0, 2, 0, 98, 0, 6, 0, 0, 0, 1, 0, 11, 0, 3,
    0, 0, 0, 2, 0, 19, 0, 4, 0, 0, 0, 1, 0, 35, 0, 5, 0, 0, 0, 2, 0, 99, 0, 6, 0, 0, 0, 1, 0, 12,
    0, 3, 0, 0, 0, 2, 0, 20, 0, 4, 0, 0, 0, 1, 0, 36, 0, 5, 0, 0, 0, 2, 0, 100, 0, 6, 0, 0, 0, 1,
    0, 13, 0, 3, 0, 0, 0, 2, 0, 21, 0, 4, 0, 0, 0, 1, 0, 37, 0, 5, 0, 0, 0, 2, 0, 101, 0, 6, 0, 0,
    0, 1, 0, 14, 0, 3, 0, 0, 0, 2, 0, 22, 0, 4, 0, 0, 0, 1, 0, 38, 0, 5, 0, 0, 0, 2, 0, 102, 0, 6,
    0, 0, 0, 1, 0, 7, 0, 3, 0, 0, 0, 2, 0, 23, 0, 4, 0, 0, 0, 1, 0, 39, 0, 5, 0, 0, 0, 2, 0, 103,
    0, 6, 0, 0, 0, 1, 0, 8, 0, 3, 0, 0, 0, 2, 0, 24, 0, 4, 0, 0, 0, 1, 0, 40, 0, 5, 0, 0, 0, 2, 0,
    104, 0, 6, 0, 0, 0, 1, 0, 9, 0, 3, 0, 0, 0, 2, 0, 25, 0, 4, 0, 0, 0, 1, 0, 41, 0, 5, 0, 0, 0,
    2, 0, 105, 0, 6, 0, 0, 0, 1, 0, 10, 0, 3, 0, 0, 0, 2, 0, 26, 0, 4, 0, 0, 0, 1, 0, 42, 0, 5, 0,
    0, 0, 2, 0, 106, 0, 6, 0, 0, 0, 1, 0, 11, 0, 3, 0, 0, 0, 2, 0, 27, 0, 4, 0, 0, 0, 1, 0, 43, 0,
    5, 0, 0, 0, 2, 0, 107, 0, 6, 0, 0, 0, 1, 0, 12, 0, 3, 0, 0, 0, 2, 0, 28, 0, 4, 0, 0, 0, 1, 0,
    44, 0, 5, 0, 0, 0, 2, 0, 108, 0, 6, 0, 0, 0, 1, 0, 13, 0, 3, 0, 0, 0, 2, 0, 29, 0, 4, 0, 0, 0,
    1, 0, 45, 0, 5, 0, 0, 0, 2, 0, 109, 0, 6, 0, 0, 0, 1, 0, 14, 0, 3, 0, 0, 0, 2, 0, 30, 0, 4, 0,
    0, 0, 1, 0, 46, 0, 5, 0, 0, 0, 2, 0, 110, 0, 6, 0, 0, 0, 1, 0, 7, 0, 3, 0, 0, 0, 2, 0, 15, 0,
    4, 0, 0, 0, 1, 0, 47, 0, 5, 0, 0, 0, 2, 0, 111, 0, 6, 0, 0, 0, 1, 0, 8, 0, 3, 0, 0, 0, 2, 0,
    16, 0, 4, 0, 0, 0, 1, 0, 48, 0, 5, 0, 0, 0, 2, 0, 112, 0, 6, 0, 0, 0, 1, 0, 9, 0, 3, 0, 0, 0,
    2, 0, 17, 0, 4, 0, 0, 0, 1, 0, 49, 0, 5, 0, 0, 0, 2, 0, 113, 0, 6, 0, 0, 0, 1, 0, 10, 0, 3, 0,
    0, 0, 2, 0, 18, 0, 4, 0, 0, 0, 1, 0, 50, 0, 5, 0, 0, 0, 2, 0, 114, 0, 6, 0, 0, 0, 1, 0, 11, 0,
    3, 0, 0, 0, 2, 0, 19, 0, 4, 0, 0, 0, 1, 0, 51, 0, 5, 0, 0, 0, 2, 0, 115, 0, 6, 0, 0, 0, 1, 0,
    12, 0, 3, 0, 0, 0, 2, 0, 20, 0, 4, 0, 0, 0, 1, 0, 52, 0, 5, 0, 0, 0, 2, 0, 116, 0, 6, 0, 0, 0,
    1, 0, 13, 0, 3, 0, 0, 0, 2, 0, 21, 0, 4, 0, 0, 0, 1, 0, 53, 0, 5, 0, 0, 0, 2, 0, 117, 0, 6, 0,
    0, 0, 1, 0, 14, 0, 3, 0, 0, 0, 2, 0, 22, 0, 4, 0, 0, 0, 1, 0, 54, 0, 5, 0, 0, 0, 2, 0, 118, 0,
    6, 0, 0, 0, 1, 0, 7, 0, 3, 0, 0, 0, 2, 0, 23, 0, 4, 0, 0, 0, 1, 0, 55, 0, 5, 0, 0, 0, 2, 0,
    119, 0, 6, 0, 0, 0, 1, 0, 8, 0, 3, 0, 0, 0, 2, 0, 24, 0, 4, 0, 0, 0, 1, 0, 56, 0, 5, 0, 0, 0,
    2, 0, 120, 0, 6, 0, 0, 0, 1, 0, 9, 0, 3, 0, 0, 0, 2, 0, 25, 0, 4, 0, 0, 0, 1, 0, 57, 0, 5, 0,
    0, 0, 2, 0, 121, 0, 6, 0, 0, 0, 1, 0, 10, 0, 3, 0, 0, 0, 2, 0, 26, 0, 4, 0, 0, 0, 1, 0, 58, 0,
    5, 0, 0, 0, 2, 0, 122, 0, 6, 0, 0, 0, 1, 0, 11, 0, 3, 0, 0, 0, 2, 0, 27, 0, 4, 0, 0, 0, 1, 0,
    59, 0, 5, 0, 0, 0, 2, 0, 123, 0, 6, 0, 0, 0, 1, 0, 12, 0, 3, 0, 0, 0, 2, 0, 28, 0, 4, 0, 0, 0,
    1, 0, 60, 0, 5, 0, 0, 0, 2, 0, 124, 0, 6, 0, 0, 0, 1, 0, 13, 0, 3, 0, 0, 0, 2, 0, 29, 0, 4, 0,
    0, 0, 1, 0, 61, 0, 5, 0, 0, 0, 2, 0, 125, 0, 6, 0, 0, 0, 1, 0, 14, 0, 3, 0, 0, 0, 2, 0, 30, 0,
    4, 0, 0, 0, 1, 0, 62, 0, 5, 0, 0, 0, 2, 0, 126, 0, 6, 0,
];
/// Precomputed lengths table for reading delta codes
pub const READ_LEN_LE: &[u8] = &[
    12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1,
    5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1,
    11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1,
    4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1,
    12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1,
    5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1,
    10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1,
    4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1,
    12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1,
    5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1,
    9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1,
    4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1,
    12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1,
    5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1,
    8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1,
    4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1,
    12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1,
    5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1,
    11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1,
    4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1,
    12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1,
    5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1,
    10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1,
    4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1,
    12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1,
    5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1,
    9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1,
    4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1,
    12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1,
    5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1,
    8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1,
    4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1,
    12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1,
    5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1,
    11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1,
    4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1,
    12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1,
    5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1,
    10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1,
    4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1,
    12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1,
    5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1,
    9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1,
    4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1,
    12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1,
    5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1,
    8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1,
    4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1,
    12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1,
    5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1,
    11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1,
    4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1,
    12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1,
    5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1,
    10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1,
    4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1,
    12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1,
    5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1,
    9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1,
    4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1,
    12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1,
    5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1, 4, 1,
    8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1, 12, 1,
    4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1, 5, 1,
    12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1, 11, 1,
    5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1, 4, 1,
    11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1, 12, 1,
    4, 1, 11, 1, 5, 1, 12, 1, 4, 1, 8, 1, 5, 1, 12, 1, 4, 1, 9, 1, 5, 1, 12, 1, 4, 1, 10, 1, 5, 1,
    12, 1, 4, 1, 11, 1, 5, 1,
];
///Table used to speed up the writing of delta codes
pub const WRITE_BE: &[u32] = &[
    1, 4, 5, 12, 13, 14, 15, 32, 33, 34, 35, 36, 37, 38, 39, 80, 81, 82, 83, 84, 85, 86, 87, 88,
    89, 90, 91, 92, 93, 94, 95, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204,
    205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
    448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466,
    467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485,
    486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504,
    505, 506, 507, 508, 509, 510, 511, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033,
    1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049,
    1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065,
    1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081,
    1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097,
    1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113,
    1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129,
    1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145,
    1146, 1147, 1148, 1149, 1150, 1151, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313,
    2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329,
    2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345,
    2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361,
    2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377,
    2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393,
    2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409,
    2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425,
    2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441,
    2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457,
    2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473,
    2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489,
    2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505,
    2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521,
    2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537,
    2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553,
    2554, 2555, 2556, 2557, 2558, 2559, 5120, 5121, 5122, 5123, 5124, 5125, 5126, 5127, 5128, 5129,
    5130, 5131, 5132, 5133, 5134, 5135, 5136, 5137, 5138, 5139, 5140, 5141, 5142, 5143, 5144, 5145,
    5146, 5147, 5148, 5149, 5150, 5151, 5152, 5153, 5154, 5155, 5156, 5157, 5158, 5159, 5160, 5161,
    5162, 5163, 5164, 5165, 5166, 5167, 5168, 5169, 5170, 5171, 5172, 5173, 5174, 5175, 5176, 5177,
    5178, 5179, 5180, 5181, 5182, 5183, 5184, 5185, 5186, 5187, 5188, 5189, 5190, 5191, 5192, 5193,
    5194, 5195, 5196, 5197, 5198, 5199, 5200, 5201, 5202, 5203, 5204, 5205, 5206, 5207, 5208, 5209,
    5210, 5211, 5212, 5213, 5214, 5215, 5216, 5217, 5218, 5219, 5220, 5221, 5222, 5223, 5224, 5225,
    5226, 5227, 5228, 5229, 5230, 5231, 5232, 5233, 5234, 5235, 5236, 5237, 5238, 5239, 5240, 5241,
    5242, 5243, 5244, 5245, 5246, 5247, 5248, 5249, 5250, 5251, 5252, 5253, 5254, 5255, 5256, 5257,
    5258, 5259, 5260, 5261, 5262, 5263, 5264, 5265, 5266, 5267, 5268, 5269, 5270, 5271, 5272, 5273,
    5274, 5275, 5276, 5277, 5278, 5279, 5280, 5281, 5282, 5283, 5284, 5285, 5286, 5287, 5288, 5289,
    5290, 5291, 5292, 5293, 5294, 5295, 5296, 5297, 5298, 5299, 5300, 5301, 5302, 5303, 5304, 5305,
    5306, 5307, 5308, 5309, 5310, 5311, 5312, 5313, 5314, 5315, 5316, 5317, 5318, 5319, 5320, 5321,
    5322, 5323, 5324, 5325, 5326, 5327, 5328, 5329, 5330, 5331, 5332, 5333, 5334, 5335, 5336, 5337,
    5338, 5339, 5340, 5341, 5342, 5343, 5344, 5345, 5346, 5347, 5348, 5349, 5350, 5351, 5352, 5353,
    5354, 5355, 5356, 5357, 5358, 5359, 5360, 5361, 5362, 5363, 5364, 5365, 5366, 5367, 5368, 5369,
    5370, 5371, 5372, 5373, 5374, 5375, 5376, 5377, 5378, 5379, 5380, 5381, 5382, 5383, 5384, 5385,
    5386, 5387, 5388, 5389, 5390, 5391, 5392, 5393, 5394, 5395, 5396, 5397, 5398, 5399, 5400, 5401,
    5402, 5403, 5404, 5405, 5406, 5407, 5408, 5409, 5410, 5411, 5412, 5413, 5414, 5415, 5416, 5417,
    5418, 5419, 5420, 5421, 5422, 5423, 5424, 5425, 5426, 5427, 5428, 5429, 5430, 5431, 5432, 5433,
    5434, 5435, 5436, 5437, 5438, 5439, 5440, 5441, 5442, 5443, 5444, 5445, 5446, 5447, 5448, 5449,
    5450, 5451, 5452, 5453, 5454, 5455, 5456, 5457, 5458, 5459, 5460, 5461, 5462, 5463, 5464, 5465,
    5466, 5467, 5468, 5469, 5470, 5471, 5472, 5473, 5474, 5475, 5476, 5477, 5478, 5479, 5480, 5481,
    5482, 5483, 5484, 5485, 5486, 5487, 5488, 5489, 5490, 5491, 5492, 5493, 5494, 5495, 5496, 5497,
    5498, 5499, 5500, 5501, 5502, 5503, 5504, 5505, 5506, 5507, 5508, 5509, 5510, 5511, 5512, 5513,
    5514, 5515, 5516, 5517, 5518, 5519, 5520, 5521, 5522, 5523, 5524, 5525, 5526, 5527, 5528, 5529,
    5530, 5531, 5532, 5533, 5534, 5535, 5536, 5537, 5538, 5539, 5540, 5541, 5542, 5543, 5544, 5545,
    5546, 5547, 5548, 5549, 5550, 5551, 5552, 5553, 5554, 5555, 5556, 5557, 5558, 5559, 5560, 5561,
    5562, 5563, 5564, 5565, 5566, 5567, 5568, 5569, 5570, 5571, 5572, 5573, 5574, 5575, 5576, 5577,
    5578, 5579, 5580, 5581, 5582, 5583, 5584, 5585, 5586, 5587, 5588, 5589, 5590, 5591, 5592, 5593,
    5594, 5595, 5596, 5597, 5598, 5599, 5600, 5601, 5602, 5603, 5604, 5605, 5606, 5607, 5608, 5609,
    5610, 5611, 5612, 5613, 5614, 5615, 5616, 5617, 5618, 5619, 5620, 5621, 5622, 5623, 5624, 5625,
    5626, 5627, 5628, 5629, 5630, 5631, 11264,
];
///Table used to speed up the writing of delta codes
pub const WRITE_LEN_BE: &[u32] = &[
    1, 4, 4, 5, 5, 5, 5, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 17,
];
///Table used to speed up the writing of delta codes
pub const WRITE_LE: &[u32] = &[
    1, 2, 10, 6, 14, 22, 30, 4, 36, 68, 100, 132, 164, 196, 228, 12, 44, 76, 108, 140, 172, 204,
    236, 268, 300, 332, 364, 396, 428, 460, 492, 20, 52, 84, 116, 148, 180, 212, 244, 276, 308,
    340, 372, 404, 436, 468, 500, 532, 564, 596, 628, 660, 692, 724, 756, 788, 820, 852, 884, 916,
    948, 980, 1012, 28, 60, 92, 124, 156, 188, 220, 252, 284, 316, 348, 380, 412, 444, 476, 508,
    540, 572, 604, 636, 668, 700, 732, 764, 796, 828, 860, 892, 924, 956, 988, 1020, 1052, 1084,
    1116, 1148, 1180, 1212, 1244, 1276, 1308, 1340, 1372, 1404, 1436, 1468, 1500, 1532, 1564, 1596,
    1628, 1660, 1692, 1724, 1756, 1788, 1820, 1852, 1884, 1916, 1948, 1980, 2012, 2044, 8, 136,
    264, 392, 520, 648, 776, 904, 1032, 1160, 1288, 1416, 1544, 1672, 1800, 1928, 2056, 2184, 2312,
    2440, 2568, 2696, 2824, 2952, 3080, 3208, 3336, 3464, 3592, 3720, 3848, 3976, 4104, 4232, 4360,
    4488, 4616, 4744, 4872, 5000, 5128, 5256, 5384, 5512, 5640, 5768, 5896, 6024, 6152, 6280, 6408,
    6536, 6664, 6792, 6920, 7048, 7176, 7304, 7432, 7560, 7688, 7816, 7944, 8072, 8200, 8328, 8456,
    8584, 8712, 8840, 8968, 9096, 9224, 9352, 9480, 9608, 9736, 9864, 9992, 10120, 10248, 10376,
    10504, 10632, 10760, 10888, 11016, 11144, 11272, 11400, 11528, 11656, 11784, 11912, 12040,
    12168, 12296, 12424, 12552, 12680, 12808, 12936, 13064, 13192, 13320, 13448, 13576, 13704,
    13832, 13960, 14088, 14216, 14344, 14472, 14600, 14728, 14856, 14984, 15112, 15240, 15368,
    15496, 15624, 15752, 15880, 16008, 16136, 16264, 24, 152, 280, 408, 536, 664, 792, 920, 1048,
    1176, 1304, 1432, 1560, 1688, 1816, 1944, 2072, 2200, 2328, 2456, 2584, 2712, 2840, 2968, 3096,
    3224, 3352, 3480, 3608, 3736, 3864, 3992, 4120, 4248, 4376, 4504, 4632, 4760, 4888, 5016, 5144,
    5272, 5400, 5528, 5656, 5784, 5912, 6040, 6168, 6296, 6424, 6552, 6680, 6808, 6936, 7064, 7192,
    7320, 7448, 7576, 7704, 7832, 7960, 8088, 8216, 8344, 8472, 8600, 8728, 8856, 8984, 9112, 9240,
    9368, 9496, 9624, 9752, 9880, 10008, 10136, 10264, 10392, 10520, 10648, 10776, 10904, 11032,
    11160, 11288, 11416, 11544, 11672, 11800, 11928, 12056, 12184, 12312, 12440, 12568, 12696,
    12824, 12952, 13080, 13208, 13336, 13464, 13592, 13720, 13848, 13976, 14104, 14232, 14360,
    14488, 14616, 14744, 14872, 15000, 15128, 15256, 15384, 15512, 15640, 15768, 15896, 16024,
    16152, 16280, 16408, 16536, 16664, 16792, 16920, 17048, 17176, 17304, 17432, 17560, 17688,
    17816, 17944, 18072, 18200, 18328, 18456, 18584, 18712, 18840, 18968, 19096, 19224, 19352,
    19480, 19608, 19736, 19864, 19992, 20120, 20248, 20376, 20504, 20632, 20760, 20888, 21016,
    21144, 21272, 21400, 21528, 21656, 21784, 21912, 22040, 22168, 22296, 22424, 22552, 22680,
    22808, 22936, 23064, 23192, 23320, 23448, 23576, 23704, 23832, 23960, 24088, 24216, 24344,
    24472, 24600, 24728, 24856, 24984, 25112, 25240, 25368, 25496, 25624, 25752, 25880, 26008,
    26136, 26264, 26392, 26520, 26648, 26776, 26904, 27032, 27160, 27288, 27416, 27544, 27672,
    27800, 27928, 28056, 28184, 28312, 28440, 28568, 28696, 28824, 28952, 29080, 29208, 29336,
    29464, 29592, 29720, 29848, 29976, 30104, 30232, 30360, 30488, 30616, 30744, 30872, 31000,
    31128, 31256, 31384, 31512, 31640, 31768, 31896, 32024, 32152, 32280, 32408, 32536, 32664, 40,
    168, 296, 424, 552, 680, 808, 936, 1064, 1192, 1320, 1448, 1576, 1704, 1832, 1960, 2088, 2216,
    2344, 2472, 2600, 2728, 2856, 2984, 3112, 3240, 3368, 3496, 3624, 3752, 3880, 4008, 4136, 4264,
    4392, 4520, 4648, 4776, 4904, 5032, 5160, 5288, 5416, 5544, 5672, 5800, 5928, 6056, 6184, 6312,
    6440, 6568, 6696, 6824, 6952, 7080, 7208, 7336, 7464, 7592, 7720, 7848, 7976, 8104, 8232, 8360,
    8488, 8616, 8744, 8872, 9000, 9128, 9256, 9384, 9512, 9640, 9768, 9896, 10024, 10152, 10280,
    10408, 10536, 10664, 10792, 10920, 11048, 11176, 11304, 11432, 11560, 11688, 11816, 11944,
    12072, 12200, 12328, 12456, 12584, 12712, 12840, 12968, 13096, 13224, 13352, 13480, 13608,
    13736, 13864, 13992, 14120, 14248, 14376, 14504, 14632, 14760, 14888, 15016, 15144, 15272,
    15400, 15528, 15656, 15784, 15912, 16040, 16168, 16296, 16424, 16552, 16680, 16808, 16936,
    17064, 17192, 17320, 17448, 17576, 17704, 17832, 17960, 18088, 18216, 18344, 18472, 18600,
    18728, 18856, 18984, 19112, 19240, 19368, 19496, 19624, 19752, 19880, 20008, 20136, 20264,
    20392, 20520, 20648, 20776, 20904, 21032, 21160, 21288, 21416, 21544, 21672, 21800, 21928,
    22056, 22184, 22312, 22440, 22568, 22696, 22824, 22952, 23080, 23208, 23336, 23464, 23592,
    23720, 23848, 23976, 24104, 24232, 24360, 24488, 24616, 24744, 24872, 25000, 25128, 25256,
    25384, 25512, 25640, 25768, 25896, 26024, 26152, 26280, 26408, 26536, 26664, 26792, 26920,
    27048, 27176, 27304, 27432, 27560, 27688, 27816, 27944, 28072, 28200, 28328, 28456, 28584,
    28712, 28840, 28968, 29096, 29224, 29352, 29480, 29608, 29736, 29864, 29992, 30120, 30248,
    30376, 30504, 30632, 30760, 30888, 31016, 31144, 31272, 31400, 31528, 31656, 31784, 31912,
    32040, 32168, 32296, 32424, 32552, 32680, 32808, 32936, 33064, 33192, 33320, 33448, 33576,
    33704, 33832, 33960, 34088, 34216, 34344, 34472, 34600, 34728, 34856, 34984, 35112, 35240,
    35368, 35496, 35624, 35752, 35880, 36008, 36136, 36264, 36392, 36520, 36648, 36776, 36904,
    37032, 37160, 37288, 37416, 37544, 37672, 37800, 37928, 38056, 38184, 38312, 38440, 38568,
    38696, 38824, 38952, 39080, 39208, 39336, 39464, 39592, 39720, 39848, 39976, 40104, 40232,
    40360, 40488, 40616, 40744, 40872, 41000, 41128, 41256, 41384, 41512, 41640, 41768, 41896,
    42024, 42152, 42280, 42408, 42536, 42664, 42792, 42920, 43048, 43176, 43304, 43432, 43560,
    43688, 43816, 43944, 44072, 44200, 44328, 44456, 44584, 44712, 44840, 44968, 45096, 45224,
    45352, 45480, 45608, 45736, 45864, 45992, 46120, 46248, 46376, 46504, 46632, 46760, 46888,
    47016, 47144, 47272, 47400, 47528, 47656, 47784, 47912, 48040, 48168, 48296, 48424, 48552,
    48680, 48808, 48936, 49064, 49192, 49320, 49448, 49576, 49704, 49832, 49960, 50088, 50216,
    50344, 50472, 50600, 50728, 50856, 50984, 51112, 51240, 51368, 51496, 51624, 51752, 51880,
    52008, 52136, 52264, 52392, 52520, 52648, 52776, 52904, 53032, 53160, 53288, 53416, 53544,
    53672, 53800, 53928, 54056, 54184, 54312, 54440, 54568, 54696, 54824, 54952, 55080, 55208,
    55336, 55464, 55592, 55720, 55848, 55976, 56104, 56232, 56360, 56488, 56616, 56744, 56872,
    57000, 57128, 57256, 57384, 57512, 57640, 57768, 57896, 58024, 58152, 58280, 58408, 58536,
    58664, 58792, 58920, 59048, 59176, 59304, 59432, 59560, 59688, 59816, 59944, 60072, 60200,
    60328, 60456, 60584, 60712, 60840, 60968, 61096, 61224, 61352, 61480, 61608, 61736, 61864,
    61992, 62120, 62248, 62376, 62504, 62632, 62760, 62888, 63016, 63144, 63272, 63400, 63528,
    63656, 63784, 63912, 64040, 64168, 64296, 64424, 64552, 64680, 64808, 64936, 65064, 65192,
    65320, 65448, 56,
];
///Table used to speed up the writing of delta codes
pub const WRITE_LEN_LE: &[u32] = &[
    1, 4, 4, 5, 5, 5, 5, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 17,
];
///Table used to speed up the skipping of delta codes
pub const LEN: &[u8] = &[
    1, 4, 4, 5, 5, 5, 5, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 17,
];

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/exp_golomb.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

//! Exponential Golomb codes.
//!
//! Exponential Golomb codes are a variant of Golomb codes with power-of-2
//! modulus (i.e., [Rice codes](super::rice)) in which the prefix is written
//! using [Elias γ code](super::gamma) instead of unary code. More precisely,
//! the exponential Golomb code with parameter `k` of an integer `n` is given
//! `⌊x / 2^k⌋` in [γ code](super::gamma) followed by `x mod 2^k` as  a `k`-bit
//! number. They are used in [H.264
//! (MPEG-4)](https://en.wikipedia.org/wiki/Advanced_Video_Coding) and
//! [H.265](https://en.wikipedia.org/wiki/High_Efficiency_Video_Coding).
//!
//! The exponential Golomb code for `k = 1` is exactly [γ code](super::gamma).

use super::gamma::{len_gamma, GammaRead, GammaWrite};
use crate::traits::*;

/// Returns the length of the exponential Golomb code for `n` with parameter `k`.
#[must_use]
#[inline]
pub fn len_exp_golomb(n: u64, k: usize) -> usize {
    len_gamma(n >> k) + k
}

/// Trait for reading exponential Golomb codes.
pub trait ExpGolombRead<E: Endianness>: BitRead<E> + GammaRead<E> {
    #[inline(always)]
    fn read_exp_golomb(&mut self, k: usize) -> Result<u64, Self::Error> {
        Ok((self.read_gamma()? << k) + self.read_bits(k)?)
    }
}

/// Trait for writing exponential Golomb codes.
pub trait ExpGolombWrite<E: Endianness>: BitWrite<E> + GammaWrite<E> {
    #[inline]
    fn write_exp_golomb(&mut self, n: u64, k: usize) -> Result<usize, Self::Error> {
        let mut written_bits = self.write_gamma(n >> k)?;
        #[cfg(feature = "checks")]
        {
            // Clean up n in case checks are enabled
            let n = n & (1_u128 << k).wrapping_sub(1) as u64;
            written_bits += self.write_bits(n, k)?;
        }
        #[cfg(not(feature = "checks"))]
        {
            written_bits += self.write_bits(n, k)?;
        }
        Ok(written_bits)
    }
}

impl<E: Endianness, B: BitRead<E> + GammaRead<E>> ExpGolombRead<E> for B {}
impl<E: Endianness, B: BitWrite<E> + GammaWrite<E>> ExpGolombWrite<E> for B {}

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/gamma.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

//! Elias γ code.
//!
//! The γ code of a natural number `n` is the concatenation of the unary code of
//! `⌊log₂(n + 1)⌋` and the binary representation of `n + 1` with the most
//! significant bit removed.
//!
//! The `USE_TABLE` parameter enables or disables the use of
//! pre-computed tables for decoding.
//!
//! ## Reference
//! Peter Elias,
//! "Universal codeword sets and representations of the integers,"
//! IEEE Transactions on Information Theory, vol. 21, no. 2, pp. 194-203, March
//! 1975, doi:  <https://doi.org/10.1109/TIT.1975.1055349>.

use super::gamma_tables;
use crate::traits::*;

/// Returns the length of the γ code for `n`.
#[must_use]
#[inline]
pub fn len_gamma_param<const USE_TABLE: bool>(mut n: u64) -> usize {
    if USE_TABLE {
        if let Some(idx) = gamma_tables::LEN.get(n as usize) {
            return *idx as usize;
        }
    }
    n += 1;
    let number_of_bits_to_write = n.ilog2();
    2 * number_of_bits_to_write as usize + 1
}

/// Returns the length of the γ code for `n` using
/// a default value for `USE_TABLE`.
pub fn len_gamma(n: u64) -> usize {
    #[cfg(target_arch = "arm")]
    return len_gamma_param::<false>(n);
    #[cfg(not(target_arch = "arm"))]
    return len_gamma_param::<true>(n);
}

/// Trait for reading γ codes.
///
/// This is the trait you should usually pull in scope to read γ codes.
pub trait GammaRead<E: Endianness>: BitRead<E> {
    fn read_gamma(&mut self) -> Result<u64, Self::Error>;
}

/// Parametric trait for reading γ codes.
///
/// This trait is is more general than [`GammaRead`], as it makes it possible
/// to specify how to use tables using const parameters.
///
/// We provide an implementation of this trait for [`BitRead`]. An implementation
/// of [`GammaRead`] using default values is usually provided exploiting the
/// [`crate::codes::params::ReadParams`] mechanism.
pub trait GammaReadParam<E: Endianness>: BitRead<E> {
    fn read_gamma_param<const USE_TABLE: bool>(&mut self) -> Result<u64, Self::Error>;
}

/// Default, internal non-table based implementation that works
/// for any endianness.
#[inline(always)]
fn default_read_gamma<E: Endianness, B: BitRead<E>>(backend: &mut B) -> Result<u64, B::Error> {
    let len = backend.read_unary()?;
    debug_assert!(len <= 64);
    Ok(backend.read_bits(len as usize)? + (1 << len) - 1)
}

impl<B: BitRead<BE>> GammaReadParam<BE> for B {
    #[inline]
    fn read_gamma_param<const USE_TABLE: bool>(&mut self) -> Result<u64, Self::Error> {
        if USE_TABLE {
            if let Some((res, _)) = gamma_tables::read_table_be(self) {
                return Ok(res);
            }
        }
        default_read_gamma(self)
    }
}

impl<B: BitRead<LE>> GammaReadParam<LE> for B {
    #[inline]
    fn read_gamma_param<const USE_TABLE: bool>(&mut self) -> Result<u64, Self::Error> {
        if USE_TABLE {
            if let Some((res, _)) = gamma_tables::read_table_le(self) {
                return Ok(res);
            }
        }
        default_read_gamma(self)
    }
}

/// Trait for writing γ codes.
///
/// This is the trait you should usually pull in scope to write γ codes.
pub trait GammaWrite<E: Endianness>: BitWrite<E> {
    fn write_gamma(&mut self, n: u64) -> Result<usize, Self::Error>;
}

/// Parametric trait for writing γ codes.
///
/// This trait is is more general than [`GammaWrite`], as it makes it possible
/// to specify how to use tables using const parameters.
///
/// We provide an implementation of this trait for [`BitWrite`]. An implementation
/// of [`GammaWrite`] using default values is usually provided exploiting the
/// [`crate::codes::params::WriteParams`] mechanism.
pub trait GammaWriteParam<E: Endianness>: BitWrite<E> {
    fn write_gamma_param<const USE_TABLE: bool>(&mut self, n: u64) -> Result<usize, Self::Error>;
}

impl<B: BitWrite<BE>> GammaWriteParam<BE> for B {
    #[inline]
    #[allow(clippy::collapsible_if)]
    fn write_gamma_param<const USE_TABLE: bool>(&mut self, n: u64) -> Result<usize, Self::Error> {
        if USE_TABLE {
            if let Some(len) = gamma_tables::write_table_be(self, n)? {
                return Ok(len);
            }
        }
        default_write_gamma(self, n)
    }
}

impl<B: BitWrite<LE>> GammaWriteParam<LE> for B {
    #[inline]
    #[allow(clippy::collapsible_if)]
    fn write_gamma_param<const USE_TABLE: bool>(&mut self, n: u64) -> Result<usize, Self::Error> {
        if USE_TABLE {
            if let Some(len) = gamma_tables::write_table_le(self, n)? {
                return Ok(len);
            }
        }
        default_write_gamma(self, n)
    }
}

/// Default, internal non-table based implementation that works
/// for any endianness.
#[inline(always)]
fn default_write_gamma<E: Endianness, B: BitWrite<E>>(
    backend: &mut B,
    mut n: u64,
) -> Result<usize, B::Error> {
    n += 1;
    let number_of_bits_to_write = n.ilog2();

    #[cfg(feature = "checks")]
    {
        // Clean up n in case checks are enabled
        n ^= 1 << number_of_bits_to_write;
    }

    Ok(backend.write_unary(number_of_bits_to_write as _)?
        + backend.write_bits(n, number_of_bits_to_write as _)?)
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/gamma_tables.rs`:

```````rs
#![doc(hidden)]
// THIS FILE HAS BEEN GENERATED BY THE SCRIPT gen_code_tables.py
// ~~~~~~~~~~~~~~~~~~~ DO NOT MODIFY ~~~~~~~~~~~~~~~~~~~~~~
// Methods for reading and writing values using precomputed tables for gamma codes
use crate::traits::{BitRead, BitWrite, BE, LE};
use common_traits::*;
/// How many bits are needed to read the tables in this
pub const READ_BITS: usize = 9;
/// Maximum value writable using the table(s)
pub const WRITE_MAX: u64 = 63;

#[inline(always)]
/// Read a value using a decoding table.
///
/// If the result is `Some` the decoding was successful, and
/// the decoded value and the length of the code are returned.
pub fn read_table_le<B: BitRead<LE>>(backend: &mut B) -> Option<(u64, usize)> {
    if let Ok(idx) = backend.peek_bits(READ_BITS) {
        let idx: u64 = idx.cast();
        let len = READ_LEN_LE[idx as usize];
        if len != MISSING_VALUE_LEN_LE {
            backend.skip_bits_after_table_lookup(len as usize);
            return Some((READ_LE[idx as usize] as u64, len as usize));
        }
    }
    None
}
#[inline(always)]
/// Compute the length of the code representing a value using a decoding table.
///
/// If the result is `Some` the lookup was successful, and
/// the length of the code is returned.
pub fn len_table_le<B: BitRead<LE>>(backend: &mut B) -> Option<usize> {
    if let Ok(idx) = backend.peek_bits(READ_BITS) {
        let idx: u64 = idx.cast();
        let len = READ_LEN_LE[idx as usize];
        if len != MISSING_VALUE_LEN_LE {
            backend.skip_bits_after_table_lookup(len as usize);
            return Some(len as usize);
        }
    }
    None
}

#[inline(always)]
/// Write a value using an encoding table.
///
/// If the result is `Some` the encoding was successful, and
/// length of the code is returned.
pub fn write_table_le<B: BitWrite<LE>>(
    backend: &mut B,
    value: u64,
) -> Result<Option<usize>, B::Error> {
    Ok(if let Some(bits) = WRITE_LE.get(value as usize) {
        let len = WRITE_LEN_LE[value as usize] as usize;
        backend.write_bits(*bits as u64, len)?;
        Some(len)
    } else {
        None
    })
}

#[inline(always)]
/// Read a value using a decoding table.
///
/// If the result is `Some` the decoding was successful, and
/// the decoded value and the length of the code are returned.
pub fn read_table_be<B: BitRead<BE>>(backend: &mut B) -> Option<(u64, usize)> {
    if let Ok(idx) = backend.peek_bits(READ_BITS) {
        let idx: u64 = idx.cast();
        let len = READ_LEN_BE[idx as usize];
        if len != MISSING_VALUE_LEN_BE {
            backend.skip_bits_after_table_lookup(len as usize);
            return Some((READ_BE[idx as usize] as u64, len as usize));
        }
    }
    None
}
#[inline(always)]
/// Compute the length of the code representing a value using a decoding table.
///
/// If the result is `Some` the lookup was successful, and
/// the length of the code is returned.
pub fn len_table_be<B: BitRead<BE>>(backend: &mut B) -> Option<usize> {
    if let Ok(idx) = backend.peek_bits(READ_BITS) {
        let idx: u64 = idx.cast();
        let len = READ_LEN_BE[idx as usize];
        if len != MISSING_VALUE_LEN_BE {
            backend.skip_bits_after_table_lookup(len as usize);
            return Some(len as usize);
        }
    }
    None
}

#[inline(always)]
/// Write a value using an encoding table.
///
/// If the result is `Some` the encoding was successful, and
/// length of the code is returned.
pub fn write_table_be<B: BitWrite<BE>>(
    backend: &mut B,
    value: u64,
) -> Result<Option<usize>, B::Error> {
    Ok(if let Some(bits) = WRITE_BE.get(value as usize) {
        let len = WRITE_LEN_BE[value as usize] as usize;
        backend.write_bits(*bits as u64, len)?;
        Some(len)
    } else {
        None
    })
}
/// The len we assign to a code that cannot be decoded through the table
pub const MISSING_VALUE_LEN_BE: u8 = 10;
/// Precomputed table for writing gamma codes
pub const READ_BE: &[u8] = &[
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
    27, 28, 29, 30, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12,
    12, 13, 13, 13, 13, 14, 14, 14, 14, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];
/// Precomputed lengths table for reading gamma codes
pub const READ_LEN_BE: &[u8] = &[
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1,
];
/// The len we assign to a code that cannot be decoded through the table
pub const MISSING_VALUE_LEN_LE: u8 = 10;
/// Precomputed table for writing gamma codes
pub const READ_LE: &[u8] = &[
    0, 0, 1, 0, 3, 0, 2, 0, 7, 0, 1, 0, 4, 0, 2, 0, 15, 0, 1, 0, 5, 0, 2, 0, 8, 0, 1, 0, 6, 0, 2,
    0, 0, 0, 1, 0, 3, 0, 2, 0, 9, 0, 1, 0, 4, 0, 2, 0, 16, 0, 1, 0, 5, 0, 2, 0, 10, 0, 1, 0, 6, 0,
    2, 0, 0, 0, 1, 0, 3, 0, 2, 0, 11, 0, 1, 0, 4, 0, 2, 0, 17, 0, 1, 0, 5, 0, 2, 0, 12, 0, 1, 0, 6,
    0, 2, 0, 0, 0, 1, 0, 3, 0, 2, 0, 13, 0, 1, 0, 4, 0, 2, 0, 18, 0, 1, 0, 5, 0, 2, 0, 14, 0, 1, 0,
    6, 0, 2, 0, 0, 0, 1, 0, 3, 0, 2, 0, 7, 0, 1, 0, 4, 0, 2, 0, 19, 0, 1, 0, 5, 0, 2, 0, 8, 0, 1,
    0, 6, 0, 2, 0, 0, 0, 1, 0, 3, 0, 2, 0, 9, 0, 1, 0, 4, 0, 2, 0, 20, 0, 1, 0, 5, 0, 2, 0, 10, 0,
    1, 0, 6, 0, 2, 0, 0, 0, 1, 0, 3, 0, 2, 0, 11, 0, 1, 0, 4, 0, 2, 0, 21, 0, 1, 0, 5, 0, 2, 0, 12,
    0, 1, 0, 6, 0, 2, 0, 0, 0, 1, 0, 3, 0, 2, 0, 13, 0, 1, 0, 4, 0, 2, 0, 22, 0, 1, 0, 5, 0, 2, 0,
    14, 0, 1, 0, 6, 0, 2, 0, 0, 0, 1, 0, 3, 0, 2, 0, 7, 0, 1, 0, 4, 0, 2, 0, 23, 0, 1, 0, 5, 0, 2,
    0, 8, 0, 1, 0, 6, 0, 2, 0, 0, 0, 1, 0, 3, 0, 2, 0, 9, 0, 1, 0, 4, 0, 2, 0, 24, 0, 1, 0, 5, 0,
    2, 0, 10, 0, 1, 0, 6, 0, 2, 0, 0, 0, 1, 0, 3, 0, 2, 0, 11, 0, 1, 0, 4, 0, 2, 0, 25, 0, 1, 0, 5,
    0, 2, 0, 12, 0, 1, 0, 6, 0, 2, 0, 0, 0, 1, 0, 3, 0, 2, 0, 13, 0, 1, 0, 4, 0, 2, 0, 26, 0, 1, 0,
    5, 0, 2, 0, 14, 0, 1, 0, 6, 0, 2, 0, 0, 0, 1, 0, 3, 0, 2, 0, 7, 0, 1, 0, 4, 0, 2, 0, 27, 0, 1,
    0, 5, 0, 2, 0, 8, 0, 1, 0, 6, 0, 2, 0, 0, 0, 1, 0, 3, 0, 2, 0, 9, 0, 1, 0, 4, 0, 2, 0, 28, 0,
    1, 0, 5, 0, 2, 0, 10, 0, 1, 0, 6, 0, 2, 0, 0, 0, 1, 0, 3, 0, 2, 0, 11, 0, 1, 0, 4, 0, 2, 0, 29,
    0, 1, 0, 5, 0, 2, 0, 12, 0, 1, 0, 6, 0, 2, 0, 0, 0, 1, 0, 3, 0, 2, 0, 13, 0, 1, 0, 4, 0, 2, 0,
    30, 0, 1, 0, 5, 0, 2, 0, 14, 0, 1, 0, 6, 0, 2, 0,
];
/// Precomputed lengths table for reading gamma codes
pub const READ_LEN_LE: &[u8] = &[
    10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 9, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3,
    1, 10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 9, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1,
    3, 1, 10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 9, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5,
    1, 3, 1, 10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 9, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1,
    5, 1, 3, 1, 10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 9, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3,
    1, 5, 1, 3, 1, 10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 9, 1, 3, 1, 5, 1, 3, 1, 7, 1,
    3, 1, 5, 1, 3, 1, 10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 9, 1, 3, 1, 5, 1, 3, 1, 7,
    1, 3, 1, 5, 1, 3, 1, 10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 9, 1, 3, 1, 5, 1, 3, 1,
    7, 1, 3, 1, 5, 1, 3, 1, 10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 9, 1, 3, 1, 5, 1, 3,
    1, 7, 1, 3, 1, 5, 1, 3, 1, 10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 9, 1, 3, 1, 5, 1,
    3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 9, 1, 3, 1, 5,
    1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 9, 1, 3, 1,
    5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 9, 1, 3,
    1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 9, 1,
    3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 9,
    1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1, 10, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1,
    9, 1, 3, 1, 5, 1, 3, 1, 7, 1, 3, 1, 5, 1, 3, 1,
];
///Table used to speed up the writing of gamma codes
pub const WRITE_BE: &[u16] = &[
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
    27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
    51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
];
///Table used to speed up the writing of gamma codes
pub const WRITE_LEN_BE: &[u16] = &[
    1, 3, 3, 5, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 13,
];
///Table used to speed up the writing of gamma codes
pub const WRITE_LE: &[u16] = &[
    1, 2, 6, 4, 12, 20, 28, 8, 24, 40, 56, 72, 88, 104, 120, 16, 48, 80, 112, 144, 176, 208, 240,
    272, 304, 336, 368, 400, 432, 464, 496, 32, 96, 160, 224, 288, 352, 416, 480, 544, 608, 672,
    736, 800, 864, 928, 992, 1056, 1120, 1184, 1248, 1312, 1376, 1440, 1504, 1568, 1632, 1696,
    1760, 1824, 1888, 1952, 2016, 64,
];
///Table used to speed up the writing of gamma codes
pub const WRITE_LEN_LE: &[u16] = &[
    1, 3, 3, 5, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 13,
];
///Table used to speed up the skipping of gamma codes
pub const LEN: &[u8] = &[
    1, 3, 3, 5, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 13,
];

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/golomb.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

//! Golomb codes.
//!
//! Given a modulo `b`, the Golomb code of `x` is given by `⌊x / v⌋` in
//! [unary code](BitRead::read_unary) followed by the [minimal binary
//! code](super::minimal_binary) of `x mod v`.
//!
//! For natural numbers distributed with a geometric distribution with base `p`,
//! the optimal code is a Golomb code with [`b = ⌈-log(2 – p) / log(1 – p)⌉`](b).
//!
//! For a faster, less precise alternative, see [Rice codes](super::rice).
//!
//! ## References
//! S. Golomb,
//! "Run-length encodings (Corresp.),"
//! IEEE Transactions on Information Theory, vol. 12, no. 3, pp. 399-401,
//! July 1966, doi: <https://doi.org/10.1109/TIT.1966.1053907>.
//!
//! R. Gallager and D. van Voorhis,
//! "Optimal source codes for geometrically distributed integer alphabets (Corresp.),"
//! IEEE Transactions on Information Theory, vol. 21, no. 2, pp. 228-230,
//! March 1975, doi:  <https://doi.org/10.1109/TIT.1975.1055357>.

use super::minimal_binary::{len_minimal_binary, MinimalBinaryRead, MinimalBinaryWrite};
use crate::traits::*;

/// Returns the length of the Golomb code for `n` with modulo `b`.
#[must_use]
#[inline]
pub fn len_golomb(n: u64, b: u64) -> usize {
    (n / b) as usize + 1 + len_minimal_binary(n % b, b)
}

/// Returns the optimal value of `b` for a geometric distribution of base `p`.
pub fn b(p: f64) -> u64 {
    (-(2.0 - p).ln() / (1.0 - p).ln()).ceil() as u64
}

/// Returns the intended geometric distribution with base `p` for golomb codes
/// with value `b`.
pub fn p(b: u64) -> f64 {
    1.0 / 2.0_f64.powf(1.0 / b as f64)
}

/// Trait for reading Golomb codes.
pub trait GolombRead<E: Endianness>: BitRead<E> + MinimalBinaryRead<E> {
    #[inline(always)]
    fn read_golomb(&mut self, b: u64) -> Result<u64, Self::Error> {
        Ok(self.read_unary()? * b + self.read_minimal_binary(b)?)
    }
}

/// Trait for writing Golomb codes.
pub trait GolombWrite<E: Endianness>: BitWrite<E> + MinimalBinaryWrite<E> {
    #[inline]
    fn write_golomb(&mut self, n: u64, b: u64) -> Result<usize, Self::Error> {
        Ok(self.write_unary(n / b)? + self.write_minimal_binary(n % b, b)?)
    }
}

impl<E: Endianness, B: BitRead<E>> GolombRead<E> for B {}
impl<E: Endianness, B: BitWrite<E>> GolombWrite<E> for B {}

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/mod.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

/*!

Traits for reading and writing instantaneous codes.

This modules contains code for reading and writing instantaneous codes.
Codewords are uniformely indexed from 0 for codes. For example, the
first few words of [unary](crate::traits::BitRead::read_unary),
[γ](gamma), and [δ](delta) codes are:

| Arg |  unary   |    γ    |     δ    |
|-----|---------:|--------:|---------:|
| 0   |        1 |       1 |        1 |
| 1   |       01 |     010 |     0100 |
| 2   |      001 |     011 |     0101 |
| 3   |     0001 |   00100 |    01100 |
| 4   |    00001 |   00101 |    01101 |
| 5   |   000001 |   00110 |    01110 |
| 6   |  0000001 |   00111 |    01111 |
| 7   | 00000001 | 0001000 | 00100000 |

Each code is implemented as a pair of traits for reading and writing
(e.g., [`GammaReadParam`] and [`GammaWriteParam`]). The traits for
reading depend on [`BitRead`], whereas
the traits for writing depend on [`BitWrite`].

The traits ending with `Param` make it possible to specify parameters—for
example, whether to use decoding tables. Usually, one whould instead pull
in scope non-parametric traits such as [`GammaRead`] and [`GammaWrite`],
for which defaults are provided using the mechanism described in the
[`params`] module.

Note that if you are using decoding tables, you must ensure that the
[`peek_bits`](crate::traits::BitRead::peek_bits) method of your
[`BitRead`] implementation returns a sufficient
number of bits: if it does not, an assertion will be triggered in test
mode, but behavior will be unpredictable otherwise. This is unfortunately
difficult to check statically. To stay on the safe side, we recommend
to use a read word of at least 16 bits.

*/
use anyhow::Result;
#[cfg(feature = "mem_dbg")]
use mem_dbg::{MemDbg, MemSize};

use crate::prelude::{BitRead, BitWrite};
pub mod params;

pub mod code;
pub use code::{const_codes, Code, CodeReadDispatcher, CodeWriteDispatcher, ConstCode};
pub use code::{CodeLen, CodeRead, CodeReadDispatch, CodeWrite, CodeWriteDispatch};

pub mod gamma;
pub use gamma::{
    len_gamma, len_gamma_param, GammaRead, GammaReadParam, GammaWrite, GammaWriteParam,
};

pub mod delta;
pub use delta::{
    len_delta, len_delta_param, DeltaRead, DeltaReadParam, DeltaWrite, DeltaWriteParam,
};

pub mod omega;
pub use omega::{len_omega, OmegaRead, OmegaWrite};

pub mod minimal_binary;
pub use minimal_binary::{len_minimal_binary, MinimalBinaryRead, MinimalBinaryWrite};

pub mod zeta;
pub use zeta::{len_zeta, len_zeta_param, ZetaRead, ZetaReadParam, ZetaWrite, ZetaWriteParam};

pub mod pi;
pub use pi::{len_pi, len_pi_web, PiRead, PiWebRead, PiWebWrite, PiWrite};

pub mod golomb;
pub use golomb::{len_golomb, GolombRead, GolombWrite};

pub mod rice;
pub use rice::{len_rice, RiceRead, RiceWrite};

pub mod exp_golomb;
pub use exp_golomb::{len_exp_golomb, ExpGolombRead, ExpGolombWrite};

pub mod vbyte;
pub use vbyte::{len_vbyte, VByteRead, VByteWrite};

use crate::prelude::Endianness;

pub mod delta_tables;
pub mod gamma_tables;
pub mod zeta_tables;

/// A collection trait for reading all the codes supported by this library.
pub trait ReadCodes<E: Endianness>:
    BitRead<E>
    + GammaRead<E>
    + GammaReadParam<E>
    + DeltaRead<E>
    + DeltaReadParam<E>
    + ZetaRead<E>
    + ZetaReadParam<E>
    + OmegaRead<E>
    + MinimalBinaryRead<E>
    + PiRead<E>
    + PiWebRead<E>
    + GolombRead<E>
    + RiceRead<E>
    + ExpGolombRead<E>
    + VByteRead<E>
{
    fn read_code(&mut self, code: Code) -> Result<u64, Self::Error> {
        code.read::<E, Self>(self)
    }
}
impl<E: Endianness, B> ReadCodes<E> for B where
    B: BitRead<E>
        + GammaRead<E>
        + GammaReadParam<E>
        + DeltaRead<E>
        + DeltaReadParam<E>
        + ZetaRead<E>
        + ZetaReadParam<E>
        + OmegaRead<E>
        + MinimalBinaryRead<E>
        + PiRead<E>
        + PiWebRead<E>
        + GolombRead<E>
        + RiceRead<E>
        + ExpGolombRead<E>
        + VByteRead<E>
{
}

/// A collection trait for writing all the codes supported by this library.
pub trait WriteCodes<E: Endianness>:
    BitWrite<E>
    + GammaWrite<E>
    + DeltaWrite<E>
    + ZetaWrite<E>
    + OmegaWrite<E>
    + MinimalBinaryWrite<E>
    + PiWrite<E>
    + PiWebWrite<E>
    + GolombWrite<E>
    + RiceWrite<E>
    + ExpGolombWrite<E>
    + VByteWrite<E>
{
    fn write_code(&mut self, code: Code, value: u64) -> Result<usize, Self::Error> {
        code.write::<E, Self>(self, value)
    }
}
impl<E: Endianness, B> WriteCodes<E> for B where
    B: BitWrite<E>
        + GammaWrite<E>
        + DeltaWrite<E>
        + ZetaWrite<E>
        + OmegaWrite<E>
        + MinimalBinaryWrite<E>
        + PiWrite<E>
        + PiWebWrite<E>
        + GolombWrite<E>
        + RiceWrite<E>
        + ExpGolombWrite<E>
        + VByteWrite<E>
{
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/omega.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2024 Tommaso Fontana
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

//! Elias ω code.
//!
//! Like Elias gamma coding and Elias delta coding, it works by prefixing the
//! positive integer with a representation of its order of magnitude in a
//! universal code. Unlike those other two codes, however, Elias omega
//! recursively encodes that prefix; thus, they are sometimes known as
//! recursive Elias codes.
//!
//! The ω code is decodable in BigEndian order only. This is because the read
//! algorithm requires to peek at the MSB bit of the next value, which is not
//! possible in LittleEndian order. To write in LittleEndian order, we rotate by
//! one the bits to the left, so that the MSB bit is the LSB bit, and we can peek
//! at it.
//!
//! ## Reference
//! Peter Elias.
//! "Universal codeword sets and representations of the integers,"
//! IEEE Transactions on Information Theory, vol. 21, no. 2, pp. 194-203, March
//! 1975, doi:  <https://doi.org/10.1109/TIT.1975.1055349>.

use crate::traits::*;
use common_traits::CastableInto;

fn ceil_log(n: u64) -> u64 {
    n.ilog2() as u64 + (!n.is_power_of_two()) as u64
}

/// Returns the length of the ω code for `n`.
#[inline(always)]
pub fn len_omega(n: u64) -> usize {
    // omega codes are indexed from 1
    recursive_len(n + 1)
}

fn recursive_len(n: u64) -> usize {
    if n <= 1 {
        return 1;
    }
    let l = ceil_log(n.saturating_add(1));
    recursive_len(l - 1) + l as usize
}

/// Trait for reading ω codes.
///
/// This is the trait you should usually pull in scope to read ω codes.
pub trait OmegaRead<E: Endianness>: BitRead<E> {
    // omega codes are indexed from 1
    fn read_omega(&mut self) -> Result<u64, Self::Error> {
        let mut n = 1;
        loop {
            let bit = self.peek_bits(1)?.cast();
            if bit == 0 {
                self.skip_bits(1)?;
                return Ok(n - 1);
            }

            let old_n = n;
            n = self.read_bits(1 + n as usize)?;

            if core::any::TypeId::of::<E>() == core::any::TypeId::of::<LE>() {
                n = (n >> 1) | (1 << old_n);
            }
        }
    }
}

/// Trait for writing ω codes.
///
/// This is the trait you should usually pull in scope to write ω codes.
pub trait OmegaWrite<E: Endianness>: BitWrite<E> {
    fn write_omega(&mut self, n: u64) -> Result<usize, Self::Error> {
        // omega codes are indexed from 1
        Ok(recursive_write::<E, Self>(n + 1, self)? + self.write_bits(0, 1)?)
    }
}

fn recursive_write<E: Endianness, B: BitWrite<E> + ?Sized>(
    mut n: u64,
    writer: &mut B,
) -> Result<usize, B::Error> {
    if n <= 1 {
        return Ok(0);
    }
    let l = ceil_log(n.saturating_add(1));
    if core::any::TypeId::of::<E>() == core::any::TypeId::of::<LE>() {
        // move the front 1 to the back so we can peek it
        n = (n << 1) | 1;
        // clean the highest 1
        n &= u64::MAX >> (64 - l);
    }
    Ok(recursive_write(l - 1, writer)? + writer.write_bits(n, l as usize)?)
}

impl<E: Endianness, B: BitRead<E>> OmegaRead<E> for B {}
impl<E: Endianness, B: BitWrite<E>> OmegaWrite<E> for B {}

#[cfg(test)]
mod test {
    use crate::prelude::*;

    #[test]
    fn test_omega() {
        for (value, expected_be, expected_le) in [
            (0, 0, 0),
            (1, 0b10_0 << (64 - 3), 0b0_01),
            (2, 0b11_0 << (64 - 3), 0b0_11),
            (3, 0b10_100_0 << (64 - 6), 0b0_001_01),
            (4, 0b10_101_0 << (64 - 6), 0b0_011_01),
            (5, 0b10_110_0 << (64 - 6), 0b0_101_01),
            (6, 0b10_111_0 << (64 - 6), 0b0_111_01),
            (7, 0b11_1000_0 << (64 - 7), 0b0_0001_11),
            (15, 0b10_100_10000_0 << (64 - 11), 0b0_00001_001_01),
            (99, 0b10_110_1100100_0 << (64 - 13), 0b0_1001001_101_01),
            (
                999,
                0b11_1001_1111101000_0 << (64 - 17),
                0b0_1111010001_0011_11,
            ),
            (
                999_999,
                0b10_100_10011_11110100001001000000_0 << (64 - 31),
                0b0_11101000010010000001_00111_001_01,
            ),
        ] {
            let mut data = vec![0_u64];
            let mut writer = <BufBitWriter<BE, _>>::new(MemWordWriterVec::new(&mut data));
            writer.write_omega(value).unwrap();
            drop(writer);
            assert_eq!(
                data[0].to_be(),
                expected_be,
                "\nfor value: {}\ngot: {:064b}\nexp: {:064b}\n",
                value,
                data[0].to_be(),
                expected_be,
            );
            println!("");

            let mut data = vec![0_u64];
            let mut writer = <BufBitWriter<LE, _>>::new(MemWordWriterVec::new(&mut data));
            writer.write_omega(value).unwrap();
            drop(writer);
            assert_eq!(
                data[0].to_le(),
                expected_le,
                "\nfor value: {}\ngot: {:064b}\nexp: {:064b}\n",
                value,
                data[0].to_le(),
                expected_le,
            );
            println!("");
        }
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/params.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

/*!

Mechanisms for selecting parameters.

Traits and structures in this file are of no interest for the standard
user. Their purpose is to provide a systematic way, and in particular
a default way, to select parameters for parameterized traits
such as [`GammaReadParam`] and [`GammaWriteParam`].

The traits and structure in this module work closely with the
bitstream readers and writers in [`impls`](crate::impls), which have an
additional type parameter `RP`/`WP` that must
implement marker traits [`ReadParams`] or [`WriteParams`], respectively.
The type is then used as a selector type to provide blanket implementations
of parameterless traits in [`codes`](crate::codes) such as [`GammaRead`],
[`GammaWrite`], [`DeltaRead`], [`DeltaWrite`], and so on.

This module provides default selector types [`DefaultReadParams`] and [`DefaultWriteParams`]
which are also the default value for the parameter `RP`/`WP` in the bitstream
readers and writers in [`crate::impls`]. Type-selected blanket implementations
of all parameterless traits in [`crate::codes`] are provided for the bitstream
readers and writers in [`impls`](crate::impls). Thus, if you not specify a value for the
parameter `RP`/`WP`, you will obtain automatically
the blanket implementations for parameterless traits contained in this module.

However, you can also create new selector types implementing [`ReadParams`]/[`WriteParams`] and
write blanket implementations for the bitstream readers and writers in [`crate::impls`]
where `RP`/`WP` is set to your selector types. Then, by specifying your type as value of the
parameter `RP`/`WP` when creating such readers and writers you will use
automatically your blanket implementations instead of the ones provided by this module.

*/

use crate::codes::*;
use crate::impls::*;
use crate::traits::*;
use common_traits::*;
#[cfg(feature = "mem_dbg")]
use mem_dbg::{MemDbg, MemSize};
use std::error::Error;

/// Marker trait for read-parameters selector types.
///
/// Note that in principle marker traits are not necessary to use
/// selector types, but they are useful to avoid that the user specifies
/// a nonsensical type, and to document the meaning of type parameters.
pub trait ReadParams {}

/// A selector type for read parameters providing reasonable defaults.
///
/// If you want to optimize these choices for your architecture, we suggest to
/// run the benchmarks in the `benchmarks` directory and write your
/// own implementation.
#[derive(Debug, Clone)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct DefaultReadParams;
impl ReadParams for DefaultReadParams {}

macro_rules! impl_default_read_codes {
    ($($endianess:ident),*) => {$(
        impl<WR: WordRead> GammaRead<$endianess>
            for BufBitReader<$endianess, WR, DefaultReadParams>
        where
            WR:: Word: DoubleType + UpcastableInto<u64>,
            <WR::Word as DoubleType>::DoubleType: CastableInto<u64>,
        {
            #[inline(always)]
            fn read_gamma(&mut self) -> Result<u64, Self::Error> {
                // From our tests, the ARM architecture is faster
                // without tables for ɣ codes.
                return self.read_gamma_param::<false>();
            }
        }

        impl<WR: WordRead> DeltaRead<$endianess>
            for BufBitReader<$endianess, WR, DefaultReadParams>
        where
            WR:: Word: DoubleType + UpcastableInto<u64>,
            <WR::Word as DoubleType>::DoubleType: CastableInto<u64>,
        {
            #[inline(always)]
            fn read_delta(&mut self) -> Result<u64, Self::Error> {
                return self.read_delta_param::<false, true>();
            }
        }

        impl<WR: WordRead> ZetaRead<$endianess>
            for BufBitReader<$endianess, WR, DefaultReadParams>
        where
            WR:: Word: DoubleType + UpcastableInto<u64>,
            <WR::Word as DoubleType>::DoubleType: CastableInto<u64>,
        {
            #[inline(always)]
            fn read_zeta(&mut self, k: u64) -> Result<u64, Self::Error> {
                self.read_zeta_param(k)
            }

            #[inline(always)]
            fn read_zeta3(&mut self) -> Result<u64, Self::Error> {
                self.read_zeta3_param::<true>()
            }
        }

        impl<E: Error + Send + Sync + 'static, WR: WordRead<Error = E, Word = u64> + WordSeek<Error = E>> GammaRead<$endianess>
            for BitReader<$endianess, WR, DefaultReadParams>
        where
            WR:: Word: DoubleType + UpcastableInto<u64>,
            <WR::Word as DoubleType>::DoubleType: CastableInto<u64>,
        {
            #[inline(always)]
            fn read_gamma(&mut self) -> Result<u64, Self::Error> {
                // From our tests, the ARM architecture is faster
                // without tables for ɣ codes.
                return self.read_gamma_param::<false>();
            }
        }

        impl<E: Error + Send + Sync + 'static, WR: WordRead<Error = E, Word = u64> + WordSeek<Error = E>> DeltaRead<$endianess>
            for BitReader<$endianess, WR, DefaultReadParams>
        where
            WR:: Word: DoubleType + UpcastableInto<u64>,
            <WR::Word as DoubleType>::DoubleType: CastableInto<u64>,
        {
            #[inline(always)]
            fn read_delta(&mut self) -> Result<u64, Self::Error> {
                return self.read_delta_param::<false, true>();
            }
        }

        impl<E: Error + Send + Sync + 'static, WR: WordRead<Error = E, Word = u64> + WordSeek<Error = E>> ZetaRead<$endianess>
            for BitReader<$endianess, WR, DefaultReadParams>
        where
            WR:: Word: DoubleType + UpcastableInto<u64>,
            <WR::Word as DoubleType>::DoubleType: CastableInto<u64>,
        {
            #[inline(always)]
            fn read_zeta(&mut self, k: u64) -> Result<u64, Self::Error> {
                self.read_zeta_param(k)
            }

            #[inline(always)]
            fn read_zeta3(&mut self) -> Result<u64, Self::Error> {
                self.read_zeta3_param::<true>()
            }
        }
    )*};
}

impl_default_read_codes! {LittleEndian, BigEndian}

/// Marker trait for write-parameters selector types.
///
/// Note that in principle marker traits are not necessary to use
/// selector types, but they are useful to avoid that the user specifies
/// a nonsensical type, and to document the meaning of type parameters.
pub trait WriteParams {}

/// A selector type for write parameters providing reasonable defaults.
///
/// If you want to optimize these choices for your architecture, we suggest to
/// run the benchmarks in the `benchmarks` directory and write your
/// own implementation.
#[derive(Debug, Clone)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct DefaultWriteParams;
impl WriteParams for DefaultWriteParams {}

macro_rules! impl_default_write_codes {
    ($($endianess:ident),*) => {$(
        impl<WR: WordWrite> GammaWrite<$endianess>
            for BufBitWriter<$endianess, WR, DefaultWriteParams>
            where u64: CastableInto<WR::Word>,
        {
            #[inline(always)]
            fn write_gamma(&mut self, value: u64) -> Result<usize, Self::Error> {
                self.write_gamma_param::<true>(value)
            }
        }

        impl<WR: WordWrite, DC: WriteParams> DeltaWrite<$endianess>
            for BufBitWriter<$endianess, WR, DC>
            where u64: CastableInto<WR::Word>,
        {
            #[inline(always)]
            fn write_delta(&mut self, value: u64) -> Result<usize, Self::Error> {
                self.write_delta_param::<true, true>(value)
            }
        }

        impl<WR: WordWrite, DC: WriteParams> ZetaWrite<$endianess>
            for BufBitWriter<$endianess, WR, DC>
            where u64: CastableInto<WR::Word>,
        {
            #[inline(always)]
            fn write_zeta(&mut self, value: u64, k: u64) -> Result<usize, Self::Error> {
                self.write_zeta_param::<true>(value, k)
            }

            #[inline(always)]
            fn write_zeta3(&mut self, value: u64) -> Result<usize, Self::Error> {
                self.write_zeta3_param::<true>(value)
            }
        }

    )*};
}

impl_default_write_codes! {LittleEndian, BigEndian}

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/pi.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2024 Tommaso Fontana
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

//! π codes
//!
//! π codes allow efficient encoding of Zipf distributions that have an
//! exponent even closer to 1 compared to ζ codes.
//!
//! The intended distribution is:
//! Θ( 1 / N^(1 + 2^-k) )
//! so it's optimal for Zipf distributions of exponent α ≈ 1 + 2^−k
//!
//! π web codes are a modified version of π-codes in which 0 is encoded
//! by 1 and any other positive integer n is encoded with a 0 followed by
//! the π-code of n.
//!
//! ## Reference
//! Alberto Apostolico and Guido Drovandi.
//! "Graph Compression by BFS,"
//! Algorithms 2009, 2, 1031-1044; <https://doi.org/10.3390/a2031031>.

use crate::traits::*;

/// Returns the length of the π code for `n`.
///
/// ```rust
/// use dsi_bitstream::codes::len_pi;
///
/// // k = 0
/// assert_eq!(len_pi(0, 0), 1, "π_0(0)");
/// assert_eq!(len_pi(1, 0), 3, "π_0(1)");
/// assert_eq!(len_pi(2, 0), 3, "π_0(2)");
/// assert_eq!(len_pi(3, 0), 5, "π_0(3)");
/// assert_eq!(len_pi(4, 0), 5, "π_0(4)");
/// assert_eq!(len_pi(5, 0), 5, "π_0(5)");
/// assert_eq!(len_pi(6, 0), 5, "π_0(6)");
/// assert_eq!(len_pi(7, 0), 7, "π_0(7)");
///
/// // k = 1
/// assert_eq!(len_pi(0, 1), 2, "π_1(0)");
/// assert_eq!(len_pi(1, 1), 3, "π_1(1)");
/// assert_eq!(len_pi(2, 1), 3, "π_1(2)");
/// assert_eq!(len_pi(3, 1), 5, "π_1(3)");
/// assert_eq!(len_pi(4, 1), 5, "π_1(4)");
/// assert_eq!(len_pi(5, 1), 5, "π_1(5)");
/// assert_eq!(len_pi(6, 1), 5, "π_1(6)");
/// assert_eq!(len_pi(7, 1), 6, "π_1(7)");
///
/// // k = 2
/// assert_eq!(len_pi(0, 2), 3, "π_2(0)");
/// assert_eq!(len_pi(1, 2), 4, "π_2(1)");
/// assert_eq!(len_pi(2, 2), 4, "π_2(2)");
/// assert_eq!(len_pi(3, 2), 5, "π_2(3)");
/// assert_eq!(len_pi(4, 2), 5, "π_2(4)");
/// assert_eq!(len_pi(5, 2), 5, "π_2(5)");
/// assert_eq!(len_pi(6, 2), 5, "π_2(6)");
/// assert_eq!(len_pi(7, 2), 6, "π_2(7)");
///
/// // k = 3
/// assert_eq!(len_pi(0, 3), 4, "π_3(0)");
/// assert_eq!(len_pi(1, 3), 5, "π_3(1)");
/// assert_eq!(len_pi(2, 3), 5, "π_3(2)");
/// assert_eq!(len_pi(3, 3), 6, "π_3(3)");
/// assert_eq!(len_pi(4, 3), 6, "π_3(4)");
/// assert_eq!(len_pi(5, 3), 6, "π_3(5)");
/// assert_eq!(len_pi(6, 3), 6, "π_3(6)");
/// assert_eq!(len_pi(7, 3), 7, "π_3(7)");
/// ```
#[must_use]
#[inline]
pub fn len_pi(mut n: u64, k: u64) -> usize {
    n += 1; // π codes are indexed from 1
    let rem = n.ilog2() as usize;
    let h = 1 + rem;
    let l = h.div_ceil(1 << k);
    k as usize + l + rem
}

/// Trait for reading π codes.
///
/// This is the trait you should usually pull in scope to read π codes.
pub trait PiRead<E: Endianness>: BitRead<E> {
    #[inline]
    fn read_pi(&mut self, k: u64) -> Result<u64, Self::Error> {
        let l = self.read_unary()? + 1;
        let v = self.read_bits(k as usize)?;
        let h = l * (1 << k) - v;
        let r = h - 1;
        let rem = self.read_bits(r as usize)?;
        Ok((1 << r) + rem - 1)
    }
}

/// Trait for writing π codes.
///
/// This is the trait you should usually pull in scope to write π codes.
pub trait PiWrite<E: Endianness>: BitWrite<E> {
    #[inline]
    fn write_pi(&mut self, mut n: u64, k: u64) -> Result<usize, Self::Error> {
        n += 1; // π codes are indexed from 1
        let r = n.ilog2() as usize;
        let h = 1 + r;
        let l = h.div_ceil(1 << k);
        let v = (l * (1 << k) - h) as u64;
        let rem = n & !(u64::MAX << r);

        let mut written_bits = 0;
        written_bits += self.write_unary((l - 1) as u64)?;
        written_bits += self.write_bits(v, k as usize)?;
        written_bits += self.write_bits(rem, r)?;

        Ok(written_bits)
    }
}

impl<E: Endianness, B: BitRead<E> + ?Sized> PiRead<E> for B {}
impl<E: Endianness, B: BitWrite<E> + ?Sized> PiWrite<E> for B {}

/// Returns the length of the π web code for `n`.
#[must_use]
#[inline(always)]
pub fn len_pi_web(n: u64, k: u64) -> usize {
    1 + if n == 0 { 0 } else { len_pi(n - 1, k) }
}

/// Trait for reading π web codes.
///
/// This is the trait you should usually pull in scope to read π web codes.
pub trait PiWebRead<E: Endianness>: BitRead<E> + PiRead<E> {
    fn read_pi_web(&mut self, k: u64) -> Result<u64, Self::Error> {
        if self.read_bits(1)? == 1 {
            Ok(0)
        } else {
            Ok(self.read_pi(k)? + 1)
        }
    }
}

/// Trait for writing π web codes.
///
/// This is the trait you should usually pull in scope to write π web codes.
pub trait PiWebWrite<E: Endianness>: BitWrite<E> + PiWrite<E> {
    #[inline(always)]
    fn write_pi_web(&mut self, n: u64, k: u64) -> Result<usize, Self::Error> {
        if n == 0 {
            self.write_bits(1, 1)
        } else {
            Ok(self.write_bits(0, 1)? + self.write_pi(n - 1, k)?)
        }
    }
}

impl<E: Endianness, B: BitRead<E> + PiRead<E> + ?Sized> PiWebRead<E> for B {}
impl<E: Endianness, B: BitWrite<E> + PiWrite<E> + ?Sized> PiWebWrite<E> for B {}

#[cfg(test)]
mod test {
    use crate::prelude::*;

    #[test]
    fn test_pi_roundtrip() {
        let k = 3;
        for value in 0..1_000_000 {
            let mut data = vec![0_u64];
            let mut writer = <BufBitWriter<BE, _>>::new(MemWordWriterVec::new(&mut data));
            let code_len = writer.write_pi(value, k).unwrap();
            assert_eq!(code_len, len_pi(value, k));
            drop(writer);
            let mut reader = <BufBitReader<BE, _>>::new(MemWordReader::new(&data));
            assert_eq!(
                reader.read_pi(k).unwrap(),
                value,
                "for value: {} with k {}",
                value,
                k
            );
        }
    }

    #[test]
    fn test_pi() {
        for (k, value, expected) in [
            (2, 20, 0b01_11_0101 << (64 - 8)),
            (2, 0, 0b111 << (64 - 3)),
            (2, 1, 0b1100 << (64 - 4)),
            (2, 2, 0b1101 << (64 - 4)),
            (2, 3, 0b1_0100 << (64 - 5)),
            (2, 4, 0b1_0101 << (64 - 5)),
            (2, 5, 0b1_0110 << (64 - 5)),
            (2, 6, 0b1_0111 << (64 - 5)),
            (2, 7, 0b10_0000 << (64 - 6)),
            (3, 0, 0b1111 << (64 - 4)),
            (3, 1, 0b1_1100 << (64 - 5)),
            (3, 2, 0b1_1101 << (64 - 5)),
            (3, 3, 0b11_0100 << (64 - 6)),
            (3, 4, 0b11_0101 << (64 - 6)),
            (3, 5, 0b11_0110 << (64 - 6)),
            (3, 6, 0b11_0111 << (64 - 6)),
            (3, 7, 0b110_0000 << (64 - 7)),
        ] {
            let mut data = vec![0_u64];
            let mut writer = <BufBitWriter<BE, _>>::new(MemWordWriterVec::new(&mut data));
            let code_len = writer.write_pi(value, k).unwrap();
            drop(writer);
            assert_eq!(
                data[0].to_be(),
                expected,
                "\nfor value: {} with k {}\ngot: {:064b}\nexp: {:064b}\ngot_len: {} exp_len: {}\n",
                value,
                k,
                data[0].to_be(),
                expected,
                code_len,
                len_pi(value, k),
            );
        }
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/rice.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

//! Rice codes.
//!
//! Rice codes (AKA Golomb–Rice codes) are a form of approximated [Golomb
//! codes](crate::codes::golomb) in which the parameter `b` is a power of two.
//! This restriction makes the code less precise in modeling data with a
//! geometric distribution, but encoding and decoding can be performed without
//! any integer arithmetic, and much more quickly.
//!
//! For natural numbers distributed with a geometric distribution with base `p`,
//! the base-2 logarithm of the optimal Rice code is [`⌈log₂(log((√5 + 1)/2) /
//! log(1 - p))⌉`](log2_b). See [reference](https://tda.jpl.nasa.gov/progress_report/42-159/159E.pdf).
//!
//! ## Reference
//! Aaron Kiely,
//! "Selecting the Golomb parameter in Rice coding,"
//! Interplanetary Network Progress report 42-159 (2004) Jet Propulsion Laboratory.

use crate::traits::*;

/// Returns the length of the Rice code for `n` with parameter `log2_b`.
#[must_use]
#[inline]
pub fn len_rice(n: u64, log2_b: usize) -> usize {
    (n >> log2_b) as usize + 1 + log2_b
}

/// Returns the optimal value of `log2_b` for a geometric distribution of base `p`.
pub fn log2_b(p: f64) -> usize {
    ((-((5f64.sqrt() + 1.0) / 2.0).ln() / (-p).ln_1p()).log2()).ceil() as usize
}

/// Return the intended geometric distribution with base `p` for golomb codes
/// with value `log2_b`.
pub fn p(log2_b: u64) -> f64 {
    crate::codes::golomb::p(1 << log2_b)
}

/// Trait for reading Rice codes.
pub trait RiceRead<E: Endianness>: BitRead<E> {
    #[inline(always)]
    fn read_rice(&mut self, log2_b: usize) -> Result<u64, Self::Error> {
        Ok((self.read_unary()? << log2_b) + self.read_bits(log2_b)?)
    }
}

/// Trait for writing Rice codes.
pub trait RiceWrite<E: Endianness>: BitWrite<E> {
    #[inline]
    fn write_rice(&mut self, n: u64, log2_b: usize) -> Result<usize, Self::Error> {
        let mut written_bits = self.write_unary(n >> log2_b)?;
        #[cfg(feature = "checks")]
        {
            // Clean up n in case checks are enabled
            let n = n & (1_u128 << log2_b).wrapping_sub(1) as u64;
            written_bits += self.write_bits(n, log2_b)?;
        }
        #[cfg(not(feature = "checks"))]
        {
            written_bits += self.write_bits(n, log2_b)?;
        }
        Ok(written_bits)
    }
}

impl<E: Endianness, B: BitRead<E>> RiceRead<E> for B {}
impl<E: Endianness, B: BitWrite<E>> RiceWrite<E> for B {}

#[cfg(test)]
#[test]
fn test_log2_b() {
    use crate::prelude::golomb::b;

    let mut p = 1.0;
    for _ in 0..100 {
        p *= 0.9;
        let golomb = b(p);
        if golomb & -(golomb as i64) as u64 == golomb {
            assert_eq!(golomb, 1 << log2_b(p));
        }
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/table_params.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

/*!

Mechanisms for selecting parameters.

Traits and structures in this file are of no interest for the standard
user. Their purpose is to provide a systematic way, and in particular
a default way, to select parameters for parameterized traits
such as [`GammaReadParam`] and [`GammaWriteParam`].

The traits and structure in this module work closely with the
bitstream readers and writers in [`crate::impls`], which have an
additional type parameter `RP`/`WP` that must be a type implementing [`ReadParams`] or
[`WriteParams`], respectively. These traits have no methods, but the
type assigned to the parameter can be used as a selector for a blanket implementation
of all parameterless traits in [`crate::codes`] such as [`GammaRead`],
[`GammaWrite`], [`DeltaRead`], [`DeltaWrite`], and so on.

The default implementation of [`ReadParams`] and [`WriteParams`] are
[`DefaultReadParams`] and [`DefaultWriteParams`], respectively. These
are also the default value for the parameter `RP`/`WP` in the bitstream
readers and writers in [`crate::impls`]. Thus, if you not specify
a value for the parameter `RP`/`WP`, you will obtain automatically
the blanket implementations for parameterless traits contained in this module.

However, you can also create a new type implementing [`ReadParams`]/[`WriteParams`] and
write blanket implementations for the bitstream readers and writers in [`crate::impls`],
fixing `RP`/`WP` to your type. Then, by specifying your type as value of the
parameter `RP`/`WP` when creating such readers and writers you will use
automatically your blanket implementations instead of the ones provided by this module.

*/

use crate::codes::*;
use crate::impls::*;
use crate::traits::*;
use common_traits::*;
#[cfg(feature = "mem_dbg")]
use mem_dbg::{MemDbg, MemSize};
use std::error::Error;

/// Selection trait for parameters of code-reading methods.
pub trait ReadParams {}

/// An implementation of [`ReadParams`] providing reasonable defaults.
///
/// If you want to optimize these choices for your architecture, we suggest to
/// run the benchmarks in the `benchmarks` directory and write your
/// own implementation.
#[derive(Debug, Clone)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct DefaultReadParams;
impl ReadParams for DefaultReadParams {}

macro_rules! impl_default_read_codes {
    ($($endianess:ident),*) => {$(
        impl<WR: WordRead> GammaRead<$endianess>
            for BufBitReader<$endianess, WR, DefaultReadParams>
        where
            WR:: Word: DoubleType + UpcastableInto<u64>,
            <WR::Word as DoubleType>::DoubleType: CastableInto<u64>,
        {
            #[inline(always)]
            fn read_gamma(&mut self) -> Result<u64, Self::Error> {
                // From our tests, the ARM architecture is faster
                // without tables for ɣ codes.
                return self.read_gamma_param::<false>();
            }
        }

        impl<WR: WordRead> DeltaRead<$endianess>
            for BufBitReader<$endianess, WR, DefaultReadParams>
        where
            WR:: Word: DoubleType + UpcastableInto<u64>,
            <WR::Word as DoubleType>::DoubleType: CastableInto<u64>,
        {
            #[inline(always)]
            fn read_delta(&mut self) -> Result<u64, Self::Error> {
                return self.read_delta_param::<false, true>();
            }

        }

        impl<WR: WordRead> ZetaRead<$endianess>
            for BufBitReader<$endianess, WR, DefaultReadParams>
        where
            WR:: Word: DoubleType + UpcastableInto<u64>,
            <WR::Word as DoubleType>::DoubleType: CastableInto<u64>,
        {
            #[inline(always)]
            fn read_zeta(&mut self, k: u64) -> Result<u64, Self::Error> {
                self.read_zeta_param(k)
            }

            #[inline(always)]
            fn read_zeta3(&mut self) -> Result<u64, Self::Error> {
                self.read_zeta3_param::<true>()
            }
        }

        impl<E: Error, WR: WordRead<Error = E, Word = u64> + WordSeek<Error = E>> GammaRead<$endianess>
            for BitReader<$endianess, WR, DefaultReadParams>
        where
            WR:: Word: DoubleType + UpcastableInto<u64>,
            <WR::Word as DoubleType>::DoubleType: CastableInto<u64>,
        {
            #[inline(always)]
            fn read_gamma(&mut self) -> Result<u64, Self::Error> {
                // From our tests, the ARM architecture is faster
                // without tables for ɣ codes.
                return self.read_gamma_param::<false>();
            }
        }

        impl<E: Error, WR: WordRead<Error = E, Word = u64> + WordSeek<Error = E>> DeltaRead<$endianess>
            for BitReader<$endianess, WR, DefaultReadParams>
        where
            WR:: Word: DoubleType + UpcastableInto<u64>,
            <WR::Word as DoubleType>::DoubleType: CastableInto<u64>,
        {
            #[inline(always)]
            fn read_delta(&mut self) -> Result<u64, Self::Error> {
                return self.read_delta_param::<false, true>();
            }
        }

        impl<E: Error, WR: WordRead<Error = E, Word = u64> + WordSeek<Error = E>> ZetaRead<$endianess>
            for BitReader<$endianess, WR, DefaultReadParams>
        where
            WR:: Word: DoubleType + UpcastableInto<u64>,
            <WR::Word as DoubleType>::DoubleType: CastableInto<u64>,
        {
            #[inline(always)]
            fn read_zeta(&mut self, k: u64) -> Result<u64, Self::Error> {
                self.read_zeta_param(k)
            }

            #[inline(always)]
            fn read_zeta3(&mut self) -> Result<u64, Self::Error> {
                self.read_zeta3_param::<true>()
            }
        }
    )*};
}

impl_default_read_codes! {LittleEndian, BigEndian}

/// Selection trait for parameters of code-writing methods.
pub trait WriteParams {}

/// An implementation of [`WriteParams`] providing reasonable defaults.
///
/// If you want to optimize these choices for your architecture, we suggest to
/// run the benchmarks in the `benchmarks` directory and write your
/// own implementation.
#[derive(Debug, Clone)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct DefaultWriteParams;
impl WriteParams for DefaultWriteParams {}

macro_rules! impl_default_write_codes {
    ($($endianess:ident),*) => {$(
        impl<WR: WordWrite> GammaWrite<$endianess>
            for BufBitWriter<$endianess, WR, DefaultWriteParams>
            where u64: CastableInto<WR::Word>,
        {
            #[inline(always)]
            fn write_gamma(&mut self, value: u64) -> Result<usize, Self::Error> {
                self.write_gamma_param::<true>(value)
            }
        }

        impl<WR: WordWrite, DC: WriteParams> DeltaWrite<$endianess>
            for BufBitWriter<$endianess, WR, DC>
            where u64: CastableInto<WR::Word>,
        {
            #[inline(always)]
            fn write_delta(&mut self, value: u64) -> Result<usize, Self::Error> {
                self.write_delta_param::<true, true>(value)
            }
        }

        impl<WR: WordWrite, DC: WriteParams> ZetaWrite<$endianess>
            for BufBitWriter<$endianess, WR, DC>
            where u64: CastableInto<WR::Word>,
        {
            #[inline(always)]
            fn write_zeta(&mut self, value: u64, k: u64) -> Result<usize, Self::Error> {
                self.write_zeta_param::<true>(value, k)
            }

            #[inline(always)]
            fn write_zeta3(&mut self, value: u64) -> Result<usize, Self::Error> {
                self.write_zeta3_param::<true>(value)
            }
        }

    )*};
}

impl_default_write_codes! {LittleEndian, BigEndian}

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/vbyte.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

//! VByte code
//!
//! A complete version of variable length byte codes (like [`LEB128`] or [`VLQ`]).
//!
//! Both [`LEB128`] and [`VLQ`] use the 8th bit of each byte to signal whether the
//! next byte is part of the number or not. This implies that 0 can be represented
//! in multiple ways, which is not ideal for compression. This implementation
//! does the same but subtract the biggest possible value for each byte to
//! ensure that the number is represented in a unique way.
//!
//! Moreover, instead of using the highest bit to signal the end of the number,
//! we accumulate the number of bytes used to represent the number in the first
//! byte. This allows to compute the length of the code using a single `CLZ`
//! instruction.
//!
//! This is a byte aligned code so it's faster to encode / decode on byte-stream
//! than bit-streams, so we provide also the functions
//! [`vbyte_encode`] and [`vbyte_decode`] that can be used on
//! [`std::io::Read`] and [`std::io::Write`] objects.
//!
//! [`LEB128`]: https://en.wikipedia.org/wiki/LEB128
//! [`VLQ`]: https://en.wikipedia.org/wiki/Variable-length_quantity

use crate::traits::*;
use common_traits::CastableInto;

const UPPER_BOUND_1: u64 = 128;
const UPPER_BOUND_2: u64 = 128_u64.pow(2) + UPPER_BOUND_1;
const UPPER_BOUND_3: u64 = 128_u64.pow(3) + UPPER_BOUND_2;
const UPPER_BOUND_4: u64 = 128_u64.pow(4) + UPPER_BOUND_3;
const UPPER_BOUND_5: u64 = 128_u64.pow(5) + UPPER_BOUND_4;
const UPPER_BOUND_6: u64 = 128_u64.pow(6) + UPPER_BOUND_5;
const UPPER_BOUND_7: u64 = 128_u64.pow(7) + UPPER_BOUND_6;
const UPPER_BOUND_8: u64 = 128_u64.pow(8) + UPPER_BOUND_7;

/// Returns the length of the VByte code for `value` in bytes.
#[must_use]
#[inline]
pub fn len_vbyte_bytes(value: u64) -> usize {
    if value < UPPER_BOUND_1 {
        return 1;
    }
    if value < UPPER_BOUND_2 {
        return 2;
    }
    if value < UPPER_BOUND_3 {
        return 3;
    }
    if value < UPPER_BOUND_4 {
        return 4;
    }
    if value < UPPER_BOUND_5 {
        return 5;
    }
    if value < UPPER_BOUND_6 {
        return 6;
    }
    if value < UPPER_BOUND_7 {
        return 7;
    }
    if value < UPPER_BOUND_8 {
        return 8;
    }
    9
}

/// Returns the length of the VByte code for `value` in bits.
#[must_use]
#[inline]
pub fn len_vbyte(value: u64) -> usize {
    8 * len_vbyte_bytes(value)
}

/// Trait for reading VByte codes.
pub trait VByteRead<E: Endianness>: BitRead<E> {
    #[inline(always)]
    fn read_vbyte(&mut self) -> Result<u64, Self::Error> {
        let len = self.peek_bits(8)?.cast() as u8;
        let len = if core::any::TypeId::of::<E>() == core::any::TypeId::of::<BigEndian>() {
            len.leading_ones() as u8
        } else {
            len.trailing_ones() as u8
        }
        .min(8);
        self.skip_bits((1 + len as usize).min(8))?;

        match len {
            0 => self.read_bits(8 - 1),
            1 => self.read_bits(16 - 2).map(|x| x + UPPER_BOUND_1),
            2 => self.read_bits(24 - 3).map(|x| x + UPPER_BOUND_2),
            3 => self.read_bits(32 - 4).map(|x| x + UPPER_BOUND_3),
            4 => self.read_bits(40 - 5).map(|x| x + UPPER_BOUND_4),
            5 => self.read_bits(48 - 6).map(|x| x + UPPER_BOUND_5),
            6 => self.read_bits(56 - 7).map(|x| x + UPPER_BOUND_6),
            7 => self.read_bits(64 - 8).map(|x| x + UPPER_BOUND_7),
            8.. => self.read_bits(64).map(|x| x + UPPER_BOUND_8),
        }
    }
}

/// Trait for writing VByte codes.
pub trait VByteWrite<E: Endianness>: BitWrite<E> {
    #[inline]
    fn write_vbyte(&mut self, mut value: u64) -> Result<usize, Self::Error> {
        // endianness dependant constant
        macro_rules! edc {
            ($be:literal, $le:literal) => {
                if core::any::TypeId::of::<E>() == core::any::TypeId::of::<LittleEndian>() {
                    $le
                } else {
                    $be
                }
            };
        }

        if value < UPPER_BOUND_1 {
            self.write_bits(0, 1)?;
            return self.write_bits(value, 8 - 1);
        }
        if value < UPPER_BOUND_2 {
            value -= UPPER_BOUND_1;
            debug_assert!((value >> 8) < (1 << 6));
            self.write_bits(edc!(0b10, 0b01), 2)?;
            return self.write_bits(value, 16 - 2);
        }
        if value < UPPER_BOUND_3 {
            value -= UPPER_BOUND_2;
            debug_assert!((value >> 16) < (1 << 5));
            self.write_bits(edc!(0b110, 0b011), 3)?;
            return self.write_bits(value, 24 - 3);
        }
        if value < UPPER_BOUND_4 {
            value -= UPPER_BOUND_3;
            debug_assert!((value >> 24) < (1 << 4));
            self.write_bits(edc!(0b1110, 0b0111), 4)?;
            return self.write_bits(value, 32 - 4);
        }
        if value < UPPER_BOUND_5 {
            value -= UPPER_BOUND_4;
            debug_assert!((value >> 32) < (1 << 3));
            self.write_bits(edc!(0b11110, 0b01111), 5)?;
            return self.write_bits(value, 40 - 5);
        }
        if value < UPPER_BOUND_6 {
            value -= UPPER_BOUND_5;
            debug_assert!((value >> 40) < (1 << 2));
            self.write_bits(edc!(0b111110, 0b011111), 6)?;
            return self.write_bits(value, 48 - 6);
        }
        if value < UPPER_BOUND_7 {
            value -= UPPER_BOUND_6;
            debug_assert!((value >> 48) < (1 << 1));
            self.write_bits(edc!(0b1111110, 0b0111111), 7)?;
            return self.write_bits(value, 56 - 7);
        }
        if value < UPPER_BOUND_8 {
            value -= UPPER_BOUND_7;
            self.write_bits(edc!(0b11111110, 0b01111111), 8)?;
            return self.write_bits(value, 64 - 8);
        }
        // TODO!: we can save the last bit of the unary code here and
        // just write 8 ones
        self.write_bits(0b11111111, 8)?;
        self.write_bits(value - UPPER_BOUND_8, 64)
    }
}

impl<E: Endianness, B: BitRead<E>> VByteRead<E> for B {}
impl<E: Endianness, B: BitWrite<E>> VByteWrite<E> for B {}

/// Encodes an integer to a byte stream using VByte codes and return the
/// number of bytes written.
#[inline(always)]
pub fn vbyte_encode<E: Endianness, W: std::io::Write>(
    value: u64,
    writer: &mut W,
) -> std::io::Result<usize> {
    if core::any::TypeId::of::<E>() == core::any::TypeId::of::<BigEndian>() {
        vbyte_encode_be(value, writer)
    } else {
        vbyte_encode_le(value, writer)
    }
}

#[inline(always)]
/// Decodes an integer from a byte stream using VByte codes.
pub fn vbyte_decode<E: Endianness, R: std::io::Read>(reader: &mut R) -> std::io::Result<u64> {
    if core::any::TypeId::of::<E>() == core::any::TypeId::of::<BigEndian>() {
        vbyte_decode_be(reader)
    } else {
        vbyte_decode_le(reader)
    }
}

/// Encodes an integer to a little endian byte stream using VByte codes and
/// return the number of bytes written.
pub fn vbyte_encode_le<W: std::io::Write>(
    mut value: u64,
    writer: &mut W,
) -> std::io::Result<usize> {
    if value < UPPER_BOUND_1 {
        writer.write_all(&[value as u8])?;
        return Ok(1);
    }
    if value < UPPER_BOUND_2 {
        value -= UPPER_BOUND_1;
        debug_assert!((value >> 8) < (1 << 6));
        writer.write_all(&[0x80 | (value & 0b11_1111) as u8, (value >> 6) as u8])?;
        return Ok(2);
    }
    if value < UPPER_BOUND_3 {
        value -= UPPER_BOUND_2;
        debug_assert!((value >> 16) < (1 << 5));
        writer.write_all(&[
            0xC0 | (value & 0b1_1111) as u8,
            (value >> 5) as u8,
            (value >> 13) as u8,
        ])?;
        return Ok(3);
    }
    if value < UPPER_BOUND_4 {
        value -= UPPER_BOUND_3;
        debug_assert!((value >> 24) < (1 << 4));
        writer.write_all(&[
            0xE0 | (value & 0b1111) as u8,
            (value >> 4) as u8,
            (value >> 12) as u8,
            (value >> 20) as u8,
        ])?;
        return Ok(4);
    }
    if value < UPPER_BOUND_5 {
        value -= UPPER_BOUND_4;
        debug_assert!((value >> 32) < (1 << 3));
        writer.write_all(&[
            0xF0 | (value & 0b111) as u8,
            (value >> 3) as u8,
            (value >> 11) as u8,
            (value >> 19) as u8,
            (value >> 27) as u8,
        ])?;
        return Ok(5);
    }
    if value < UPPER_BOUND_6 {
        value -= UPPER_BOUND_5;
        debug_assert!((value >> 40) < (1 << 2));
        writer.write_all(&[
            0xF8 | (value & 0b11) as u8,
            (value >> 2) as u8,
            (value >> 10) as u8,
            (value >> 18) as u8,
            (value >> 26) as u8,
            (value >> 34) as u8,
        ])?;
        return Ok(6);
    }
    if value < UPPER_BOUND_7 {
        value -= UPPER_BOUND_6;
        debug_assert!((value >> 48) < (1 << 1));
        writer.write_all(&[
            0xFC | (value & 0b1) as u8,
            (value >> 1) as u8,
            (value >> 9) as u8,
            (value >> 17) as u8,
            (value >> 25) as u8,
            (value >> 33) as u8,
            (value >> 41) as u8,
        ])?;
        return Ok(7);
    }
    if value < UPPER_BOUND_8 {
        value -= UPPER_BOUND_7;
        writer.write_all(&[
            0xFE,
            value as u8,
            (value >> 8) as u8,
            (value >> 16) as u8,
            (value >> 24) as u8,
            (value >> 32) as u8,
            (value >> 40) as u8,
            (value >> 48) as u8,
        ])?;
        return Ok(8);
    }

    writer.write_all(&[
        0xFF,
        value as u8,
        (value >> 8) as u8,
        (value >> 16) as u8,
        (value >> 24) as u8,
        (value >> 32) as u8,
        (value >> 40) as u8,
        (value >> 48) as u8,
        (value >> 56) as u8,
    ])?;
    Ok(9)
}

/// Encodes an integer to a big endian byte stream using VByte codes and return
/// the number of bytes written.
pub fn vbyte_encode_be<W: std::io::Write>(
    mut value: u64,
    writer: &mut W,
) -> std::io::Result<usize> {
    if value < UPPER_BOUND_1 {
        writer.write_all(&[value as u8])?;
        return Ok(1);
    }
    if value < UPPER_BOUND_2 {
        value -= UPPER_BOUND_1;
        debug_assert!((value >> 8) < (1 << 6));
        writer.write_all(&[0x80 | (value >> 8) as u8, value as u8])?;
        return Ok(2);
    }
    if value < UPPER_BOUND_3 {
        value -= UPPER_BOUND_2;
        debug_assert!((value >> 16) < (1 << 5));
        writer.write_all(&[0xC0 | (value >> 16) as u8, (value >> 8) as u8, value as u8])?;
        return Ok(3);
    }
    if value < UPPER_BOUND_4 {
        value -= UPPER_BOUND_3;
        debug_assert!((value >> 24) < (1 << 4));
        writer.write_all(&[
            0xE0 | (value >> 24) as u8,
            (value >> 16) as u8,
            (value >> 8) as u8,
            value as u8,
        ])?;
        return Ok(4);
    }
    if value < UPPER_BOUND_5 {
        value -= UPPER_BOUND_4;
        debug_assert!((value >> 32) < (1 << 3));
        writer.write_all(&[
            0xF0 | (value >> 32) as u8,
            (value >> 24) as u8,
            (value >> 16) as u8,
            (value >> 8) as u8,
            value as u8,
        ])?;
        return Ok(5);
    }
    if value < UPPER_BOUND_6 {
        value -= UPPER_BOUND_5;
        debug_assert!((value >> 40) < (1 << 2));
        writer.write_all(&[
            0xF8 | (value >> 40) as u8,
            (value >> 32) as u8,
            (value >> 24) as u8,
            (value >> 16) as u8,
            (value >> 8) as u8,
            value as u8,
        ])?;
        return Ok(6);
    }
    if value < UPPER_BOUND_7 {
        value -= UPPER_BOUND_6;
        debug_assert!((value >> 48) < (1 << 1));
        writer.write_all(&[
            0xFC | (value >> 48) as u8,
            (value >> 40) as u8,
            (value >> 32) as u8,
            (value >> 24) as u8,
            (value >> 16) as u8,
            (value >> 8) as u8,
            value as u8,
        ])?;
        return Ok(7);
    }
    if value < UPPER_BOUND_8 {
        value -= UPPER_BOUND_7;
        writer.write_all(&[
            0xFE,
            (value >> 48) as u8,
            (value >> 40) as u8,
            (value >> 32) as u8,
            (value >> 24) as u8,
            (value >> 16) as u8,
            (value >> 8) as u8,
            value as u8,
        ])?;
        return Ok(8);
    }

    writer.write_all(&[
        0xFF,
        (value >> 56) as u8,
        (value >> 48) as u8,
        (value >> 40) as u8,
        (value >> 32) as u8,
        (value >> 24) as u8,
        (value >> 16) as u8,
        (value >> 8) as u8,
        value as u8,
    ])?;
    Ok(9)
}

/// Decodes an integer from a little endian byte stream using VByte codes.
pub fn vbyte_decode_le<R: std::io::Read>(reader: &mut R) -> std::io::Result<u64> {
    let mut data = [0; 9];
    reader.read_exact(&mut data[..1])?;
    let x = data[0];
    if x < 0x80 {
        return Ok(x as u64);
    }
    if x < 0xC0 {
        reader.read_exact(&mut data[1..2])?;
        let x = (((x & !0xC0) as u64) | (data[1] as u64) << 6) + UPPER_BOUND_1;
        return Ok(x);
    }
    if x < 0xE0 {
        reader.read_exact(&mut data[1..3])?;
        let x =
            (((x & !0xE0) as u64) | (data[1] as u64) << 5 | (data[2] as u64) << 13) + UPPER_BOUND_2;
        return Ok(x);
    }
    if x < 0xF0 {
        reader.read_exact(&mut data[1..4])?;
        let x = (((x & !0xF0) as u64)
            | (data[1] as u64) << 4
            | (data[2] as u64) << 12
            | (data[3] as u64) << 20)
            + UPPER_BOUND_3;
        return Ok(x);
    }
    if x < 0xF8 {
        reader.read_exact(&mut data[1..5])?;
        let x = (((x & !0xF8) as u64)
            | (data[1] as u64) << 3
            | (data[2] as u64) << 11
            | (data[3] as u64) << 19
            | (data[4] as u64) << 27)
            + UPPER_BOUND_4;
        return Ok(x);
    }
    if x < 0xFC {
        reader.read_exact(&mut data[1..6])?;
        let x = (((x & !0xFC) as u64)
            | (data[1] as u64) << 2
            | (data[2] as u64) << 10
            | (data[3] as u64) << 18
            | (data[4] as u64) << 26
            | (data[5] as u64) << 34)
            + UPPER_BOUND_5;
        return Ok(x);
    }
    if x < 0xFE {
        reader.read_exact(&mut data[1..7])?;
        let x = (((x & !0xFE) as u64)
            | (data[1] as u64) << 1
            | (data[2] as u64) << 9
            | (data[3] as u64) << 17
            | (data[4] as u64) << 25
            | (data[5] as u64) << 33
            | (data[6] as u64) << 41)
            + UPPER_BOUND_6;
        return Ok(x);
    }
    if x < 0xFF {
        reader.read_exact(&mut data[1..8])?;
        let x = ((data[1] as u64)
            | (data[2] as u64) << 8
            | (data[3] as u64) << 16
            | (data[4] as u64) << 24
            | (data[5] as u64) << 32
            | (data[6] as u64) << 40
            | (data[7] as u64) << 48)
            + UPPER_BOUND_7;
        return Ok(x);
    }

    reader.read_exact(&mut data[1..9])?;
    let x = u64::from_le_bytes(data[1..].try_into().unwrap());

    Ok(x)
}

/// Decodes an integer from a big endian byte stream using VByte codes.
pub fn vbyte_decode_be<R: std::io::Read>(reader: &mut R) -> std::io::Result<u64> {
    let mut data = [0; 9];
    reader.read_exact(&mut data[..1])?;
    let x = data[0];
    if x < 0x80 {
        return Ok(x as u64);
    }
    if x < 0xC0 {
        reader.read_exact(&mut data[1..2])?;
        let x = (((x & !0xC0) as u64) << 8 | data[1] as u64) + UPPER_BOUND_1;
        return Ok(x);
    }
    if x < 0xE0 {
        reader.read_exact(&mut data[1..3])?;
        let x =
            (((x & !0xE0) as u64) << 16 | (data[1] as u64) << 8 | data[2] as u64) + UPPER_BOUND_2;
        return Ok(x);
    }
    if x < 0xF0 {
        reader.read_exact(&mut data[1..4])?;
        let x = (((x & !0xF0) as u64) << 24
            | (data[1] as u64) << 16
            | (data[2] as u64) << 8
            | data[3] as u64)
            + UPPER_BOUND_3;
        return Ok(x);
    }
    if x < 0xF8 {
        reader.read_exact(&mut data[1..5])?;
        let x = (((x & !0xF8) as u64) << 32
            | (data[1] as u64) << 24
            | (data[2] as u64) << 16
            | (data[3] as u64) << 8
            | data[4] as u64)
            + UPPER_BOUND_4;
        return Ok(x);
    }
    if x < 0xFC {
        reader.read_exact(&mut data[1..6])?;
        let x = (((x & !0xFC) as u64) << 40
            | (data[1] as u64) << 32
            | (data[2] as u64) << 24
            | (data[3] as u64) << 16
            | (data[4] as u64) << 8
            | data[5] as u64)
            + UPPER_BOUND_5;
        return Ok(x);
    }
    if x < 0xFE {
        reader.read_exact(&mut data[1..7])?;
        let x = (((x & !0xFE) as u64) << 48
            | (data[1] as u64) << 40
            | (data[2] as u64) << 32
            | (data[3] as u64) << 24
            | (data[4] as u64) << 16
            | (data[5] as u64) << 8
            | data[6] as u64)
            + UPPER_BOUND_6;
        return Ok(x);
    }
    if x < 0xFF {
        reader.read_exact(&mut data[1..8])?;
        let x = ((data[1] as u64) << 48
            | (data[2] as u64) << 40
            | (data[3] as u64) << 32
            | (data[4] as u64) << 24
            | (data[5] as u64) << 16
            | (data[6] as u64) << 8
            | data[7] as u64)
            + UPPER_BOUND_7;
        return Ok(x);
    }

    reader.read_exact(&mut data[1..9])?;
    let x = u64::from_be_bytes(data[1..].try_into().unwrap());

    Ok(x)
}

#[cfg(test)]
mod test {
    use super::*;

    macro_rules! impl_tests {
        ($test_name:ident, $E:ty) => {
            #[test]
            fn $test_name() {
                const MAX: usize = 1 << 20;
                const MIN: usize = 0;
                let mut buffer = std::io::Cursor::new(Vec::with_capacity(128));
                let mut lens = Vec::new();

                for i in MIN..MAX {
                    lens.push(vbyte_encode::<$E, _>(i as _, &mut buffer).unwrap());
                }
                buffer.set_position(0);
                for (i, l) in (MIN..MAX).zip(lens.iter()) {
                    let j = vbyte_decode::<$E, _>(&mut buffer).unwrap();
                    assert_eq!(*l, len_vbyte_bytes(i as _));
                    assert_eq!(i as u64, j);
                }

                let values = [
                    0,
                    UPPER_BOUND_1 - 1,
                    UPPER_BOUND_1 + 1,
                    UPPER_BOUND_2 - 1,
                    UPPER_BOUND_2 + 1,
                    UPPER_BOUND_3 - 1,
                    UPPER_BOUND_3 + 1,
                    UPPER_BOUND_4 - 1,
                    UPPER_BOUND_4 + 1,
                    UPPER_BOUND_5 - 1,
                    UPPER_BOUND_5 + 1,
                    UPPER_BOUND_6 - 1,
                    UPPER_BOUND_6 + 1,
                    UPPER_BOUND_7 - 1,
                    UPPER_BOUND_7 + 1,
                    UPPER_BOUND_8 - 1,
                    UPPER_BOUND_8 + 1,
                    u64::MAX,
                ];

                let tell: u64 = buffer.position();
                for &i in values.iter() {
                    vbyte_encode::<$E, _>(i, &mut buffer).unwrap();
                }
                buffer.set_position(tell);
                for &i in values.iter() {
                    assert_eq!(i, vbyte_decode::<$E, _>(&mut buffer).unwrap());
                }
            }
        };
    }

    impl_tests!(test_vbytes_be, BE);
    impl_tests!(test_vbytes_le, LE);
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/zeta.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

//! Boldi–Vigna ζ codes.
//!
//! The ζ code with parameter `k` of a natural number `n` is the concatenation of
//! of the unary code of `h = ⌊⌊log₂(n + 1)⌋ / k⌋` and
//! minimal binary code of `n + 1 - 2^(hk)` with `2^((h + 1)k) – 2^(hk)` as upper bound.
//!
//! Note that this module provides a generic implementation of ζ codes, and
//! a specialized implementation for ζ₃ that may use tables.
//!
//! ## Reference
//! Boldi Paolo and Sebastiano Vigna,
//! “The Webgraph framework II: codes for the World-Wide Web,”
//! Data Compression Conference, 2004. Proceedings. DCC 2004
//! (2004): 528-; <https://doi.org/10.1109/DCC.2004.1281504>.

use super::{len_minimal_binary, zeta_tables, MinimalBinaryRead, MinimalBinaryWrite};
use crate::traits::*;

/// Returns the length of the ζ code with parameter `k` for `n`.
#[must_use]
#[inline]
#[allow(clippy::collapsible_if)]
pub fn len_zeta_param<const USE_TABLE: bool>(mut n: u64, k: u64) -> usize {
    if USE_TABLE {
        if k == zeta_tables::K {
            if let Some(idx) = zeta_tables::LEN.get(n as usize) {
                return *idx as usize;
            }
        }
    }
    n += 1;
    let h = n.ilog2() as u64 / k;
    let u = 1 << ((h + 1) * k);
    let l = 1 << (h * k);
    h as usize + 1 + len_minimal_binary(n - l, u - l)
}

/// Returns the length of the ζ code with parameter `k` for `n` using
/// a default value for `USE_TABLE`.
#[inline(always)]
pub fn len_zeta(n: u64, k: u64) -> usize {
    len_zeta_param::<true>(n, k)
}

/// Trait for reading ζ codes.
///
/// This is the trait you should usually pull in scope to read ζ codes.
pub trait ZetaRead<E: Endianness>: BitRead<E> {
    fn read_zeta(&mut self, k: u64) -> Result<u64, Self::Error>;
    fn read_zeta3(&mut self) -> Result<u64, Self::Error>;
}

/// Parametric trait for reading ζ codes.
///
/// This trait is is more general than [`ZetaRead`], as it makes it possible
/// to specify how to use tables using const parameters.
///
/// We provide an implementation of this trait for [`BitRead`]. An implementation
/// of [`ZetaRead`] using default values is usually provided exploiting the
/// [`crate::codes::params::ReadParams`] mechanism.
pub trait ZetaReadParam<E: Endianness>: MinimalBinaryRead<E> {
    fn read_zeta_param(&mut self, k: u64) -> Result<u64, Self::Error>;
    fn read_zeta3_param<const USE_TABLE: bool>(&mut self) -> Result<u64, Self::Error>;
}

impl<B: BitRead<BE>> ZetaReadParam<BE> for B {
    #[inline(always)]
    fn read_zeta_param(&mut self, k: u64) -> Result<u64, B::Error> {
        default_read_zeta(self, k)
    }

    #[inline(always)]
    fn read_zeta3_param<const USE_TABLE: bool>(&mut self) -> Result<u64, B::Error> {
        if USE_TABLE {
            if let Some((res, _)) = zeta_tables::read_table_be(self) {
                return Ok(res);
            }
        }
        default_read_zeta(self, 3)
    }
}

impl<B: BitRead<LE>> ZetaReadParam<LE> for B {
    #[inline(always)]
    fn read_zeta_param(&mut self, k: u64) -> Result<u64, B::Error> {
        default_read_zeta(self, k)
    }

    #[inline(always)]
    fn read_zeta3_param<const USE_TABLE: bool>(&mut self) -> Result<u64, B::Error> {
        if USE_TABLE {
            if let Some((res, _)) = zeta_tables::read_table_le(self) {
                return Ok(res);
            }
        }
        default_read_zeta(self, 3)
    }
}

/// Default, internal non-table based implementation that works
/// for any endianness.
#[inline(always)]
fn default_read_zeta<BO: Endianness, B: BitRead<BO>>(
    backend: &mut B,
    k: u64,
) -> Result<u64, B::Error> {
    let h = backend.read_unary()?;
    let u = 1 << ((h + 1) * k);
    let l = 1 << (h * k);
    let res = backend.read_minimal_binary(u - l)?;
    Ok(l + res - 1)
}

/// Trait for writing ζ codes.
///
/// This is the trait you should usually pull in scope to write ζ codes.
pub trait ZetaWrite<E: Endianness>: BitWrite<E> {
    fn write_zeta(&mut self, n: u64, k: u64) -> Result<usize, Self::Error>;
    fn write_zeta3(&mut self, n: u64) -> Result<usize, Self::Error>;
}

/// Parametric trait for writing ζ codes.
///
/// This trait is is more general than [`ZetaWrite`], as it makes it possible
/// to specify how to use tables using const parameters.
///
/// We provide an implementation of this trait for [`BitWrite`]. An implementation
/// of [`ZetaWrite`] using default values is usually provided exploiting the
/// [`crate::codes::params::WriteParams`] mechanism.
pub trait ZetaWriteParam<E: Endianness>: MinimalBinaryWrite<E> {
    fn write_zeta_param<const USE_TABLE: bool>(
        &mut self,
        n: u64,
        k: u64,
    ) -> Result<usize, Self::Error>;
    fn write_zeta3_param<const USE_TABLE: bool>(&mut self, n: u64) -> Result<usize, Self::Error>;
}

impl<B: BitWrite<BE>> ZetaWriteParam<BE> for B {
    #[inline]
    fn write_zeta_param<const USE_TABLE: bool>(
        &mut self,
        n: u64,
        k: u64,
    ) -> Result<usize, Self::Error> {
        default_write_zeta(self, n, k)
    }

    #[inline]
    #[allow(clippy::collapsible_if)]
    fn write_zeta3_param<const USE_TABLE: bool>(&mut self, n: u64) -> Result<usize, Self::Error> {
        if USE_TABLE {
            if let Some(len) = zeta_tables::write_table_be(self, n)? {
                return Ok(len);
            }
        }
        default_write_zeta(self, n, 3)
    }
}

impl<B: BitWrite<LE>> ZetaWriteParam<LE> for B {
    #[inline]
    fn write_zeta_param<const USE_TABLE: bool>(
        &mut self,
        n: u64,
        k: u64,
    ) -> Result<usize, Self::Error> {
        default_write_zeta(self, n, k)
    }

    #[inline]
    #[allow(clippy::collapsible_if)]
    fn write_zeta3_param<const USE_TABLE: bool>(&mut self, n: u64) -> Result<usize, Self::Error> {
        if USE_TABLE {
            if let Some(len) = zeta_tables::write_table_le(self, n)? {
                return Ok(len);
            }
        }
        default_write_zeta(self, n, 3)
    }
}

/// Default, internal non-table based implementation that works
/// for any endianness.
#[inline(always)]
fn default_write_zeta<E: Endianness, B: BitWrite<E>>(
    backend: &mut B,
    mut n: u64,
    k: u64,
) -> Result<usize, B::Error> {
    n += 1;
    let h = n.ilog2() as u64 / k;
    let u = 1 << ((h + 1) * k);
    let l = 1 << (h * k);

    debug_assert!(l <= n, "{} <= {}", l, n);
    debug_assert!(n < u, "{} < {}", n, u);

    // Write the code
    Ok(backend.write_unary(h)? + backend.write_minimal_binary(n - l, u - l)?)
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/zeta_tables.rs`:

```````rs
#![doc(hidden)]
// THIS FILE HAS BEEN GENERATED BY THE SCRIPT gen_code_tables.py
// ~~~~~~~~~~~~~~~~~~~ DO NOT MODIFY ~~~~~~~~~~~~~~~~~~~~~~
// Methods for reading and writing values using precomputed tables for zeta codes
use crate::traits::{BitRead, BitWrite, BE, LE};
use common_traits::*;
/// How many bits are needed to read the tables in this
pub const READ_BITS: usize = 12;
/// Maximum value writable using the table(s)
pub const WRITE_MAX: u64 = 1023;

#[inline(always)]
/// Read a value using a decoding table.
///
/// If the result is `Some` the decoding was successful, and
/// the decoded value and the length of the code are returned.
pub fn read_table_le<B: BitRead<LE>>(backend: &mut B) -> Option<(u64, usize)> {
    if let Ok(idx) = backend.peek_bits(READ_BITS) {
        let idx: u64 = idx.cast();
        let len = READ_LEN_LE[idx as usize];
        if len != MISSING_VALUE_LEN_LE {
            backend.skip_bits_after_table_lookup(len as usize);
            return Some((READ_LE[idx as usize] as u64, len as usize));
        }
    }
    None
}
#[inline(always)]
/// Compute the length of the code representing a value using a decoding table.
///
/// If the result is `Some` the lookup was successful, and
/// the length of the code is returned.
pub fn len_table_le<B: BitRead<LE>>(backend: &mut B) -> Option<usize> {
    if let Ok(idx) = backend.peek_bits(READ_BITS) {
        let idx: u64 = idx.cast();
        let len = READ_LEN_LE[idx as usize];
        if len != MISSING_VALUE_LEN_LE {
            backend.skip_bits_after_table_lookup(len as usize);
            return Some(len as usize);
        }
    }
    None
}

#[inline(always)]
/// Write a value using an encoding table.
///
/// If the result is `Some` the encoding was successful, and
/// length of the code is returned.
pub fn write_table_le<B: BitWrite<LE>>(
    backend: &mut B,
    value: u64,
) -> Result<Option<usize>, B::Error> {
    Ok(if let Some(bits) = WRITE_LE.get(value as usize) {
        let len = WRITE_LEN_LE[value as usize] as usize;
        backend.write_bits(*bits as u64, len)?;
        Some(len)
    } else {
        None
    })
}

#[inline(always)]
/// Read a value using a decoding table.
///
/// If the result is `Some` the decoding was successful, and
/// the decoded value and the length of the code are returned.
pub fn read_table_be<B: BitRead<BE>>(backend: &mut B) -> Option<(u64, usize)> {
    if let Ok(idx) = backend.peek_bits(READ_BITS) {
        let idx: u64 = idx.cast();
        let len = READ_LEN_BE[idx as usize];
        if len != MISSING_VALUE_LEN_BE {
            backend.skip_bits_after_table_lookup(len as usize);
            return Some((READ_BE[idx as usize] as u64, len as usize));
        }
    }
    None
}
#[inline(always)]
/// Compute the length of the code representing a value using a decoding table.
///
/// If the result is `Some` the lookup was successful, and
/// the length of the code is returned.
pub fn len_table_be<B: BitRead<BE>>(backend: &mut B) -> Option<usize> {
    if let Ok(idx) = backend.peek_bits(READ_BITS) {
        let idx: u64 = idx.cast();
        let len = READ_LEN_BE[idx as usize];
        if len != MISSING_VALUE_LEN_BE {
            backend.skip_bits_after_table_lookup(len as usize);
            return Some(len as usize);
        }
    }
    None
}

#[inline(always)]
/// Write a value using an encoding table.
///
/// If the result is `Some` the encoding was successful, and
/// length of the code is returned.
pub fn write_table_be<B: BitWrite<BE>>(
    backend: &mut B,
    value: u64,
) -> Result<Option<usize>, B::Error> {
    Ok(if let Some(bits) = WRITE_BE.get(value as usize) {
        let len = WRITE_LEN_BE[value as usize] as usize;
        backend.write_bits(*bits as u64, len)?;
        Some(len)
    } else {
        None
    })
}
/// The len we assign to a code that cannot be decoded through the table
pub const MISSING_VALUE_LEN_BE: u8 = 13;
/// Precomputed table for writing zeta codes
pub const READ_BE: &[u16] = &[
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    63, 63, 64, 64, 65, 65, 66, 66, 67, 67, 68, 68, 69, 69, 70, 70, 71, 71, 72, 72, 73, 73, 74, 74,
    75, 75, 76, 76, 77, 77, 78, 78, 79, 79, 80, 80, 81, 81, 82, 82, 83, 83, 84, 84, 85, 85, 86, 86,
    87, 87, 88, 88, 89, 89, 90, 90, 91, 91, 92, 92, 93, 93, 94, 94, 95, 95, 96, 96, 97, 97, 98, 98,
    99, 99, 100, 100, 101, 101, 102, 102, 103, 103, 104, 104, 105, 105, 106, 106, 107, 107, 108,
    108, 109, 109, 110, 110, 111, 111, 112, 112, 113, 113, 114, 114, 115, 115, 116, 116, 117, 117,
    118, 118, 119, 119, 120, 120, 121, 121, 122, 122, 123, 123, 124, 124, 125, 125, 126, 126, 127,
    128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146,
    147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165,
    166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184,
    185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203,
    204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,
    223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241,
    242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260,
    261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279,
    280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298,
    299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317,
    318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336,
    337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355,
    356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374,
    375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393,
    394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412,
    413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431,
    432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450,
    451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469,
    470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488,
    489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507,
    508, 509, 510, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
    16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18,
    18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
    19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21,
    21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
    25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27,
    27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
    28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30,
    30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
    31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33,
    33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
    34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36,
    36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
    37, 37, 37, 37, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 39, 39, 39, 39,
    39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
    40, 40, 40, 40, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 42, 42, 42, 42,
    42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
    43, 43, 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 45, 45, 45, 45,
    45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,
    46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 48, 48, 48, 48,
    48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,
    49, 49, 49, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 51, 51, 51,
    51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
    52, 52, 52, 52, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 54, 54, 54, 54,
    54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55,
    55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57,
    57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
    58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60,
    60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
    61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
];
/// Precomputed lengths table for reading zeta codes
pub const READ_LEN_BE: &[u8] = &[
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
];
/// The len we assign to a code that cannot be decoded through the table
pub const MISSING_VALUE_LEN_LE: u8 = 13;
/// Precomputed table for writing zeta codes
pub const READ_LE: &[u16] = &[
    0, 0, 7, 1, 63, 3, 8, 5, 0, 0, 9, 2, 64, 4, 10, 6, 0, 0, 11, 1, 65, 3, 12, 5, 0, 0, 13, 2, 66,
    4, 14, 6, 0, 0, 15, 1, 67, 3, 17, 5, 0, 0, 19, 2, 68, 4, 21, 6, 0, 0, 23, 1, 69, 3, 25, 5, 0,
    0, 27, 2, 70, 4, 29, 6, 0, 0, 31, 1, 71, 3, 33, 5, 0, 0, 35, 2, 72, 4, 37, 6, 0, 0, 39, 1, 73,
    3, 41, 5, 0, 0, 43, 2, 74, 4, 45, 6, 0, 0, 47, 1, 75, 3, 49, 5, 0, 0, 51, 2, 76, 4, 53, 6, 0,
    0, 55, 1, 77, 3, 57, 5, 0, 0, 59, 2, 78, 4, 61, 6, 0, 0, 7, 1, 79, 3, 8, 5, 0, 0, 9, 2, 80, 4,
    10, 6, 0, 0, 11, 1, 81, 3, 12, 5, 0, 0, 13, 2, 82, 4, 14, 6, 0, 0, 16, 1, 83, 3, 18, 5, 0, 0,
    20, 2, 84, 4, 22, 6, 0, 0, 24, 1, 85, 3, 26, 5, 0, 0, 28, 2, 86, 4, 30, 6, 0, 0, 32, 1, 87, 3,
    34, 5, 0, 0, 36, 2, 88, 4, 38, 6, 0, 0, 40, 1, 89, 3, 42, 5, 0, 0, 44, 2, 90, 4, 46, 6, 0, 0,
    48, 1, 91, 3, 50, 5, 0, 0, 52, 2, 92, 4, 54, 6, 0, 0, 56, 1, 93, 3, 58, 5, 0, 0, 60, 2, 94, 4,
    62, 6, 0, 0, 7, 1, 95, 3, 8, 5, 0, 0, 9, 2, 96, 4, 10, 6, 0, 0, 11, 1, 97, 3, 12, 5, 0, 0, 13,
    2, 98, 4, 14, 6, 0, 0, 15, 1, 99, 3, 17, 5, 0, 0, 19, 2, 100, 4, 21, 6, 0, 0, 23, 1, 101, 3,
    25, 5, 0, 0, 27, 2, 102, 4, 29, 6, 0, 0, 31, 1, 103, 3, 33, 5, 0, 0, 35, 2, 104, 4, 37, 6, 0,
    0, 39, 1, 105, 3, 41, 5, 0, 0, 43, 2, 106, 4, 45, 6, 0, 0, 47, 1, 107, 3, 49, 5, 0, 0, 51, 2,
    108, 4, 53, 6, 0, 0, 55, 1, 109, 3, 57, 5, 0, 0, 59, 2, 110, 4, 61, 6, 0, 0, 7, 1, 111, 3, 8,
    5, 0, 0, 9, 2, 112, 4, 10, 6, 0, 0, 11, 1, 113, 3, 12, 5, 0, 0, 13, 2, 114, 4, 14, 6, 0, 0, 16,
    1, 115, 3, 18, 5, 0, 0, 20, 2, 116, 4, 22, 6, 0, 0, 24, 1, 117, 3, 26, 5, 0, 0, 28, 2, 118, 4,
    30, 6, 0, 0, 32, 1, 119, 3, 34, 5, 0, 0, 36, 2, 120, 4, 38, 6, 0, 0, 40, 1, 121, 3, 42, 5, 0,
    0, 44, 2, 122, 4, 46, 6, 0, 0, 48, 1, 123, 3, 50, 5, 0, 0, 52, 2, 124, 4, 54, 6, 0, 0, 56, 1,
    125, 3, 58, 5, 0, 0, 60, 2, 126, 4, 62, 6, 0, 0, 7, 1, 127, 3, 8, 5, 0, 0, 9, 2, 129, 4, 10, 6,
    0, 0, 11, 1, 131, 3, 12, 5, 0, 0, 13, 2, 133, 4, 14, 6, 0, 0, 15, 1, 135, 3, 17, 5, 0, 0, 19,
    2, 137, 4, 21, 6, 0, 0, 23, 1, 139, 3, 25, 5, 0, 0, 27, 2, 141, 4, 29, 6, 0, 0, 31, 1, 143, 3,
    33, 5, 0, 0, 35, 2, 145, 4, 37, 6, 0, 0, 39, 1, 147, 3, 41, 5, 0, 0, 43, 2, 149, 4, 45, 6, 0,
    0, 47, 1, 151, 3, 49, 5, 0, 0, 51, 2, 153, 4, 53, 6, 0, 0, 55, 1, 155, 3, 57, 5, 0, 0, 59, 2,
    157, 4, 61, 6, 0, 0, 7, 1, 159, 3, 8, 5, 0, 0, 9, 2, 161, 4, 10, 6, 0, 0, 11, 1, 163, 3, 12, 5,
    0, 0, 13, 2, 165, 4, 14, 6, 0, 0, 16, 1, 167, 3, 18, 5, 0, 0, 20, 2, 169, 4, 22, 6, 0, 0, 24,
    1, 171, 3, 26, 5, 0, 0, 28, 2, 173, 4, 30, 6, 0, 0, 32, 1, 175, 3, 34, 5, 0, 0, 36, 2, 177, 4,
    38, 6, 0, 0, 40, 1, 179, 3, 42, 5, 0, 0, 44, 2, 181, 4, 46, 6, 0, 0, 48, 1, 183, 3, 50, 5, 0,
    0, 52, 2, 185, 4, 54, 6, 0, 0, 56, 1, 187, 3, 58, 5, 0, 0, 60, 2, 189, 4, 62, 6, 0, 0, 7, 1,
    191, 3, 8, 5, 0, 0, 9, 2, 193, 4, 10, 6, 0, 0, 11, 1, 195, 3, 12, 5, 0, 0, 13, 2, 197, 4, 14,
    6, 0, 0, 15, 1, 199, 3, 17, 5, 0, 0, 19, 2, 201, 4, 21, 6, 0, 0, 23, 1, 203, 3, 25, 5, 0, 0,
    27, 2, 205, 4, 29, 6, 0, 0, 31, 1, 207, 3, 33, 5, 0, 0, 35, 2, 209, 4, 37, 6, 0, 0, 39, 1, 211,
    3, 41, 5, 0, 0, 43, 2, 213, 4, 45, 6, 0, 0, 47, 1, 215, 3, 49, 5, 0, 0, 51, 2, 217, 4, 53, 6,
    0, 0, 55, 1, 219, 3, 57, 5, 0, 0, 59, 2, 221, 4, 61, 6, 0, 0, 7, 1, 223, 3, 8, 5, 0, 0, 9, 2,
    225, 4, 10, 6, 0, 0, 11, 1, 227, 3, 12, 5, 0, 0, 13, 2, 229, 4, 14, 6, 0, 0, 16, 1, 231, 3, 18,
    5, 0, 0, 20, 2, 233, 4, 22, 6, 0, 0, 24, 1, 235, 3, 26, 5, 0, 0, 28, 2, 237, 4, 30, 6, 0, 0,
    32, 1, 239, 3, 34, 5, 0, 0, 36, 2, 241, 4, 38, 6, 0, 0, 40, 1, 243, 3, 42, 5, 0, 0, 44, 2, 245,
    4, 46, 6, 0, 0, 48, 1, 247, 3, 50, 5, 0, 0, 52, 2, 249, 4, 54, 6, 0, 0, 56, 1, 251, 3, 58, 5,
    0, 0, 60, 2, 253, 4, 62, 6, 0, 0, 7, 1, 255, 3, 8, 5, 0, 0, 9, 2, 257, 4, 10, 6, 0, 0, 11, 1,
    259, 3, 12, 5, 0, 0, 13, 2, 261, 4, 14, 6, 0, 0, 15, 1, 263, 3, 17, 5, 0, 0, 19, 2, 265, 4, 21,
    6, 0, 0, 23, 1, 267, 3, 25, 5, 0, 0, 27, 2, 269, 4, 29, 6, 0, 0, 31, 1, 271, 3, 33, 5, 0, 0,
    35, 2, 273, 4, 37, 6, 0, 0, 39, 1, 275, 3, 41, 5, 0, 0, 43, 2, 277, 4, 45, 6, 0, 0, 47, 1, 279,
    3, 49, 5, 0, 0, 51, 2, 281, 4, 53, 6, 0, 0, 55, 1, 283, 3, 57, 5, 0, 0, 59, 2, 285, 4, 61, 6,
    0, 0, 7, 1, 287, 3, 8, 5, 0, 0, 9, 2, 289, 4, 10, 6, 0, 0, 11, 1, 291, 3, 12, 5, 0, 0, 13, 2,
    293, 4, 14, 6, 0, 0, 16, 1, 295, 3, 18, 5, 0, 0, 20, 2, 297, 4, 22, 6, 0, 0, 24, 1, 299, 3, 26,
    5, 0, 0, 28, 2, 301, 4, 30, 6, 0, 0, 32, 1, 303, 3, 34, 5, 0, 0, 36, 2, 305, 4, 38, 6, 0, 0,
    40, 1, 307, 3, 42, 5, 0, 0, 44, 2, 309, 4, 46, 6, 0, 0, 48, 1, 311, 3, 50, 5, 0, 0, 52, 2, 313,
    4, 54, 6, 0, 0, 56, 1, 315, 3, 58, 5, 0, 0, 60, 2, 317, 4, 62, 6, 0, 0, 7, 1, 319, 3, 8, 5, 0,
    0, 9, 2, 321, 4, 10, 6, 0, 0, 11, 1, 323, 3, 12, 5, 0, 0, 13, 2, 325, 4, 14, 6, 0, 0, 15, 1,
    327, 3, 17, 5, 0, 0, 19, 2, 329, 4, 21, 6, 0, 0, 23, 1, 331, 3, 25, 5, 0, 0, 27, 2, 333, 4, 29,
    6, 0, 0, 31, 1, 335, 3, 33, 5, 0, 0, 35, 2, 337, 4, 37, 6, 0, 0, 39, 1, 339, 3, 41, 5, 0, 0,
    43, 2, 341, 4, 45, 6, 0, 0, 47, 1, 343, 3, 49, 5, 0, 0, 51, 2, 345, 4, 53, 6, 0, 0, 55, 1, 347,
    3, 57, 5, 0, 0, 59, 2, 349, 4, 61, 6, 0, 0, 7, 1, 351, 3, 8, 5, 0, 0, 9, 2, 353, 4, 10, 6, 0,
    0, 11, 1, 355, 3, 12, 5, 0, 0, 13, 2, 357, 4, 14, 6, 0, 0, 16, 1, 359, 3, 18, 5, 0, 0, 20, 2,
    361, 4, 22, 6, 0, 0, 24, 1, 363, 3, 26, 5, 0, 0, 28, 2, 365, 4, 30, 6, 0, 0, 32, 1, 367, 3, 34,
    5, 0, 0, 36, 2, 369, 4, 38, 6, 0, 0, 40, 1, 371, 3, 42, 5, 0, 0, 44, 2, 373, 4, 46, 6, 0, 0,
    48, 1, 375, 3, 50, 5, 0, 0, 52, 2, 377, 4, 54, 6, 0, 0, 56, 1, 379, 3, 58, 5, 0, 0, 60, 2, 381,
    4, 62, 6, 0, 0, 7, 1, 383, 3, 8, 5, 0, 0, 9, 2, 385, 4, 10, 6, 0, 0, 11, 1, 387, 3, 12, 5, 0,
    0, 13, 2, 389, 4, 14, 6, 0, 0, 15, 1, 391, 3, 17, 5, 0, 0, 19, 2, 393, 4, 21, 6, 0, 0, 23, 1,
    395, 3, 25, 5, 0, 0, 27, 2, 397, 4, 29, 6, 0, 0, 31, 1, 399, 3, 33, 5, 0, 0, 35, 2, 401, 4, 37,
    6, 0, 0, 39, 1, 403, 3, 41, 5, 0, 0, 43, 2, 405, 4, 45, 6, 0, 0, 47, 1, 407, 3, 49, 5, 0, 0,
    51, 2, 409, 4, 53, 6, 0, 0, 55, 1, 411, 3, 57, 5, 0, 0, 59, 2, 413, 4, 61, 6, 0, 0, 7, 1, 415,
    3, 8, 5, 0, 0, 9, 2, 417, 4, 10, 6, 0, 0, 11, 1, 419, 3, 12, 5, 0, 0, 13, 2, 421, 4, 14, 6, 0,
    0, 16, 1, 423, 3, 18, 5, 0, 0, 20, 2, 425, 4, 22, 6, 0, 0, 24, 1, 427, 3, 26, 5, 0, 0, 28, 2,
    429, 4, 30, 6, 0, 0, 32, 1, 431, 3, 34, 5, 0, 0, 36, 2, 433, 4, 38, 6, 0, 0, 40, 1, 435, 3, 42,
    5, 0, 0, 44, 2, 437, 4, 46, 6, 0, 0, 48, 1, 439, 3, 50, 5, 0, 0, 52, 2, 441, 4, 54, 6, 0, 0,
    56, 1, 443, 3, 58, 5, 0, 0, 60, 2, 445, 4, 62, 6, 0, 0, 7, 1, 447, 3, 8, 5, 0, 0, 9, 2, 449, 4,
    10, 6, 0, 0, 11, 1, 451, 3, 12, 5, 0, 0, 13, 2, 453, 4, 14, 6, 0, 0, 15, 1, 455, 3, 17, 5, 0,
    0, 19, 2, 457, 4, 21, 6, 0, 0, 23, 1, 459, 3, 25, 5, 0, 0, 27, 2, 461, 4, 29, 6, 0, 0, 31, 1,
    463, 3, 33, 5, 0, 0, 35, 2, 465, 4, 37, 6, 0, 0, 39, 1, 467, 3, 41, 5, 0, 0, 43, 2, 469, 4, 45,
    6, 0, 0, 47, 1, 471, 3, 49, 5, 0, 0, 51, 2, 473, 4, 53, 6, 0, 0, 55, 1, 475, 3, 57, 5, 0, 0,
    59, 2, 477, 4, 61, 6, 0, 0, 7, 1, 479, 3, 8, 5, 0, 0, 9, 2, 481, 4, 10, 6, 0, 0, 11, 1, 483, 3,
    12, 5, 0, 0, 13, 2, 485, 4, 14, 6, 0, 0, 16, 1, 487, 3, 18, 5, 0, 0, 20, 2, 489, 4, 22, 6, 0,
    0, 24, 1, 491, 3, 26, 5, 0, 0, 28, 2, 493, 4, 30, 6, 0, 0, 32, 1, 495, 3, 34, 5, 0, 0, 36, 2,
    497, 4, 38, 6, 0, 0, 40, 1, 499, 3, 42, 5, 0, 0, 44, 2, 501, 4, 46, 6, 0, 0, 48, 1, 503, 3, 50,
    5, 0, 0, 52, 2, 505, 4, 54, 6, 0, 0, 56, 1, 507, 3, 58, 5, 0, 0, 60, 2, 509, 4, 62, 6, 0, 0, 7,
    1, 63, 3, 8, 5, 0, 0, 9, 2, 64, 4, 10, 6, 0, 0, 11, 1, 65, 3, 12, 5, 0, 0, 13, 2, 66, 4, 14, 6,
    0, 0, 15, 1, 67, 3, 17, 5, 0, 0, 19, 2, 68, 4, 21, 6, 0, 0, 23, 1, 69, 3, 25, 5, 0, 0, 27, 2,
    70, 4, 29, 6, 0, 0, 31, 1, 71, 3, 33, 5, 0, 0, 35, 2, 72, 4, 37, 6, 0, 0, 39, 1, 73, 3, 41, 5,
    0, 0, 43, 2, 74, 4, 45, 6, 0, 0, 47, 1, 75, 3, 49, 5, 0, 0, 51, 2, 76, 4, 53, 6, 0, 0, 55, 1,
    77, 3, 57, 5, 0, 0, 59, 2, 78, 4, 61, 6, 0, 0, 7, 1, 79, 3, 8, 5, 0, 0, 9, 2, 80, 4, 10, 6, 0,
    0, 11, 1, 81, 3, 12, 5, 0, 0, 13, 2, 82, 4, 14, 6, 0, 0, 16, 1, 83, 3, 18, 5, 0, 0, 20, 2, 84,
    4, 22, 6, 0, 0, 24, 1, 85, 3, 26, 5, 0, 0, 28, 2, 86, 4, 30, 6, 0, 0, 32, 1, 87, 3, 34, 5, 0,
    0, 36, 2, 88, 4, 38, 6, 0, 0, 40, 1, 89, 3, 42, 5, 0, 0, 44, 2, 90, 4, 46, 6, 0, 0, 48, 1, 91,
    3, 50, 5, 0, 0, 52, 2, 92, 4, 54, 6, 0, 0, 56, 1, 93, 3, 58, 5, 0, 0, 60, 2, 94, 4, 62, 6, 0,
    0, 7, 1, 95, 3, 8, 5, 0, 0, 9, 2, 96, 4, 10, 6, 0, 0, 11, 1, 97, 3, 12, 5, 0, 0, 13, 2, 98, 4,
    14, 6, 0, 0, 15, 1, 99, 3, 17, 5, 0, 0, 19, 2, 100, 4, 21, 6, 0, 0, 23, 1, 101, 3, 25, 5, 0, 0,
    27, 2, 102, 4, 29, 6, 0, 0, 31, 1, 103, 3, 33, 5, 0, 0, 35, 2, 104, 4, 37, 6, 0, 0, 39, 1, 105,
    3, 41, 5, 0, 0, 43, 2, 106, 4, 45, 6, 0, 0, 47, 1, 107, 3, 49, 5, 0, 0, 51, 2, 108, 4, 53, 6,
    0, 0, 55, 1, 109, 3, 57, 5, 0, 0, 59, 2, 110, 4, 61, 6, 0, 0, 7, 1, 111, 3, 8, 5, 0, 0, 9, 2,
    112, 4, 10, 6, 0, 0, 11, 1, 113, 3, 12, 5, 0, 0, 13, 2, 114, 4, 14, 6, 0, 0, 16, 1, 115, 3, 18,
    5, 0, 0, 20, 2, 116, 4, 22, 6, 0, 0, 24, 1, 117, 3, 26, 5, 0, 0, 28, 2, 118, 4, 30, 6, 0, 0,
    32, 1, 119, 3, 34, 5, 0, 0, 36, 2, 120, 4, 38, 6, 0, 0, 40, 1, 121, 3, 42, 5, 0, 0, 44, 2, 122,
    4, 46, 6, 0, 0, 48, 1, 123, 3, 50, 5, 0, 0, 52, 2, 124, 4, 54, 6, 0, 0, 56, 1, 125, 3, 58, 5,
    0, 0, 60, 2, 126, 4, 62, 6, 0, 0, 7, 1, 128, 3, 8, 5, 0, 0, 9, 2, 130, 4, 10, 6, 0, 0, 11, 1,
    132, 3, 12, 5, 0, 0, 13, 2, 134, 4, 14, 6, 0, 0, 15, 1, 136, 3, 17, 5, 0, 0, 19, 2, 138, 4, 21,
    6, 0, 0, 23, 1, 140, 3, 25, 5, 0, 0, 27, 2, 142, 4, 29, 6, 0, 0, 31, 1, 144, 3, 33, 5, 0, 0,
    35, 2, 146, 4, 37, 6, 0, 0, 39, 1, 148, 3, 41, 5, 0, 0, 43, 2, 150, 4, 45, 6, 0, 0, 47, 1, 152,
    3, 49, 5, 0, 0, 51, 2, 154, 4, 53, 6, 0, 0, 55, 1, 156, 3, 57, 5, 0, 0, 59, 2, 158, 4, 61, 6,
    0, 0, 7, 1, 160, 3, 8, 5, 0, 0, 9, 2, 162, 4, 10, 6, 0, 0, 11, 1, 164, 3, 12, 5, 0, 0, 13, 2,
    166, 4, 14, 6, 0, 0, 16, 1, 168, 3, 18, 5, 0, 0, 20, 2, 170, 4, 22, 6, 0, 0, 24, 1, 172, 3, 26,
    5, 0, 0, 28, 2, 174, 4, 30, 6, 0, 0, 32, 1, 176, 3, 34, 5, 0, 0, 36, 2, 178, 4, 38, 6, 0, 0,
    40, 1, 180, 3, 42, 5, 0, 0, 44, 2, 182, 4, 46, 6, 0, 0, 48, 1, 184, 3, 50, 5, 0, 0, 52, 2, 186,
    4, 54, 6, 0, 0, 56, 1, 188, 3, 58, 5, 0, 0, 60, 2, 190, 4, 62, 6, 0, 0, 7, 1, 192, 3, 8, 5, 0,
    0, 9, 2, 194, 4, 10, 6, 0, 0, 11, 1, 196, 3, 12, 5, 0, 0, 13, 2, 198, 4, 14, 6, 0, 0, 15, 1,
    200, 3, 17, 5, 0, 0, 19, 2, 202, 4, 21, 6, 0, 0, 23, 1, 204, 3, 25, 5, 0, 0, 27, 2, 206, 4, 29,
    6, 0, 0, 31, 1, 208, 3, 33, 5, 0, 0, 35, 2, 210, 4, 37, 6, 0, 0, 39, 1, 212, 3, 41, 5, 0, 0,
    43, 2, 214, 4, 45, 6, 0, 0, 47, 1, 216, 3, 49, 5, 0, 0, 51, 2, 218, 4, 53, 6, 0, 0, 55, 1, 220,
    3, 57, 5, 0, 0, 59, 2, 222, 4, 61, 6, 0, 0, 7, 1, 224, 3, 8, 5, 0, 0, 9, 2, 226, 4, 10, 6, 0,
    0, 11, 1, 228, 3, 12, 5, 0, 0, 13, 2, 230, 4, 14, 6, 0, 0, 16, 1, 232, 3, 18, 5, 0, 0, 20, 2,
    234, 4, 22, 6, 0, 0, 24, 1, 236, 3, 26, 5, 0, 0, 28, 2, 238, 4, 30, 6, 0, 0, 32, 1, 240, 3, 34,
    5, 0, 0, 36, 2, 242, 4, 38, 6, 0, 0, 40, 1, 244, 3, 42, 5, 0, 0, 44, 2, 246, 4, 46, 6, 0, 0,
    48, 1, 248, 3, 50, 5, 0, 0, 52, 2, 250, 4, 54, 6, 0, 0, 56, 1, 252, 3, 58, 5, 0, 0, 60, 2, 254,
    4, 62, 6, 0, 0, 7, 1, 256, 3, 8, 5, 0, 0, 9, 2, 258, 4, 10, 6, 0, 0, 11, 1, 260, 3, 12, 5, 0,
    0, 13, 2, 262, 4, 14, 6, 0, 0, 15, 1, 264, 3, 17, 5, 0, 0, 19, 2, 266, 4, 21, 6, 0, 0, 23, 1,
    268, 3, 25, 5, 0, 0, 27, 2, 270, 4, 29, 6, 0, 0, 31, 1, 272, 3, 33, 5, 0, 0, 35, 2, 274, 4, 37,
    6, 0, 0, 39, 1, 276, 3, 41, 5, 0, 0, 43, 2, 278, 4, 45, 6, 0, 0, 47, 1, 280, 3, 49, 5, 0, 0,
    51, 2, 282, 4, 53, 6, 0, 0, 55, 1, 284, 3, 57, 5, 0, 0, 59, 2, 286, 4, 61, 6, 0, 0, 7, 1, 288,
    3, 8, 5, 0, 0, 9, 2, 290, 4, 10, 6, 0, 0, 11, 1, 292, 3, 12, 5, 0, 0, 13, 2, 294, 4, 14, 6, 0,
    0, 16, 1, 296, 3, 18, 5, 0, 0, 20, 2, 298, 4, 22, 6, 0, 0, 24, 1, 300, 3, 26, 5, 0, 0, 28, 2,
    302, 4, 30, 6, 0, 0, 32, 1, 304, 3, 34, 5, 0, 0, 36, 2, 306, 4, 38, 6, 0, 0, 40, 1, 308, 3, 42,
    5, 0, 0, 44, 2, 310, 4, 46, 6, 0, 0, 48, 1, 312, 3, 50, 5, 0, 0, 52, 2, 314, 4, 54, 6, 0, 0,
    56, 1, 316, 3, 58, 5, 0, 0, 60, 2, 318, 4, 62, 6, 0, 0, 7, 1, 320, 3, 8, 5, 0, 0, 9, 2, 322, 4,
    10, 6, 0, 0, 11, 1, 324, 3, 12, 5, 0, 0, 13, 2, 326, 4, 14, 6, 0, 0, 15, 1, 328, 3, 17, 5, 0,
    0, 19, 2, 330, 4, 21, 6, 0, 0, 23, 1, 332, 3, 25, 5, 0, 0, 27, 2, 334, 4, 29, 6, 0, 0, 31, 1,
    336, 3, 33, 5, 0, 0, 35, 2, 338, 4, 37, 6, 0, 0, 39, 1, 340, 3, 41, 5, 0, 0, 43, 2, 342, 4, 45,
    6, 0, 0, 47, 1, 344, 3, 49, 5, 0, 0, 51, 2, 346, 4, 53, 6, 0, 0, 55, 1, 348, 3, 57, 5, 0, 0,
    59, 2, 350, 4, 61, 6, 0, 0, 7, 1, 352, 3, 8, 5, 0, 0, 9, 2, 354, 4, 10, 6, 0, 0, 11, 1, 356, 3,
    12, 5, 0, 0, 13, 2, 358, 4, 14, 6, 0, 0, 16, 1, 360, 3, 18, 5, 0, 0, 20, 2, 362, 4, 22, 6, 0,
    0, 24, 1, 364, 3, 26, 5, 0, 0, 28, 2, 366, 4, 30, 6, 0, 0, 32, 1, 368, 3, 34, 5, 0, 0, 36, 2,
    370, 4, 38, 6, 0, 0, 40, 1, 372, 3, 42, 5, 0, 0, 44, 2, 374, 4, 46, 6, 0, 0, 48, 1, 376, 3, 50,
    5, 0, 0, 52, 2, 378, 4, 54, 6, 0, 0, 56, 1, 380, 3, 58, 5, 0, 0, 60, 2, 382, 4, 62, 6, 0, 0, 7,
    1, 384, 3, 8, 5, 0, 0, 9, 2, 386, 4, 10, 6, 0, 0, 11, 1, 388, 3, 12, 5, 0, 0, 13, 2, 390, 4,
    14, 6, 0, 0, 15, 1, 392, 3, 17, 5, 0, 0, 19, 2, 394, 4, 21, 6, 0, 0, 23, 1, 396, 3, 25, 5, 0,
    0, 27, 2, 398, 4, 29, 6, 0, 0, 31, 1, 400, 3, 33, 5, 0, 0, 35, 2, 402, 4, 37, 6, 0, 0, 39, 1,
    404, 3, 41, 5, 0, 0, 43, 2, 406, 4, 45, 6, 0, 0, 47, 1, 408, 3, 49, 5, 0, 0, 51, 2, 410, 4, 53,
    6, 0, 0, 55, 1, 412, 3, 57, 5, 0, 0, 59, 2, 414, 4, 61, 6, 0, 0, 7, 1, 416, 3, 8, 5, 0, 0, 9,
    2, 418, 4, 10, 6, 0, 0, 11, 1, 420, 3, 12, 5, 0, 0, 13, 2, 422, 4, 14, 6, 0, 0, 16, 1, 424, 3,
    18, 5, 0, 0, 20, 2, 426, 4, 22, 6, 0, 0, 24, 1, 428, 3, 26, 5, 0, 0, 28, 2, 430, 4, 30, 6, 0,
    0, 32, 1, 432, 3, 34, 5, 0, 0, 36, 2, 434, 4, 38, 6, 0, 0, 40, 1, 436, 3, 42, 5, 0, 0, 44, 2,
    438, 4, 46, 6, 0, 0, 48, 1, 440, 3, 50, 5, 0, 0, 52, 2, 442, 4, 54, 6, 0, 0, 56, 1, 444, 3, 58,
    5, 0, 0, 60, 2, 446, 4, 62, 6, 0, 0, 7, 1, 448, 3, 8, 5, 0, 0, 9, 2, 450, 4, 10, 6, 0, 0, 11,
    1, 452, 3, 12, 5, 0, 0, 13, 2, 454, 4, 14, 6, 0, 0, 15, 1, 456, 3, 17, 5, 0, 0, 19, 2, 458, 4,
    21, 6, 0, 0, 23, 1, 460, 3, 25, 5, 0, 0, 27, 2, 462, 4, 29, 6, 0, 0, 31, 1, 464, 3, 33, 5, 0,
    0, 35, 2, 466, 4, 37, 6, 0, 0, 39, 1, 468, 3, 41, 5, 0, 0, 43, 2, 470, 4, 45, 6, 0, 0, 47, 1,
    472, 3, 49, 5, 0, 0, 51, 2, 474, 4, 53, 6, 0, 0, 55, 1, 476, 3, 57, 5, 0, 0, 59, 2, 478, 4, 61,
    6, 0, 0, 7, 1, 480, 3, 8, 5, 0, 0, 9, 2, 482, 4, 10, 6, 0, 0, 11, 1, 484, 3, 12, 5, 0, 0, 13,
    2, 486, 4, 14, 6, 0, 0, 16, 1, 488, 3, 18, 5, 0, 0, 20, 2, 490, 4, 22, 6, 0, 0, 24, 1, 492, 3,
    26, 5, 0, 0, 28, 2, 494, 4, 30, 6, 0, 0, 32, 1, 496, 3, 34, 5, 0, 0, 36, 2, 498, 4, 38, 6, 0,
    0, 40, 1, 500, 3, 42, 5, 0, 0, 44, 2, 502, 4, 46, 6, 0, 0, 48, 1, 504, 3, 50, 5, 0, 0, 52, 2,
    506, 4, 54, 6, 0, 0, 56, 1, 508, 3, 58, 5, 0, 0, 60, 2, 510, 4, 62, 6,
];
/// Precomputed lengths table for reading zeta codes
pub const READ_LEN_LE: &[u8] = &[
    13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11,
    4, 7, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3,
    8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8,
    4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4,
    11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13,
    3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4,
    8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8,
    4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4,
    13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 7, 4, 11,
    4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3,
    8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8,
    4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4,
    11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13,
    3, 8, 4, 11, 4, 8, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4,
    7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8,
    4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4,
    13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11,
    4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3,
    7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4, 8,
    4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4,
    12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13,
    3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4,
    8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7,
    4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4,
    13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12,
    4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3,
    8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7,
    4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4,
    12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13,
    3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4,
    8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 7,
    4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4,
    13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12,
    4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3,
    8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8,
    4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4,
    12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13,
    3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4,
    8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8,
    4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4,
    13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12,
    4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3,
    8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8,
    4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4,
    12, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13,
    3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4,
    8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8,
    4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4,
    13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12,
    4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3,
    8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8,
    4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4,
    12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13,
    3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4,
    7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8,
    4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4,
    13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12,
    4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3,
    7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8,
    4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4,
    12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13,
    3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 7, 4, 12, 4,
    7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8,
    4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4,
    13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12,
    4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3,
    8, 4, 12, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7,
    4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4,
    12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13,
    3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4,
    8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7,
    4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 8, 4, 11, 4, 8, 4,
    13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11,
    4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3,
    8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8,
    4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4,
    11, 4, 7, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13,
    3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4,
    8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8,
    4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4,
    13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11,
    4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3,
    8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8,
    4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 7, 4,
    11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13, 3, 7, 4, 11, 4, 7, 4, 13,
    3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4,
    8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8,
    4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 8, 4, 11, 4, 8, 4,
    13, 3, 8, 4, 11, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12,
    4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3,
    8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8,
    4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4,
    12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13,
    3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4,
    8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8,
    4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4,
    13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12,
    4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3,
    7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8,
    4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4,
    12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13,
    3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4,
    7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8,
    4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4,
    13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12,
    4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3,
    7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7,
    4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4,
    12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13,
    3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4,
    8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7,
    4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4,
    13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12,
    4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3,
    8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7,
    4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4,
    12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13,
    3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4,
    8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8,
    4, 12, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4,
    13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12,
    4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3,
    8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8,
    4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4,
    12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13,
    3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4,
    8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8,
    4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4,
    13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12,
    4, 7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3,
    8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8,
    4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4,
    12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13,
    3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4,
    8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8,
    4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4,
    13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 7, 4, 12,
    4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3, 7, 4, 12, 4, 7, 4, 13, 3,
    8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8,
    4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4,
    12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13, 3, 8, 4, 12, 4, 8, 4, 13,
    3, 8, 4, 12, 4, 8, 4,
];
///Table used to speed up the writing of zeta codes
pub const WRITE_BE: &[u16] = &[
    4, 10, 11, 12, 13, 14, 15, 32, 33, 34, 35, 36, 37, 38, 39, 80, 81, 82, 83, 84, 85, 86, 87, 88,
    89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
    110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 256,
    257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275,
    276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294,
    295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313,
    314, 315, 316, 317, 318, 319, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652,
    653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671,
    672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690,
    691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709,
    710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728,
    729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747,
    748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766,
    767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785,
    786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804,
    805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823,
    824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842,
    843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861,
    862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880,
    881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899,
    900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918,
    919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937,
    938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956,
    957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975,
    976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994,
    995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010,
    1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 2048, 2049, 2050,
    2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066,
    2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082,
    2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098,
    2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114,
    2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130,
    2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146,
    2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162,
    2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178,
    2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194,
    2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210,
    2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226,
    2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242,
    2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258,
    2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274,
    2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290,
    2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306,
    2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322,
    2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338,
    2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354,
    2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370,
    2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386,
    2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402,
    2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418,
    2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434,
    2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450,
    2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466,
    2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482,
    2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498,
    2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514,
    2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530,
    2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546,
    2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 5120,
];
///Table used to speed up the writing of zeta codes
pub const WRITE_LEN_BE: &[u16] = &[
    3, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    16,
];
///Table used to speed up the writing of zeta codes
pub const WRITE_LE: &[u16] = &[
    1, 3, 11, 5, 13, 7, 15, 2, 6, 10, 14, 18, 22, 26, 30, 34, 162, 38, 166, 42, 170, 46, 174, 50,
    178, 54, 182, 58, 186, 62, 190, 66, 194, 70, 198, 74, 202, 78, 206, 82, 210, 86, 214, 90, 218,
    94, 222, 98, 226, 102, 230, 106, 234, 110, 238, 114, 242, 118, 246, 122, 250, 126, 254, 4, 12,
    20, 28, 36, 44, 52, 60, 68, 76, 84, 92, 100, 108, 116, 124, 132, 140, 148, 156, 164, 172, 180,
    188, 196, 204, 212, 220, 228, 236, 244, 252, 260, 268, 276, 284, 292, 300, 308, 316, 324, 332,
    340, 348, 356, 364, 372, 380, 388, 396, 404, 412, 420, 428, 436, 444, 452, 460, 468, 476, 484,
    492, 500, 508, 516, 2564, 524, 2572, 532, 2580, 540, 2588, 548, 2596, 556, 2604, 564, 2612,
    572, 2620, 580, 2628, 588, 2636, 596, 2644, 604, 2652, 612, 2660, 620, 2668, 628, 2676, 636,
    2684, 644, 2692, 652, 2700, 660, 2708, 668, 2716, 676, 2724, 684, 2732, 692, 2740, 700, 2748,
    708, 2756, 716, 2764, 724, 2772, 732, 2780, 740, 2788, 748, 2796, 756, 2804, 764, 2812, 772,
    2820, 780, 2828, 788, 2836, 796, 2844, 804, 2852, 812, 2860, 820, 2868, 828, 2876, 836, 2884,
    844, 2892, 852, 2900, 860, 2908, 868, 2916, 876, 2924, 884, 2932, 892, 2940, 900, 2948, 908,
    2956, 916, 2964, 924, 2972, 932, 2980, 940, 2988, 948, 2996, 956, 3004, 964, 3012, 972, 3020,
    980, 3028, 988, 3036, 996, 3044, 1004, 3052, 1012, 3060, 1020, 3068, 1028, 3076, 1036, 3084,
    1044, 3092, 1052, 3100, 1060, 3108, 1068, 3116, 1076, 3124, 1084, 3132, 1092, 3140, 1100, 3148,
    1108, 3156, 1116, 3164, 1124, 3172, 1132, 3180, 1140, 3188, 1148, 3196, 1156, 3204, 1164, 3212,
    1172, 3220, 1180, 3228, 1188, 3236, 1196, 3244, 1204, 3252, 1212, 3260, 1220, 3268, 1228, 3276,
    1236, 3284, 1244, 3292, 1252, 3300, 1260, 3308, 1268, 3316, 1276, 3324, 1284, 3332, 1292, 3340,
    1300, 3348, 1308, 3356, 1316, 3364, 1324, 3372, 1332, 3380, 1340, 3388, 1348, 3396, 1356, 3404,
    1364, 3412, 1372, 3420, 1380, 3428, 1388, 3436, 1396, 3444, 1404, 3452, 1412, 3460, 1420, 3468,
    1428, 3476, 1436, 3484, 1444, 3492, 1452, 3500, 1460, 3508, 1468, 3516, 1476, 3524, 1484, 3532,
    1492, 3540, 1500, 3548, 1508, 3556, 1516, 3564, 1524, 3572, 1532, 3580, 1540, 3588, 1548, 3596,
    1556, 3604, 1564, 3612, 1572, 3620, 1580, 3628, 1588, 3636, 1596, 3644, 1604, 3652, 1612, 3660,
    1620, 3668, 1628, 3676, 1636, 3684, 1644, 3692, 1652, 3700, 1660, 3708, 1668, 3716, 1676, 3724,
    1684, 3732, 1692, 3740, 1700, 3748, 1708, 3756, 1716, 3764, 1724, 3772, 1732, 3780, 1740, 3788,
    1748, 3796, 1756, 3804, 1764, 3812, 1772, 3820, 1780, 3828, 1788, 3836, 1796, 3844, 1804, 3852,
    1812, 3860, 1820, 3868, 1828, 3876, 1836, 3884, 1844, 3892, 1852, 3900, 1860, 3908, 1868, 3916,
    1876, 3924, 1884, 3932, 1892, 3940, 1900, 3948, 1908, 3956, 1916, 3964, 1924, 3972, 1932, 3980,
    1940, 3988, 1948, 3996, 1956, 4004, 1964, 4012, 1972, 4020, 1980, 4028, 1988, 4036, 1996, 4044,
    2004, 4052, 2012, 4060, 2020, 4068, 2028, 4076, 2036, 4084, 2044, 4092, 8, 24, 40, 56, 72, 88,
    104, 120, 136, 152, 168, 184, 200, 216, 232, 248, 264, 280, 296, 312, 328, 344, 360, 376, 392,
    408, 424, 440, 456, 472, 488, 504, 520, 536, 552, 568, 584, 600, 616, 632, 648, 664, 680, 696,
    712, 728, 744, 760, 776, 792, 808, 824, 840, 856, 872, 888, 904, 920, 936, 952, 968, 984, 1000,
    1016, 1032, 1048, 1064, 1080, 1096, 1112, 1128, 1144, 1160, 1176, 1192, 1208, 1224, 1240, 1256,
    1272, 1288, 1304, 1320, 1336, 1352, 1368, 1384, 1400, 1416, 1432, 1448, 1464, 1480, 1496, 1512,
    1528, 1544, 1560, 1576, 1592, 1608, 1624, 1640, 1656, 1672, 1688, 1704, 1720, 1736, 1752, 1768,
    1784, 1800, 1816, 1832, 1848, 1864, 1880, 1896, 1912, 1928, 1944, 1960, 1976, 1992, 2008, 2024,
    2040, 2056, 2072, 2088, 2104, 2120, 2136, 2152, 2168, 2184, 2200, 2216, 2232, 2248, 2264, 2280,
    2296, 2312, 2328, 2344, 2360, 2376, 2392, 2408, 2424, 2440, 2456, 2472, 2488, 2504, 2520, 2536,
    2552, 2568, 2584, 2600, 2616, 2632, 2648, 2664, 2680, 2696, 2712, 2728, 2744, 2760, 2776, 2792,
    2808, 2824, 2840, 2856, 2872, 2888, 2904, 2920, 2936, 2952, 2968, 2984, 3000, 3016, 3032, 3048,
    3064, 3080, 3096, 3112, 3128, 3144, 3160, 3176, 3192, 3208, 3224, 3240, 3256, 3272, 3288, 3304,
    3320, 3336, 3352, 3368, 3384, 3400, 3416, 3432, 3448, 3464, 3480, 3496, 3512, 3528, 3544, 3560,
    3576, 3592, 3608, 3624, 3640, 3656, 3672, 3688, 3704, 3720, 3736, 3752, 3768, 3784, 3800, 3816,
    3832, 3848, 3864, 3880, 3896, 3912, 3928, 3944, 3960, 3976, 3992, 4008, 4024, 4040, 4056, 4072,
    4088, 4104, 4120, 4136, 4152, 4168, 4184, 4200, 4216, 4232, 4248, 4264, 4280, 4296, 4312, 4328,
    4344, 4360, 4376, 4392, 4408, 4424, 4440, 4456, 4472, 4488, 4504, 4520, 4536, 4552, 4568, 4584,
    4600, 4616, 4632, 4648, 4664, 4680, 4696, 4712, 4728, 4744, 4760, 4776, 4792, 4808, 4824, 4840,
    4856, 4872, 4888, 4904, 4920, 4936, 4952, 4968, 4984, 5000, 5016, 5032, 5048, 5064, 5080, 5096,
    5112, 5128, 5144, 5160, 5176, 5192, 5208, 5224, 5240, 5256, 5272, 5288, 5304, 5320, 5336, 5352,
    5368, 5384, 5400, 5416, 5432, 5448, 5464, 5480, 5496, 5512, 5528, 5544, 5560, 5576, 5592, 5608,
    5624, 5640, 5656, 5672, 5688, 5704, 5720, 5736, 5752, 5768, 5784, 5800, 5816, 5832, 5848, 5864,
    5880, 5896, 5912, 5928, 5944, 5960, 5976, 5992, 6008, 6024, 6040, 6056, 6072, 6088, 6104, 6120,
    6136, 6152, 6168, 6184, 6200, 6216, 6232, 6248, 6264, 6280, 6296, 6312, 6328, 6344, 6360, 6376,
    6392, 6408, 6424, 6440, 6456, 6472, 6488, 6504, 6520, 6536, 6552, 6568, 6584, 6600, 6616, 6632,
    6648, 6664, 6680, 6696, 6712, 6728, 6744, 6760, 6776, 6792, 6808, 6824, 6840, 6856, 6872, 6888,
    6904, 6920, 6936, 6952, 6968, 6984, 7000, 7016, 7032, 7048, 7064, 7080, 7096, 7112, 7128, 7144,
    7160, 7176, 7192, 7208, 7224, 7240, 7256, 7272, 7288, 7304, 7320, 7336, 7352, 7368, 7384, 7400,
    7416, 7432, 7448, 7464, 7480, 7496, 7512, 7528, 7544, 7560, 7576, 7592, 7608, 7624, 7640, 7656,
    7672, 7688, 7704, 7720, 7736, 7752, 7768, 7784, 7800, 7816, 7832, 7848, 7864, 7880, 7896, 7912,
    7928, 7944, 7960, 7976, 7992, 8008, 8024, 8040, 8056, 8072, 8088, 8104, 8120, 8136, 8152, 8168,
    8184, 8200,
];
///Table used to speed up the writing of zeta codes
pub const WRITE_LEN_LE: &[u16] = &[
    3, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    16,
];
///Table used to speed up the skipping of zeta codes
pub const LEN: &[u8] = &[
    3, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    16,
];
/// The K of the zeta codes for these tables
pub const K: u64 = 3;

```````

`/home/zom/Github/dsi-bitstream-rs/src/codes/code.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2024 Tommaso Fontana
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

//! A module for selecting the code to use either dynamically or at compile time.
//!
//! - [`Code`] is an enum with all the supported codes and can be used
//!   to test different codes in a generic way.
//! - [`ConstCode`] is a zero-sized struct with a const generic parameter that can be used
//!   to select the code at compile time.
//!
//! [`CodeRead`], [`CodeWrite`] and [`CodeLen`] are traits that both
//! [`Code`] and [`ConstCode`] implement to allow for generic code selection
//! over a generic bitstream.
//!
//! If you need to read or write a code multiple times on the same type of bitstream,
//! you can use [`CodeReadDispatch`] and [`CodeWriteDispatch`] which are
//! specialized versions of [`CodeRead`] and [`CodeWrite`] that are implemented
//! by [`Code`], [`ConstCode`] and [`CodeReadDispatcher`], [`CodeWriteDispatcher`]
//! which are more efficient for multiple reads and writes because they do
//! not need to do dynamic dispatch.
//!
//! [`CodeStatsWrapper`] is a struct that can wrap any struct implementing
//! [`CodeRead`] or [`CodeWrite`], and keep track of the space it would need to
//! store the same sequence using different codes. This can be used as a
//! transparent wrapper to figure out which code is the best for a given sequence.
//!

use super::*;
use core::error::Error;
use core::fmt::Debug;
use core::marker::PhantomData;

/// Something that can decode a value form any bitstream.
pub trait CodeRead {
    type Error<CRE>: Error + Debug + Send + Sync + 'static
    where
        CRE: Error + Debug + Send + Sync + 'static;
    /// Read a value
    fn read<E: Endianness, CR: ReadCodes<E> + ?Sized>(
        &self,
        reader: &mut CR,
    ) -> Result<u64, Self::Error<CR::Error>>;
}

/// Like [`CodeRead`] but with a specific endianness and reader.
/// This more specialized version allows also to do single static dispatch
/// of the read method for a code.
pub trait CodeReadDispatch<E, CR>
where
    E: Endianness,
    CR: ReadCodes<E> + ?Sized,
{
    type Error<CRE>: Error + Debug + Send + Sync + 'static
    where
        CRE: Error + Debug + Send + Sync + 'static;
    fn read_dispatch(&self, reader: &mut CR) -> Result<u64, Self::Error<CR::Error>>;
}

/// Something that can encode a value to any bitstream.
pub trait CodeWrite {
    type Error<CWE>: Error + Debug + Send + Sync + 'static
    where
        CWE: Error + Debug + Send + Sync + 'static;
    /// Write a value
    fn write<E: Endianness, CW: WriteCodes<E> + ?Sized>(
        &self,
        writer: &mut CW,
        value: u64,
    ) -> Result<usize, Self::Error<CW::Error>>;
}

/// Like [`CodeWrite`] but with a specific endianness and writer.
/// This more specialized version allows also to do single static dispatch
/// of the write method for a code.
pub trait CodeWriteDispatch<E, CW>
where
    E: Endianness,
    CW: WriteCodes<E> + ?Sized,
{
    type Error<CWE>: Error + Debug + Send + Sync + 'static
    where
        CWE: Error + Debug + Send + Sync + 'static;
    fn write_dispatch(&self, writer: &mut CW, value: u64) -> Result<usize, Self::Error<CW::Error>>;
}

/// Something that can compute the length of a value encoded with a code.
pub trait CodeLen {
    /// Compute how many bits it takes to encode a value with this code.
    fn len(&self, value: u64) -> usize;
}

#[derive(Debug)]
/// Error type for parsing a code from a string.
pub enum CodeError {
    ParseError(core::num::ParseIntError),
    UnknownCode(String),
}
impl std::error::Error for CodeError {}
impl core::fmt::Display for CodeError {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            CodeError::ParseError(e) => write!(f, "Parse error: {}", e),
            CodeError::UnknownCode(s) => write!(f, "Unknown code: {}", s),
        }
    }
}

impl From<core::num::ParseIntError> for CodeError {
    fn from(e: core::num::ParseIntError) -> Self {
        CodeError::ParseError(e)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
#[non_exhaustive]
/// An enum of all the codes supported by this library, with their parameters.
/// This can be used to test different codes in a generic way.
pub enum Code {
    Unary,
    Gamma,
    Delta,
    Omega,
    VByte,
    Zeta { k: usize },
    Pi { k: usize },
    PiWeb { k: usize },
    Golomb { b: usize },
    ExpGolomb { k: usize },
    Rice { log2_b: usize },
}

impl CodeRead for Code {
    type Error<CRE> = CRE
    where
        CRE: Error + Debug + Send + Sync + 'static;
    #[inline]
    fn read<E: Endianness, CR: ReadCodes<E> + ?Sized>(
        &self,
        reader: &mut CR,
    ) -> Result<u64, Self::Error<CR::Error>> {
        Ok(match self {
            Code::Unary => reader.read_unary()?,
            Code::Gamma => reader.read_gamma()?,
            Code::Delta => reader.read_delta()?,
            Code::Omega => reader.read_omega()?,
            Code::VByte => reader.read_vbyte()?,
            Code::Zeta { k: 3 } => reader.read_zeta3()?,
            Code::Zeta { k } => reader.read_zeta(*k as u64)?,
            Code::Pi { k } => reader.read_pi(*k as u64)?,
            Code::PiWeb { k } => reader.read_pi_web(*k as u64)?,
            Code::Golomb { b } => reader.read_golomb(*b as u64)?,
            Code::ExpGolomb { k } => reader.read_exp_golomb(*k)?,
            Code::Rice { log2_b } => reader.read_rice(*log2_b)?,
        })
    }
}

impl<E, CR> CodeReadDispatch<E, CR> for Code
where
    E: Endianness,
    CR: ReadCodes<E> + ?Sized,
{
    type Error<CRE> = CRE
    where
        CRE: Error + Debug + Send + Sync + 'static;
    #[inline(always)]
    fn read_dispatch(&self, reader: &mut CR) -> Result<u64, Self::Error<CR::Error>> {
        <Self as CodeRead>::read(self, reader)
    }
}

impl CodeWrite for Code {
    type Error<CWE> = CWE
    where
        CWE: Error + Debug + Send + Sync + 'static;
    #[inline]
    fn write<E: Endianness, CW: WriteCodes<E> + ?Sized>(
        &self,
        writer: &mut CW,
        value: u64,
    ) -> Result<usize, Self::Error<CW::Error>> {
        Ok(match self {
            Code::Unary => writer.write_unary(value)?,
            Code::Gamma => writer.write_gamma(value)?,
            Code::Delta => writer.write_delta(value)?,
            Code::Omega => writer.write_omega(value)?,
            Code::VByte => writer.write_vbyte(value)?,
            Code::Zeta { k: 3 } => writer.write_zeta3(value)?,
            Code::Zeta { k } => writer.write_zeta(value, *k as u64)?,
            Code::Pi { k } => writer.write_pi(value, *k as u64)?,
            Code::PiWeb { k } => writer.write_pi_web(value, *k as u64)?,
            Code::Golomb { b } => writer.write_golomb(value, *b as u64)?,
            Code::ExpGolomb { k } => writer.write_exp_golomb(value, *k)?,
            Code::Rice { log2_b } => writer.write_rice(value, *log2_b)?,
        })
    }
}

impl<E, CW> CodeWriteDispatch<E, CW> for Code
where
    E: Endianness,
    CW: WriteCodes<E> + ?Sized,
{
    type Error<CWE> = CWE
    where
        CWE: Error + Debug + Send + Sync + 'static;
    #[inline(always)]
    fn write_dispatch(&self, writer: &mut CW, value: u64) -> Result<usize, Self::Error<CW::Error>> {
        <Self as CodeWrite>::write(self, writer, value)
    }
}

impl CodeLen for Code {
    #[inline]
    fn len(&self, value: u64) -> usize {
        match self {
            Code::Unary => value as usize + 1,
            Code::Gamma => len_gamma(value),
            Code::Delta => len_delta(value),
            Code::Omega => len_omega(value),
            Code::VByte => len_vbyte(value),
            Code::Zeta { k } => len_zeta(value, *k as u64),
            Code::Pi { k } => len_pi(value, *k as u64),
            Code::PiWeb { k } => len_pi_web(value, *k as u64),
            Code::Golomb { b } => len_golomb(value, *b as u64),
            Code::ExpGolomb { k } => len_exp_golomb(value, *k),
            Code::Rice { log2_b } => len_rice(value, *log2_b),
        }
    }
}

impl core::fmt::Display for Code {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            Code::Unary => write!(f, "Unary"),
            Code::Gamma => write!(f, "Gamma"),
            Code::Delta => write!(f, "Delta"),
            Code::Omega => write!(f, "Omega"),
            Code::VByte => write!(f, "VByte"),
            Code::Zeta { k } => write!(f, "Zeta({})", k),
            Code::Pi { k } => write!(f, "Pi({})", k),
            Code::PiWeb { k } => write!(f, "PiWeb({})", k),
            Code::Golomb { b } => write!(f, "Golomb({})", b),
            Code::ExpGolomb { k } => write!(f, "ExpGolomb({})", k),
            Code::Rice { log2_b } => write!(f, "Rice({})", log2_b),
        }
    }
}

impl std::str::FromStr for Code {
    type Err = CodeError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Unary" => Ok(Code::Unary),
            "Gamma" => Ok(Code::Gamma),
            "Delta" => Ok(Code::Delta),
            "Omega" => Ok(Code::Omega),
            "VByte" => Ok(Code::VByte),
            _ => {
                let mut parts = s.split('(');
                let name = parts
                    .next()
                    .ok_or_else(|| CodeError::UnknownCode(format!("Could not parse {}", s)))?;
                let k = parts
                    .next()
                    .ok_or_else(|| CodeError::UnknownCode(format!("Could not parse {}", s)))?
                    .split(')')
                    .next()
                    .ok_or_else(|| CodeError::UnknownCode(format!("Could not parse {}", s)))?;
                match name {
                    "Zeta" => Ok(Code::Zeta { k: k.parse()? }),
                    "Pi" => Ok(Code::Pi { k: k.parse()? }),
                    "PiWeb" => Ok(Code::PiWeb { k: k.parse()? }),
                    "Golomb" => Ok(Code::Golomb { b: k.parse()? }),
                    "ExpGolomb" => Ok(Code::ExpGolomb { k: k.parse()? }),
                    "Rice" => Ok(Code::Rice { log2_b: k.parse()? }),
                    _ => Err(CodeError::UnknownCode(format!("Could not parse {}", name))),
                }
            }
        }
    }
}

type ReadFn<E, CR> = fn(&mut CR) -> Result<u64, <CR as BitRead<E>>::Error>;

/// Single static dispatch of the read method for a code.
/// This is a more efficient way to read codes that are initialized once dynamically,
/// and then used multiple times.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct CodeReadDispatcher<E, CR>
where
    E: Endianness,
    CR: ReadCodes<E> + ?Sized,
{
    read: ReadFn<E, CR>,
    _marker: PhantomData<E>,
}

impl<E, CR> CodeReadDispatcher<E, CR>
where
    E: Endianness,
    CR: ReadCodes<E> + ?Sized,
{
    pub const UNARY: ReadFn<E, CR> = |reader: &mut CR| reader.read_unary();
    pub const GAMMA: ReadFn<E, CR> = |reader: &mut CR| reader.read_gamma();
    pub const DELTA: ReadFn<E, CR> = |reader: &mut CR| reader.read_delta();
    pub const OMEGA: ReadFn<E, CR> = |reader: &mut CR| reader.read_omega();
    pub const VBYTE: ReadFn<E, CR> = |reader: &mut CR| reader.read_vbyte();
    pub const ZETA2: ReadFn<E, CR> = |reader: &mut CR| reader.read_zeta(2);
    pub const ZETA3: ReadFn<E, CR> = |reader: &mut CR| reader.read_zeta3();
    pub const ZETA4: ReadFn<E, CR> = |reader: &mut CR| reader.read_zeta(4);
    pub const ZETA5: ReadFn<E, CR> = |reader: &mut CR| reader.read_zeta(5);
    pub const ZETA6: ReadFn<E, CR> = |reader: &mut CR| reader.read_zeta(6);
    pub const ZETA7: ReadFn<E, CR> = |reader: &mut CR| reader.read_zeta(7);
    pub const ZETA8: ReadFn<E, CR> = |reader: &mut CR| reader.read_zeta(8);
    pub const ZETA9: ReadFn<E, CR> = |reader: &mut CR| reader.read_zeta(9);
    pub const ZETA10: ReadFn<E, CR> = |reader: &mut CR| reader.read_zeta(10);
    pub const PI2: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi(2);
    pub const PI3: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi(3);
    pub const PI4: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi(4);
    pub const PI5: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi(5);
    pub const PI6: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi(6);
    pub const PI7: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi(7);
    pub const PI8: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi(8);
    pub const PI9: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi(9);
    pub const PI10: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi(10);
    pub const PI_WEB2: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi_web(2);
    pub const PI_WEB3: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi_web(3);
    pub const PI_WEB4: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi_web(4);
    pub const PI_WEB5: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi_web(5);
    pub const PI_WEB6: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi_web(6);
    pub const PI_WEB7: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi_web(7);
    pub const PI_WEB8: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi_web(8);
    pub const PI_WEB9: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi_web(9);
    pub const PI_WEB10: ReadFn<E, CR> = |reader: &mut CR| reader.read_pi_web(10);
    pub const GOLOMB2: ReadFn<E, CR> = |reader: &mut CR| reader.read_golomb(2);
    pub const GOLOMB3: ReadFn<E, CR> = |reader: &mut CR| reader.read_golomb(3);
    pub const GOLOMB4: ReadFn<E, CR> = |reader: &mut CR| reader.read_golomb(4);
    pub const GOLOMB5: ReadFn<E, CR> = |reader: &mut CR| reader.read_golomb(5);
    pub const GOLOMB6: ReadFn<E, CR> = |reader: &mut CR| reader.read_golomb(6);
    pub const GOLOMB7: ReadFn<E, CR> = |reader: &mut CR| reader.read_golomb(7);
    pub const GOLOMB8: ReadFn<E, CR> = |reader: &mut CR| reader.read_golomb(8);
    pub const GOLOMB9: ReadFn<E, CR> = |reader: &mut CR| reader.read_golomb(9);
    pub const GOLOMB10: ReadFn<E, CR> = |reader: &mut CR| reader.read_golomb(10);
    pub const EXP_GOLOMB2: ReadFn<E, CR> = |reader: &mut CR| reader.read_exp_golomb(2);
    pub const EXP_GOLOMB3: ReadFn<E, CR> = |reader: &mut CR| reader.read_exp_golomb(3);
    pub const EXP_GOLOMB4: ReadFn<E, CR> = |reader: &mut CR| reader.read_exp_golomb(4);
    pub const EXP_GOLOMB5: ReadFn<E, CR> = |reader: &mut CR| reader.read_exp_golomb(5);
    pub const EXP_GOLOMB6: ReadFn<E, CR> = |reader: &mut CR| reader.read_exp_golomb(6);
    pub const EXP_GOLOMB7: ReadFn<E, CR> = |reader: &mut CR| reader.read_exp_golomb(7);
    pub const EXP_GOLOMB8: ReadFn<E, CR> = |reader: &mut CR| reader.read_exp_golomb(8);
    pub const EXP_GOLOMB9: ReadFn<E, CR> = |reader: &mut CR| reader.read_exp_golomb(9);
    pub const EXP_GOLOMB10: ReadFn<E, CR> = |reader: &mut CR| reader.read_exp_golomb(10);
    pub const RICE2: ReadFn<E, CR> = |reader: &mut CR| reader.read_rice(2);
    pub const RICE3: ReadFn<E, CR> = |reader: &mut CR| reader.read_rice(3);
    pub const RICE4: ReadFn<E, CR> = |reader: &mut CR| reader.read_rice(4);
    pub const RICE5: ReadFn<E, CR> = |reader: &mut CR| reader.read_rice(5);
    pub const RICE6: ReadFn<E, CR> = |reader: &mut CR| reader.read_rice(6);
    pub const RICE7: ReadFn<E, CR> = |reader: &mut CR| reader.read_rice(7);
    pub const RICE8: ReadFn<E, CR> = |reader: &mut CR| reader.read_rice(8);
    pub const RICE9: ReadFn<E, CR> = |reader: &mut CR| reader.read_rice(9);
    pub const RICE10: ReadFn<E, CR> = |reader: &mut CR| reader.read_rice(10);

    /// Create a new dispatch for the given code.
    pub fn new(code: Code) -> Result<Self> {
        let read = match code {
            Code::Unary => Self::UNARY,
            Code::Gamma => Self::GAMMA,
            Code::Delta => Self::DELTA,
            Code::Omega => Self::OMEGA,
            Code::VByte => Self::VBYTE,
            Code::Zeta { k: 2 } => Self::ZETA2,
            Code::Zeta { k: 3 } => Self::ZETA3,
            Code::Zeta { k: 4 } => Self::ZETA4,
            Code::Zeta { k: 5 } => Self::ZETA5,
            Code::Zeta { k: 6 } => Self::ZETA6,
            Code::Zeta { k: 7 } => Self::ZETA7,
            Code::Zeta { k: 8 } => Self::ZETA8,
            Code::Zeta { k: 9 } => Self::ZETA9,
            Code::Zeta { k: 10 } => Self::ZETA10,
            Code::Pi { k: 2 } => Self::PI2,
            Code::Pi { k: 3 } => Self::PI3,
            Code::Pi { k: 4 } => Self::PI4,
            Code::Pi { k: 5 } => Self::PI5,
            Code::Pi { k: 6 } => Self::PI6,
            Code::Pi { k: 7 } => Self::PI7,
            Code::Pi { k: 8 } => Self::PI8,
            Code::Pi { k: 9 } => Self::PI9,
            Code::Pi { k: 10 } => Self::PI10,
            Code::PiWeb { k: 2 } => Self::PI_WEB2,
            Code::PiWeb { k: 3 } => Self::PI_WEB3,
            Code::PiWeb { k: 4 } => Self::PI_WEB4,
            Code::PiWeb { k: 5 } => Self::PI_WEB5,
            Code::PiWeb { k: 6 } => Self::PI_WEB6,
            Code::PiWeb { k: 7 } => Self::PI_WEB7,
            Code::PiWeb { k: 8 } => Self::PI_WEB8,
            Code::PiWeb { k: 9 } => Self::PI_WEB9,
            Code::PiWeb { k: 10 } => Self::PI_WEB10,
            Code::Golomb { b: 2 } => Self::GOLOMB2,
            Code::Golomb { b: 3 } => Self::GOLOMB3,
            Code::Golomb { b: 4 } => Self::GOLOMB4,
            Code::Golomb { b: 5 } => Self::GOLOMB5,
            Code::Golomb { b: 6 } => Self::GOLOMB6,
            Code::Golomb { b: 7 } => Self::GOLOMB7,
            Code::Golomb { b: 8 } => Self::GOLOMB8,
            Code::Golomb { b: 9 } => Self::GOLOMB9,
            Code::Golomb { b: 10 } => Self::GOLOMB10,
            Code::ExpGolomb { k: 2 } => Self::EXP_GOLOMB2,
            Code::ExpGolomb { k: 3 } => Self::EXP_GOLOMB3,
            Code::ExpGolomb { k: 4 } => Self::EXP_GOLOMB4,
            Code::ExpGolomb { k: 5 } => Self::EXP_GOLOMB5,
            Code::ExpGolomb { k: 6 } => Self::EXP_GOLOMB6,
            Code::ExpGolomb { k: 7 } => Self::EXP_GOLOMB7,
            Code::ExpGolomb { k: 8 } => Self::EXP_GOLOMB8,
            Code::ExpGolomb { k: 9 } => Self::EXP_GOLOMB9,
            Code::ExpGolomb { k: 10 } => Self::EXP_GOLOMB10,
            Code::Rice { log2_b: 2 } => Self::RICE2,
            Code::Rice { log2_b: 3 } => Self::RICE3,
            Code::Rice { log2_b: 4 } => Self::RICE4,
            Code::Rice { log2_b: 5 } => Self::RICE5,
            Code::Rice { log2_b: 6 } => Self::RICE6,
            Code::Rice { log2_b: 7 } => Self::RICE7,
            Code::Rice { log2_b: 8 } => Self::RICE8,
            Code::Rice { log2_b: 9 } => Self::RICE9,
            Code::Rice { log2_b: 10 } => Self::RICE10,
            _ => anyhow::bail!("Unsupported read dispatch for code {:?}", code),
        };
        Ok(Self {
            read,
            _marker: PhantomData,
        })
    }
}

impl<E, CR> CodeReadDispatch<E, CR> for CodeReadDispatcher<E, CR>
where
    E: Endianness,
    CR: ReadCodes<E> + ?Sized,
{
    type Error<CRE> = CRE
    where
        CRE: Error + Debug + Send + Sync + 'static;

    #[inline(always)]
    fn read_dispatch(&self, reader: &mut CR) -> Result<u64, Self::Error<CR::Error>> {
        (self.read)(reader).map_err(Into::into)
    }
}

type WriteFn<E, CW> = fn(&mut CW, u64) -> Result<usize, <CW as BitWrite<E>>::Error>;

/// Single static dispatch of the write method for a code.
/// This is a more efficient way to write codes that are initialized once dynamically,
/// and then used multiple times.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct CodeWriteDispatcher<E, CW>
where
    E: Endianness,
    CW: WriteCodes<E> + ?Sized,
{
    write: WriteFn<E, CW>,
    _marker: PhantomData<E>,
}

impl<E, CW> CodeWriteDispatcher<E, CW>
where
    E: Endianness,
    CW: WriteCodes<E> + ?Sized,
{
    pub const UNARY: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_unary(value);
    pub const GAMMA: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_gamma(value);
    pub const DELTA: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_delta(value);
    pub const OMEGA: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_omega(value);
    pub const VBYTE: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_vbyte(value);
    pub const ZETA2: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_zeta(value, 2);
    pub const ZETA3: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_zeta3(value);
    pub const ZETA4: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_zeta(value, 4);
    pub const ZETA5: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_zeta(value, 5);
    pub const ZETA6: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_zeta(value, 6);
    pub const ZETA7: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_zeta(value, 7);
    pub const ZETA8: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_zeta(value, 8);
    pub const ZETA9: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_zeta(value, 9);
    pub const ZETA10: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_zeta(value, 10);
    pub const PI2: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi(value, 2);
    pub const PI3: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi(value, 3);
    pub const PI4: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi(value, 4);
    pub const PI5: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi(value, 5);
    pub const PI6: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi(value, 6);
    pub const PI7: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi(value, 7);
    pub const PI8: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi(value, 8);
    pub const PI9: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi(value, 9);
    pub const PI10: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi(value, 10);
    pub const PI_WEB2: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi_web(value, 2);
    pub const PI_WEB3: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi_web(value, 3);
    pub const PI_WEB4: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi_web(value, 4);
    pub const PI_WEB5: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi_web(value, 5);
    pub const PI_WEB6: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi_web(value, 6);
    pub const PI_WEB7: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi_web(value, 7);
    pub const PI_WEB8: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi_web(value, 8);
    pub const PI_WEB9: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_pi_web(value, 9);
    pub const PI_WEB10: WriteFn<E, CW> =
        |writer: &mut CW, value: u64| writer.write_pi_web(value, 10);
    pub const GOLOMB2: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_golomb(value, 2);
    pub const GOLOMB3: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_golomb(value, 3);
    pub const GOLOMB4: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_golomb(value, 4);
    pub const GOLOMB5: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_golomb(value, 5);
    pub const GOLOMB6: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_golomb(value, 6);
    pub const GOLOMB7: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_golomb(value, 7);
    pub const GOLOMB8: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_golomb(value, 8);
    pub const GOLOMB9: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_golomb(value, 9);
    pub const GOLOMB10: WriteFn<E, CW> =
        |writer: &mut CW, value: u64| writer.write_golomb(value, 10);
    pub const EXP_GOLOMB2: WriteFn<E, CW> =
        |writer: &mut CW, value: u64| writer.write_exp_golomb(value, 2);
    pub const EXP_GOLOMB3: WriteFn<E, CW> =
        |writer: &mut CW, value: u64| writer.write_exp_golomb(value, 3);
    pub const EXP_GOLOMB4: WriteFn<E, CW> =
        |writer: &mut CW, value: u64| writer.write_exp_golomb(value, 4);
    pub const EXP_GOLOMB5: WriteFn<E, CW> =
        |writer: &mut CW, value: u64| writer.write_exp_golomb(value, 5);
    pub const EXP_GOLOMB6: WriteFn<E, CW> =
        |writer: &mut CW, value: u64| writer.write_exp_golomb(value, 6);
    pub const EXP_GOLOMB7: WriteFn<E, CW> =
        |writer: &mut CW, value: u64| writer.write_exp_golomb(value, 7);
    pub const EXP_GOLOMB8: WriteFn<E, CW> =
        |writer: &mut CW, value: u64| writer.write_exp_golomb(value, 8);
    pub const EXP_GOLOMB9: WriteFn<E, CW> =
        |writer: &mut CW, value: u64| writer.write_exp_golomb(value, 9);
    pub const EXP_GOLOMB10: WriteFn<E, CW> =
        |writer: &mut CW, value: u64| writer.write_exp_golomb(value, 10);
    pub const RICE2: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_rice(value, 2);
    pub const RICE3: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_rice(value, 3);
    pub const RICE4: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_rice(value, 4);
    pub const RICE5: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_rice(value, 5);
    pub const RICE6: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_rice(value, 6);
    pub const RICE7: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_rice(value, 7);
    pub const RICE8: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_rice(value, 8);
    pub const RICE9: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_rice(value, 9);
    pub const RICE10: WriteFn<E, CW> = |writer: &mut CW, value: u64| writer.write_rice(value, 10);

    pub fn new(code: Code) -> Result<Self> {
        let write = match code {
            Code::Unary => Self::UNARY,
            Code::Gamma => Self::GAMMA,
            Code::Delta => Self::DELTA,
            Code::Omega => Self::OMEGA,
            Code::VByte => Self::VBYTE,
            Code::Zeta { k: 2 } => Self::ZETA2,
            Code::Zeta { k: 3 } => Self::ZETA3,
            Code::Zeta { k: 4 } => Self::ZETA4,
            Code::Zeta { k: 5 } => Self::ZETA5,
            Code::Zeta { k: 6 } => Self::ZETA6,
            Code::Zeta { k: 7 } => Self::ZETA7,
            Code::Zeta { k: 8 } => Self::ZETA8,
            Code::Zeta { k: 9 } => Self::ZETA9,
            Code::Zeta { k: 10 } => Self::ZETA10,
            Code::Pi { k: 2 } => Self::PI2,
            Code::Pi { k: 3 } => Self::PI3,
            Code::Pi { k: 4 } => Self::PI4,
            Code::Pi { k: 5 } => Self::PI5,
            Code::Pi { k: 6 } => Self::PI6,
            Code::Pi { k: 7 } => Self::PI7,
            Code::Pi { k: 8 } => Self::PI8,
            Code::Pi { k: 9 } => Self::PI9,
            Code::Pi { k: 10 } => Self::PI10,
            Code::PiWeb { k: 2 } => Self::PI_WEB2,
            Code::PiWeb { k: 3 } => Self::PI_WEB3,
            Code::PiWeb { k: 4 } => Self::PI_WEB4,
            Code::PiWeb { k: 5 } => Self::PI_WEB5,
            Code::PiWeb { k: 6 } => Self::PI_WEB6,
            Code::PiWeb { k: 7 } => Self::PI_WEB7,
            Code::PiWeb { k: 8 } => Self::PI_WEB8,
            Code::PiWeb { k: 9 } => Self::PI_WEB9,
            Code::PiWeb { k: 10 } => Self::PI_WEB10,
            Code::Golomb { b: 2 } => Self::GOLOMB2,
            Code::Golomb { b: 3 } => Self::GOLOMB3,
            Code::Golomb { b: 4 } => Self::GOLOMB4,
            Code::Golomb { b: 5 } => Self::GOLOMB5,
            Code::Golomb { b: 6 } => Self::GOLOMB6,
            Code::Golomb { b: 7 } => Self::GOLOMB7,
            Code::Golomb { b: 8 } => Self::GOLOMB8,
            Code::Golomb { b: 9 } => Self::GOLOMB9,
            Code::Golomb { b: 10 } => Self::GOLOMB10,
            Code::ExpGolomb { k: 2 } => Self::EXP_GOLOMB2,
            Code::ExpGolomb { k: 3 } => Self::EXP_GOLOMB3,
            Code::ExpGolomb { k: 4 } => Self::EXP_GOLOMB4,
            Code::ExpGolomb { k: 5 } => Self::EXP_GOLOMB5,
            Code::ExpGolomb { k: 6 } => Self::EXP_GOLOMB6,
            Code::ExpGolomb { k: 7 } => Self::EXP_GOLOMB7,
            Code::ExpGolomb { k: 8 } => Self::EXP_GOLOMB8,
            Code::ExpGolomb { k: 9 } => Self::EXP_GOLOMB9,
            Code::ExpGolomb { k: 10 } => Self::EXP_GOLOMB10,
            Code::Rice { log2_b: 2 } => Self::RICE2,
            Code::Rice { log2_b: 3 } => Self::RICE3,
            Code::Rice { log2_b: 4 } => Self::RICE4,
            Code::Rice { log2_b: 5 } => Self::RICE5,
            Code::Rice { log2_b: 6 } => Self::RICE6,
            Code::Rice { log2_b: 7 } => Self::RICE7,
            Code::Rice { log2_b: 8 } => Self::RICE8,
            Code::Rice { log2_b: 9 } => Self::RICE9,
            Code::Rice { log2_b: 10 } => Self::RICE10,
            _ => anyhow::bail!("Unsupported write dispatch for code {:?}", code),
        };
        Ok(Self {
            write,
            _marker: PhantomData,
        })
    }
}

impl<E, CW> CodeWriteDispatch<E, CW> for CodeWriteDispatcher<E, CW>
where
    E: Endianness,
    CW: WriteCodes<E> + ?Sized,
{
    type Error<CWE> = CWE
    where
        CWE: Error + Debug + Send + Sync + 'static;
    #[inline(always)]
    fn write_dispatch(&self, writer: &mut CW, value: u64) -> Result<usize, Self::Error<CW::Error>> {
        (self.write)(writer, value).map_err(Into::into)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
/// A zero-sized struct with a const generic parameter that can be used to
/// select the code at compile time.
pub struct ConstCode<const CODE: usize>;

/// The constants ot use as generic parameter of the [`ConstCode`] struct.
pub mod const_codes {
    /// This macro just define a bunch of constants with progressive values.
    /// It is used to assign a unique integer to each code.
    macro_rules! impl_codes {
        ($code:ident, $($tail:ident),*) => {
            pub const $code: usize = 0 $( + 1 + (0 * $tail))*;
            impl_codes!($($tail),*);
        };
        ($code:ident) => {
            pub const $code: usize = 0;
        };
    }

    impl_codes!(
        ZETA1,
        ZETA2,
        ZETA3,
        ZETA4,
        ZETA5,
        ZETA6,
        ZETA7,
        ZETA8,
        ZETA9,
        ZETA10,
        PI2,
        PI3,
        PI4,
        PI5,
        PI6,
        PI7,
        PI8,
        PI9,
        PI10,
        PI_WEB2,
        PI_WEB3,
        PI_WEB4,
        PI_WEB5,
        PI_WEB6,
        PI_WEB7,
        PI_WEB8,
        PI_WEB9,
        PI_WEB10,
        GOLOMB2,
        GOLOMB3,
        GOLOMB4,
        GOLOMB5,
        GOLOMB6,
        GOLOMB7,
        GOLOMB8,
        GOLOMB9,
        GOLOMB10,
        EXP_GOLOMB2,
        EXP_GOLOMB3,
        EXP_GOLOMB4,
        EXP_GOLOMB5,
        EXP_GOLOMB6,
        EXP_GOLOMB7,
        EXP_GOLOMB8,
        EXP_GOLOMB9,
        EXP_GOLOMB10,
        RICE2,
        RICE3,
        RICE4,
        RICE5,
        RICE6,
        RICE7,
        RICE8,
        RICE9,
        RICE10,
        VBYTE,
        OMEGA,
        DELTA,
        GAMMA,
        UNARY
    );
}

impl<const CODE: usize> CodeRead for ConstCode<CODE> {
    type Error<CRE> = CRE
    where
        CRE: Error + Debug + Send + Sync + 'static;
    fn read<E: Endianness, CR: ReadCodes<E> + ?Sized>(
        &self,
        reader: &mut CR,
    ) -> Result<u64, Self::Error<CR::Error>> {
        match CODE {
            const_codes::UNARY => reader.read_unary(),
            const_codes::GAMMA => reader.read_gamma(),
            const_codes::DELTA => reader.read_delta(),
            const_codes::OMEGA => reader.read_omega(),
            const_codes::VBYTE => reader.read_vbyte(),
            const_codes::ZETA1 => reader.read_zeta(1),
            const_codes::ZETA2 => reader.read_zeta(2),
            const_codes::ZETA3 => reader.read_zeta3(),
            const_codes::ZETA4 => reader.read_zeta(4),
            const_codes::ZETA5 => reader.read_zeta(5),
            const_codes::ZETA6 => reader.read_zeta(6),
            const_codes::ZETA7 => reader.read_zeta(7),
            const_codes::ZETA8 => reader.read_zeta(8),
            const_codes::ZETA9 => reader.read_zeta(9),
            const_codes::ZETA10 => reader.read_zeta(10),
            const_codes::PI2 => reader.read_pi(2),
            const_codes::PI3 => reader.read_pi(3),
            const_codes::PI4 => reader.read_pi(4),
            const_codes::PI5 => reader.read_pi(5),
            const_codes::PI6 => reader.read_pi(6),
            const_codes::PI7 => reader.read_pi(7),
            const_codes::PI8 => reader.read_pi(8),
            const_codes::PI9 => reader.read_pi(9),
            const_codes::PI10 => reader.read_pi(10),
            const_codes::PI_WEB2 => reader.read_pi_web(2),
            const_codes::PI_WEB3 => reader.read_pi_web(3),
            const_codes::PI_WEB4 => reader.read_pi_web(4),
            const_codes::PI_WEB5 => reader.read_pi_web(5),
            const_codes::PI_WEB6 => reader.read_pi_web(6),
            const_codes::PI_WEB7 => reader.read_pi_web(7),
            const_codes::PI_WEB8 => reader.read_pi_web(8),
            const_codes::PI_WEB9 => reader.read_pi_web(9),
            const_codes::PI_WEB10 => reader.read_pi_web(10),
            const_codes::GOLOMB2 => reader.read_golomb(2),
            const_codes::GOLOMB3 => reader.read_golomb(3),
            const_codes::GOLOMB4 => reader.read_golomb(4),
            const_codes::GOLOMB5 => reader.read_golomb(5),
            const_codes::GOLOMB6 => reader.read_golomb(6),
            const_codes::GOLOMB7 => reader.read_golomb(7),
            const_codes::GOLOMB8 => reader.read_golomb(8),
            const_codes::GOLOMB9 => reader.read_golomb(9),
            const_codes::GOLOMB10 => reader.read_golomb(10),
            const_codes::EXP_GOLOMB2 => reader.read_exp_golomb(2),
            const_codes::EXP_GOLOMB3 => reader.read_exp_golomb(3),
            const_codes::EXP_GOLOMB4 => reader.read_exp_golomb(4),
            const_codes::EXP_GOLOMB5 => reader.read_exp_golomb(5),
            const_codes::EXP_GOLOMB6 => reader.read_exp_golomb(6),
            const_codes::EXP_GOLOMB7 => reader.read_exp_golomb(7),
            const_codes::EXP_GOLOMB8 => reader.read_exp_golomb(8),
            const_codes::EXP_GOLOMB9 => reader.read_exp_golomb(9),
            const_codes::EXP_GOLOMB10 => reader.read_exp_golomb(10),
            const_codes::RICE2 => reader.read_rice(2),
            const_codes::RICE3 => reader.read_rice(3),
            const_codes::RICE4 => reader.read_rice(4),
            const_codes::RICE5 => reader.read_rice(5),
            const_codes::RICE6 => reader.read_rice(6),
            const_codes::RICE7 => reader.read_rice(7),
            const_codes::RICE8 => reader.read_rice(8),
            const_codes::RICE9 => reader.read_rice(9),
            const_codes::RICE10 => reader.read_rice(10),
            _ => panic!("Unknown code: {}", CODE),
        }
    }
}

impl<E, CR, const CODE: usize> CodeReadDispatch<E, CR> for ConstCode<CODE>
where
    E: Endianness,
    CR: ReadCodes<E> + ?Sized,
{
    type Error<CRE> = CRE
    where
        CRE: Error + Debug + Send + Sync + 'static;
    #[inline(always)]
    fn read_dispatch(&self, reader: &mut CR) -> Result<u64, Self::Error<CR::Error>> {
        <Self as CodeRead>::read(self, reader)
    }
}

impl<const CODE: usize> CodeWrite for ConstCode<CODE> {
    type Error<CWE> = CWE
    where
        CWE: Error + Debug + Send + Sync + 'static;
    fn write<E: Endianness, CW: WriteCodes<E> + ?Sized>(
        &self,
        writer: &mut CW,
        value: u64,
    ) -> Result<usize, Self::Error<CW::Error>> {
        match CODE {
            const_codes::UNARY => writer.write_unary(value),
            const_codes::GAMMA => writer.write_gamma(value),
            const_codes::DELTA => writer.write_delta(value),
            const_codes::OMEGA => writer.write_omega(value),
            const_codes::VBYTE => writer.write_vbyte(value),
            const_codes::ZETA1 => writer.write_zeta(value, 1),
            const_codes::ZETA2 => writer.write_zeta(value, 2),
            const_codes::ZETA3 => writer.write_zeta3(value),
            const_codes::ZETA4 => writer.write_zeta(value, 4),
            const_codes::ZETA5 => writer.write_zeta(value, 5),
            const_codes::ZETA6 => writer.write_zeta(value, 6),
            const_codes::ZETA7 => writer.write_zeta(value, 7),
            const_codes::ZETA8 => writer.write_zeta(value, 8),
            const_codes::ZETA9 => writer.write_zeta(value, 9),
            const_codes::ZETA10 => writer.write_zeta(value, 10),
            const_codes::PI2 => writer.write_pi(value, 2),
            const_codes::PI3 => writer.write_pi(value, 3),
            const_codes::PI4 => writer.write_pi(value, 4),
            const_codes::PI5 => writer.write_pi(value, 5),
            const_codes::PI6 => writer.write_pi(value, 6),
            const_codes::PI7 => writer.write_pi(value, 7),
            const_codes::PI8 => writer.write_pi(value, 8),
            const_codes::PI9 => writer.write_pi(value, 9),
            const_codes::PI10 => writer.write_pi(value, 10),
            const_codes::PI_WEB2 => writer.write_pi_web(value, 2),
            const_codes::PI_WEB3 => writer.write_pi_web(value, 3),
            const_codes::PI_WEB4 => writer.write_pi_web(value, 4),
            const_codes::PI_WEB5 => writer.write_pi_web(value, 5),
            const_codes::PI_WEB6 => writer.write_pi_web(value, 6),
            const_codes::PI_WEB7 => writer.write_pi_web(value, 7),
            const_codes::PI_WEB8 => writer.write_pi_web(value, 8),
            const_codes::PI_WEB9 => writer.write_pi_web(value, 9),
            const_codes::PI_WEB10 => writer.write_pi_web(value, 10),
            const_codes::GOLOMB2 => writer.write_golomb(value, 2),
            const_codes::GOLOMB3 => writer.write_golomb(value, 3),
            const_codes::GOLOMB4 => writer.write_golomb(value, 4),
            const_codes::GOLOMB5 => writer.write_golomb(value, 5),
            const_codes::GOLOMB6 => writer.write_golomb(value, 6),
            const_codes::GOLOMB7 => writer.write_golomb(value, 7),
            const_codes::GOLOMB8 => writer.write_golomb(value, 8),
            const_codes::GOLOMB9 => writer.write_golomb(value, 9),
            const_codes::GOLOMB10 => writer.write_golomb(value, 10),
            const_codes::EXP_GOLOMB2 => writer.write_exp_golomb(value, 2),
            const_codes::EXP_GOLOMB3 => writer.write_exp_golomb(value, 3),
            const_codes::EXP_GOLOMB4 => writer.write_exp_golomb(value, 4),
            const_codes::EXP_GOLOMB5 => writer.write_exp_golomb(value, 5),
            const_codes::EXP_GOLOMB6 => writer.write_exp_golomb(value, 6),
            const_codes::EXP_GOLOMB7 => writer.write_exp_golomb(value, 7),
            const_codes::EXP_GOLOMB8 => writer.write_exp_golomb(value, 8),
            const_codes::EXP_GOLOMB9 => writer.write_exp_golomb(value, 9),
            const_codes::EXP_GOLOMB10 => writer.write_exp_golomb(value, 10),
            const_codes::RICE2 => writer.write_rice(value, 2),
            const_codes::RICE3 => writer.write_rice(value, 3),
            const_codes::RICE4 => writer.write_rice(value, 4),
            const_codes::RICE5 => writer.write_rice(value, 5),
            const_codes::RICE6 => writer.write_rice(value, 6),
            const_codes::RICE7 => writer.write_rice(value, 7),
            const_codes::RICE8 => writer.write_rice(value, 8),
            const_codes::RICE9 => writer.write_rice(value, 9),
            const_codes::RICE10 => writer.write_rice(value, 10),
            _ => panic!("Unknown code: {}", CODE),
        }
    }
}

impl<E, CW, const CODE: usize> CodeWriteDispatch<E, CW> for ConstCode<CODE>
where
    E: Endianness,
    CW: WriteCodes<E> + ?Sized,
{
    type Error<CWE> = CWE
    where
        CWE: Error + Debug + Send + Sync + 'static;
    #[inline(always)]
    fn write_dispatch(&self, writer: &mut CW, value: u64) -> Result<usize, Self::Error<CW::Error>> {
        <Self as CodeWrite>::write(self, writer, value)
    }
}

impl<const CODE: usize> CodeLen for ConstCode<CODE> {
    #[inline]
    fn len(&self, value: u64) -> usize {
        match CODE {
            const_codes::UNARY => value as usize + 1,
            const_codes::GAMMA => len_gamma(value),
            const_codes::DELTA => len_delta(value),
            const_codes::OMEGA => len_omega(value),
            const_codes::VBYTE => len_vbyte(value),
            const_codes::ZETA1 => len_zeta(value, 1),
            const_codes::ZETA2 => len_zeta(value, 2),
            const_codes::ZETA3 => len_zeta(value, 3),
            const_codes::ZETA4 => len_zeta(value, 4),
            const_codes::ZETA5 => len_zeta(value, 5),
            const_codes::ZETA6 => len_zeta(value, 6),
            const_codes::ZETA7 => len_zeta(value, 7),
            const_codes::ZETA8 => len_zeta(value, 8),
            const_codes::ZETA9 => len_zeta(value, 9),
            const_codes::ZETA10 => len_zeta(value, 10),
            const_codes::PI2 => len_pi(value, 2),
            const_codes::PI3 => len_pi(value, 3),
            const_codes::PI4 => len_pi(value, 4),
            const_codes::PI5 => len_pi(value, 5),
            const_codes::PI6 => len_pi(value, 6),
            const_codes::PI7 => len_pi(value, 7),
            const_codes::PI8 => len_pi(value, 8),
            const_codes::PI9 => len_pi(value, 9),
            const_codes::PI10 => len_pi(value, 10),
            const_codes::PI_WEB2 => len_pi_web(value, 2),
            const_codes::PI_WEB3 => len_pi_web(value, 3),
            const_codes::PI_WEB4 => len_pi_web(value, 4),
            const_codes::PI_WEB5 => len_pi_web(value, 5),
            const_codes::PI_WEB6 => len_pi_web(value, 6),
            const_codes::PI_WEB7 => len_pi_web(value, 7),
            const_codes::PI_WEB8 => len_pi_web(value, 8),
            const_codes::PI_WEB9 => len_pi_web(value, 9),
            const_codes::PI_WEB10 => len_pi_web(value, 10),
            const_codes::GOLOMB2 => len_golomb(value, 2),
            const_codes::GOLOMB3 => len_golomb(value, 3),
            const_codes::GOLOMB4 => len_golomb(value, 4),
            const_codes::GOLOMB5 => len_golomb(value, 5),
            const_codes::GOLOMB6 => len_golomb(value, 6),
            const_codes::GOLOMB7 => len_golomb(value, 7),
            const_codes::GOLOMB8 => len_golomb(value, 8),
            const_codes::GOLOMB9 => len_golomb(value, 9),
            const_codes::GOLOMB10 => len_golomb(value, 10),
            const_codes::EXP_GOLOMB2 => len_exp_golomb(value, 2),
            const_codes::EXP_GOLOMB3 => len_exp_golomb(value, 3),
            const_codes::EXP_GOLOMB4 => len_exp_golomb(value, 4),
            const_codes::EXP_GOLOMB5 => len_exp_golomb(value, 5),
            const_codes::EXP_GOLOMB6 => len_exp_golomb(value, 6),
            const_codes::EXP_GOLOMB7 => len_exp_golomb(value, 7),
            const_codes::EXP_GOLOMB8 => len_exp_golomb(value, 8),
            const_codes::EXP_GOLOMB9 => len_exp_golomb(value, 9),
            const_codes::EXP_GOLOMB10 => len_exp_golomb(value, 10),
            const_codes::RICE2 => len_rice(value, 2),
            const_codes::RICE3 => len_rice(value, 3),
            const_codes::RICE4 => len_rice(value, 4),
            const_codes::RICE5 => len_rice(value, 5),
            const_codes::RICE6 => len_rice(value, 6),
            const_codes::RICE7 => len_rice(value, 7),
            const_codes::RICE8 => len_rice(value, 8),
            const_codes::RICE9 => len_rice(value, 9),
            const_codes::RICE10 => len_rice(value, 10),
            _ => panic!("Unknown code: {}", CODE),
        }
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/fuzz/mem_word_reader.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

use crate::prelude::*;
use arbitrary::Arbitrary;

#[derive(Arbitrary, Debug)]
pub struct FuzzCase {
    init: Vec<u64>,
    commands: Vec<RandomCommand>,
}

#[derive(Arbitrary, Debug)]
pub enum RandomCommand {
    GetPosition,
    SetPosition(usize),
    ReadNextWord,
}

pub fn harness(data: FuzzCase) {
    let mut idx = 0;
    let mut reader = MemWordReader::new(&data.init);
    for command in data.commands {
        match command {
            RandomCommand::GetPosition => {
                assert_eq!(reader.word_pos().unwrap(), idx);
            }
            RandomCommand::SetPosition(word_index) => {
                let _ = reader.set_word_pos(word_index as u64);
                idx = word_index as u64;
            }
            RandomCommand::ReadNextWord => {
                if reader.word_pos().unwrap() != u64::MAX {
                    assert_eq!(
                        reader.read_word().ok(),
                        Some(data.init.get(idx as usize).copied().unwrap_or(0))
                    );
                    idx += 1;
                }
            }
        };
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/fuzz/mem_word_reader_strict.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

use crate::prelude::*;
use arbitrary::Arbitrary;

#[derive(Arbitrary, Debug)]
pub struct FuzzCase {
    init: Vec<u64>,
    commands: Vec<RandomCommand>,
}

#[derive(Arbitrary, Debug)]
pub enum RandomCommand {
    GetPosition,
    SetPosition(usize),
    ReadNextWord,
}

pub fn harness(data: FuzzCase) {
    let mut idx = 0;
    let mut reader = MemWordReader::new_strict(&data.init);
    for command in data.commands {
        match command {
            RandomCommand::GetPosition => {
                assert_eq!(reader.word_pos().unwrap(), idx);
            }
            RandomCommand::SetPosition(word_index) => {
                let _ = reader.set_word_pos(word_index as u64);
                if word_index <= data.init.len() {
                    idx = word_index as u64;
                }
            }
            RandomCommand::ReadNextWord => {
                if reader.word_pos().unwrap() < data.init.len() as u64 {
                    assert_eq!(
                        reader.read_word().ok(),
                        Some(data.init.get(idx as usize).copied().unwrap_or(0))
                    );
                    idx += 1;
                }
            }
        };
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/fuzz/mem_word_writer.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

use crate::prelude::*;
use arbitrary::Arbitrary;

#[derive(Arbitrary, Debug)]
pub struct FuzzCase {
    init: Vec<u64>,
    commands: Vec<RandomCommand>,
}

#[derive(Arbitrary, Debug)]
pub enum RandomCommand {
    Len,
    GetPosition,
    SetPosition(usize),
    ReadWord,
    WriteWord(u64),
}

pub fn harness(data: FuzzCase) {
    let mut idx = 0;
    let mut buffer = data.init.clone();
    let mut buffer2 = data.init.clone();

    let mut writer = MemWordWriterSlice::new(&mut buffer2);
    for command in data.commands {
        match command {
            RandomCommand::Len => {
                assert_eq!(writer.len(), buffer.len());
            }
            RandomCommand::GetPosition => {
                assert_eq!(writer.word_pos().unwrap(), idx);
            }
            RandomCommand::SetPosition(word_index) => {
                let _ = writer.set_word_pos(word_index as u64);
                if word_index <= buffer.len() {
                    idx = word_index as u64;
                }
            }
            RandomCommand::ReadWord => {
                assert_eq!(writer.read_word().ok(), buffer.get(idx as usize).copied());
                if buffer.get(idx as usize).is_some() {
                    idx += 1;
                }
            }
            RandomCommand::WriteWord(word) => {
                let can_write = if let Some(w) = buffer.get_mut(idx as usize) {
                    *w = word;
                    true
                } else {
                    false
                };
                assert_eq!(writer.write_word(word).is_ok(), can_write);
                if can_write {
                    idx += 1;
                }
            }
        };
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/fuzz/mem_word_writer_vec.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

use crate::prelude::*;
use arbitrary::Arbitrary;

#[derive(Arbitrary, Debug)]
pub struct FuzzCase {
    commands: Vec<RandomCommand>,
}

#[derive(Arbitrary, Debug)]
pub enum RandomCommand {
    Len,
    GetPosition,
    SetPosition(usize),
    ReadWord,
    WriteWord(u64),
}

pub fn harness(data: FuzzCase) {
    let mut idx = 0;
    let mut buffer = vec![];
    let mut buffer2 = vec![];

    let mut writer = MemWordWriterVec::new(&mut buffer2);
    for command in data.commands {
        match command {
            RandomCommand::Len => {
                assert_eq!(writer.len(), buffer.len());
            }
            RandomCommand::GetPosition => {
                assert_eq!(writer.word_pos().unwrap(), idx);
            }
            RandomCommand::SetPosition(word_index) => {
                let _ = writer.set_word_pos(word_index as u64);
                if word_index <= buffer.len() {
                    idx = word_index as u64;
                }
            }
            RandomCommand::ReadWord => {
                assert_eq!(writer.read_word().ok(), buffer.get(idx as usize).copied());
                if buffer.get(idx as usize).is_some() {
                    idx += 1;
                }
            }
            RandomCommand::WriteWord(word) => {
                if idx >= buffer.len() as u64 {
                    buffer.resize(idx as usize + 1, 0);
                }
                assert!(writer.write_word(word).is_ok());
                buffer[idx as usize] = word;
                idx += 1;
            }
        };
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/fuzz/mod.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

pub mod codes;
pub mod mem_word_reader;
pub mod mem_word_reader_strict;
pub mod mem_word_writer;
pub mod mem_word_writer_vec;

```````

`/home/zom/Github/dsi-bitstream-rs/src/fuzz/codes.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Inria
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

use crate::prelude::*;
use arbitrary::Arbitrary;
use std::io::{Read, Write};

type ReadWord = u32;

const DEBUG: bool = false;

macro_rules! debug {
    ($($arg:tt)*) => {
        if DEBUG {
            print!($($arg)*);
        }
    };
}

macro_rules! debugln {
    ($($arg:tt)*) => {
        if DEBUG {
            println!($($arg)*);
        }
    };
}

#[derive(Arbitrary, Debug, Clone)]
pub struct FuzzCase {
    commands: Vec<RandomCommand>,
}

#[derive(Arbitrary, Debug, Clone)]
enum RandomCommand {
    Bits(u64, usize),
    MinimalBinary(u64, u64),
    Unary(u64),
    Gamma(u64, bool, bool),
    Delta(u64, bool, bool),
    Zeta(u64, u64, bool, bool),
    Golomb(u64, u64),
    Rice(u64, usize),
    ExpGolomb(u64, usize),
    Bytes(Vec<u8>),
    VByte(u64),
    Omega(u64),
    Pi(u64, u64),
    PiWeb(u64, u64),
}

pub fn harness(data: FuzzCase) {
    let mut data = data;
    for command in &mut data.commands {
        match command {
            RandomCommand::Bits(value, n_bits) => {
                *n_bits = 1 + (*n_bits % 63);
                *value &= (1 << *n_bits) - 1;
            }
            RandomCommand::MinimalBinary(value, max) => {
                *max = (*max).max(1).min(u32::MAX as _);
                *value = (*value) % *max;
            }
            RandomCommand::Unary(value) => {
                *value = (*value).min(300);
            }
            RandomCommand::Gamma(value, _, _) => {
                *value = (*value).min(u64::MAX - 1);
            }
            RandomCommand::Delta(value, _, _) => {
                *value = (*value).min(u64::MAX - 1);
            }
            RandomCommand::Zeta(value, k, _, _) => {
                *value = (*value).min(u32::MAX as u64 - 1);
                *k = (*k).max(1).min(7);
            }
            RandomCommand::Golomb(value, b) => {
                *value = (*value).min(u16::MAX as u64 - 1);
                *b = (*b).max(1).min(20);
            }
            RandomCommand::Rice(value, k) => {
                *value = (*value).min(u16::MAX as u64 - 1);
                *k = (*k).max(0).min(8);
            }
            RandomCommand::ExpGolomb(value, k) => {
                *value = (*value).min(u16::MAX as u64 - 1);
                *k = (*k).max(0).min(8);
            }
            RandomCommand::Bytes(_) => {}
            RandomCommand::VByte(_) => {}
            RandomCommand::Omega(value) => {
                *value = (*value).min(u64::MAX - 1);
            }
            RandomCommand::Pi(value, k) => {
                *value = (*value).min(u32::MAX as u64 - 1);
                *k = (*k).max(1).min(7);
            }
            RandomCommand::PiWeb(value, k) => {
                *value = (*value).min(u32::MAX as u64 - 1);
                *k = (*k).max(1).min(7);
            }
        };
    }

    debugln!("{:#4?}", data);

    let mut buffer_be: Vec<u64> = vec![];
    let mut buffer_le: Vec<u64> = vec![];
    let mut writes = vec![];
    // write
    {
        let mut big = BufBitWriter::<BE, _>::new(MemWordWriterVec::new(&mut buffer_be));
        let mut little = BufBitWriter::<LE, _>::new(MemWordWriterVec::new(&mut buffer_le));

        for command in data.commands.iter() {
            match command {
                RandomCommand::Bits(value, n_bits) => {
                    let big_success = big.write_bits(*value, *n_bits).is_ok();
                    let little_success = little.write_bits(*value, *n_bits).is_ok();
                    assert_eq!(big_success, little_success);
                    writes.push(big_success);
                }
                RandomCommand::MinimalBinary(value, max) => {
                    let big_success = big.write_minimal_binary(*value, *max).is_ok();
                    let little_success = little.write_minimal_binary(*value, *max).is_ok();
                    assert_eq!(big_success, little_success);
                    writes.push(big_success);
                }
                RandomCommand::Unary(value) => {
                    let (big_success, little_success) = (
                        big.write_unary(*value as u64).is_ok(),
                        little.write_unary(*value as u64).is_ok(),
                    );
                    assert_eq!(big_success, little_success);
                    writes.push(big_success);
                }
                RandomCommand::Gamma(value, _, write_tab) => {
                    let (big_success, little_success) = if *write_tab {
                        (
                            big.write_gamma_param::<true>(*value).is_ok(),
                            little.write_gamma_param::<true>(*value).is_ok(),
                        )
                    } else {
                        (
                            big.write_gamma_param::<false>(*value).is_ok(),
                            little.write_gamma_param::<false>(*value).is_ok(),
                        )
                    };
                    assert_eq!(big_success, little_success);
                    writes.push(big_success);
                }
                RandomCommand::Delta(value, _, write_tab) => {
                    let (big_success, little_success) = if *write_tab {
                        (
                            big.write_delta_param::<true, false>(*value).is_ok(),
                            little.write_delta_param::<true, false>(*value).is_ok(),
                        )
                    } else {
                        (
                            big.write_delta_param::<false, false>(*value).is_ok(),
                            little.write_delta_param::<false, false>(*value).is_ok(),
                        )
                    };
                    assert_eq!(big_success, little_success);
                    writes.push(big_success);
                }
                RandomCommand::Zeta(value, k, _, write_tab) => {
                    let (big_success, little_success) = if *write_tab {
                        (
                            big.write_zeta_param::<true>(*value, *k).is_ok(),
                            little.write_zeta_param::<true>(*value, *k).is_ok(),
                        )
                    } else {
                        (
                            big.write_zeta_param::<false>(*value, *k).is_ok(),
                            little.write_zeta_param::<false>(*value, *k).is_ok(),
                        )
                    };
                    assert_eq!(big_success, little_success);
                    writes.push(big_success);
                }
                RandomCommand::Golomb(value, b) => {
                    let (big_success, little_success) = (
                        big.write_golomb(*value, *b).is_ok(),
                        little.write_golomb(*value, *b).is_ok(),
                    );
                    assert_eq!(big_success, little_success);
                    writes.push(big_success);
                }
                RandomCommand::Rice(value, k) => {
                    let (big_success, little_success) = (
                        big.write_rice(*value, *k).is_ok(),
                        little.write_rice(*value, *k).is_ok(),
                    );
                    assert_eq!(big_success, little_success);
                    writes.push(big_success);
                }
                RandomCommand::ExpGolomb(value, k) => {
                    let (big_success, little_success) = (
                        big.write_exp_golomb(*value, *k).is_ok(),
                        little.write_exp_golomb(*value, *k).is_ok(),
                    );
                    assert_eq!(big_success, little_success);
                    writes.push(big_success);
                }
                RandomCommand::Bytes(bytes) => {
                    let (big_success, little_success) =
                        (big.write(bytes).is_ok(), little.write(bytes).is_ok());
                    assert_eq!(big_success, little_success);
                    writes.push(big_success);
                }
                RandomCommand::VByte(value) => {
                    let (big_success, little_success) = (
                        big.write_vbyte(*value).is_ok(),
                        little.write_vbyte(*value).is_ok(),
                    );
                    assert_eq!(big_success, little_success);
                    writes.push(big_success);
                }
                RandomCommand::Omega(value) => {
                    let (big_success, little_success) = (
                        big.write_omega(*value).is_ok(),
                        little.write_omega(*value).is_ok(),
                    );
                    assert_eq!(big_success, little_success);
                    writes.push(big_success);
                }
                RandomCommand::Pi(value, k) => {
                    let (big_success, little_success) = (
                        big.write_pi(*value, *k).is_ok(),
                        little.write_pi(*value, *k).is_ok(),
                    );
                    assert_eq!(big_success, little_success);
                    writes.push(big_success);
                }
                RandomCommand::PiWeb(value, k) => {
                    let (big_success, little_success) = (
                        big.write_pi_web(*value, *k).is_ok(),
                        little.write_pi_web(*value, *k).is_ok(),
                    );
                    assert_eq!(big_success, little_success);
                    writes.push(big_success);
                }
            };
        }
    }
    // read back
    debug!("BE: ");
    for word in &buffer_be {
        debug!("{:064b} ", *word);
    }
    debug!("\n");
    debug!("LE: ");
    for word in &buffer_le {
        debug!("{:064b} ", *word);
    }
    debug!("\n");
    let be_trans: &[ReadWord] = unsafe {
        core::slice::from_raw_parts(
            buffer_be.as_ptr() as *const ReadWord,
            buffer_be.len() * (core::mem::size_of::<u64>() / core::mem::size_of::<ReadWord>()),
        )
    };
    let le_trans: &[ReadWord] = unsafe {
        core::slice::from_raw_parts(
            buffer_le.as_ptr() as *const ReadWord,
            buffer_le.len() * (core::mem::size_of::<u64>() / core::mem::size_of::<ReadWord>()),
        )
    };
    {
        let mut big = BitReader::<BE, _>::new(MemWordReader::new(&buffer_be));
        let mut big_buff = BufBitReader::<BE, _>::new(MemWordReader::new(be_trans));

        let mut little = BitReader::<LE, _>::new(MemWordReader::new(&buffer_le));
        let mut little_buff = BufBitReader::<LE, _>::new(MemWordReader::new(le_trans));

        for (succ, command) in writes.into_iter().zip(data.commands.into_iter()) {
            let pos = big.bit_pos().unwrap();
            assert_eq!(pos, little.bit_pos().unwrap());
            assert_eq!(pos, big_buff.bit_pos().unwrap());
            assert_eq!(pos, little_buff.bit_pos().unwrap());

            match command {
                RandomCommand::Bits(value, n_bits) => {
                    let b = big.read_bits(n_bits);
                    let l = little.read_bits(n_bits);
                    let bb = big_buff.read_bits(n_bits);
                    let lb = little_buff.read_bits(n_bits);
                    if succ {
                        let b = b.unwrap();
                        let l = l.unwrap();
                        let bb = bb.unwrap();
                        let lb = lb.unwrap();
                        assert_eq!(
                            b,
                            value,
                            "\nread : {:0n$b}\ntruth: {:0n$b}",
                            b,
                            value,
                            n = n_bits as _
                        );
                        assert_eq!(
                            l,
                            value,
                            "\nread : {:0n$b}\ntruth: {:0n$b}",
                            l,
                            value,
                            n = n_bits as _
                        );
                        assert_eq!(
                            bb,
                            value,
                            "\nread : {:0n$b}\ntruth: {:0n$b}",
                            bb,
                            value,
                            n = n_bits as _
                        );
                        assert_eq!(
                            lb,
                            value,
                            "\nread : {:0n$b}\ntruth: {:0n$b}",
                            lb,
                            value,
                            n = n_bits as _
                        );
                        assert_eq!(pos + n_bits as u64, big.bit_pos().unwrap());
                        assert_eq!(pos + n_bits as u64, little.bit_pos().unwrap());
                        assert_eq!(pos + n_bits as u64, big_buff.bit_pos().unwrap());
                        assert_eq!(pos + n_bits as u64, little_buff.bit_pos().unwrap());
                    } else {
                        assert!(b.is_err());
                        assert!(l.is_err());
                        assert!(bb.is_err());
                        assert!(lb.is_err());
                        assert_eq!(pos, big.bit_pos().unwrap());
                        assert_eq!(pos, little.bit_pos().unwrap());
                        assert_eq!(pos, big_buff.bit_pos().unwrap());
                        assert_eq!(pos, little_buff.bit_pos().unwrap());
                    }
                }

                RandomCommand::MinimalBinary(value, max) => {
                    let n_bits = len_minimal_binary(value, max) as u8;
                    let b = big.read_minimal_binary(max);
                    let l = little.read_minimal_binary(max);
                    let bb = big_buff.read_minimal_binary(max);
                    let lb = little_buff.read_minimal_binary(max);
                    if succ {
                        let b = b.unwrap();
                        let l = l.unwrap();
                        let bb = bb.unwrap();
                        let lb = lb.unwrap();
                        assert_eq!(
                            b,
                            value,
                            "\nread : {:0n$b}\ntruth: {:0n$b}",
                            b,
                            value,
                            n = n_bits as _
                        );
                        assert_eq!(
                            l,
                            value,
                            "\nread : {:0n$b}\ntruth: {:0n$b}",
                            l,
                            value,
                            n = n_bits as _
                        );
                        assert_eq!(
                            bb,
                            value,
                            "\nread : {:0n$b}\ntruth: {:0n$b}",
                            bb,
                            value,
                            n = n_bits as _
                        );
                        assert_eq!(
                            lb,
                            value,
                            "\nread : {:0n$b}\ntruth: {:0n$b}",
                            lb,
                            value,
                            n = n_bits as _
                        );
                        assert_eq!(pos + n_bits as u64, big.bit_pos().unwrap());
                        assert_eq!(pos + n_bits as u64, little.bit_pos().unwrap());
                        assert_eq!(pos + n_bits as u64, big_buff.bit_pos().unwrap());
                        assert_eq!(pos + n_bits as u64, little_buff.bit_pos().unwrap());
                    } else {
                        assert!(b.is_err());
                        assert!(l.is_err());
                        assert!(bb.is_err());
                        assert!(lb.is_err());
                        assert_eq!(pos, big.bit_pos().unwrap());
                        assert_eq!(pos, little.bit_pos().unwrap());
                        assert_eq!(pos, big_buff.bit_pos().unwrap());
                        assert_eq!(pos, little_buff.bit_pos().unwrap());
                    }
                }

                RandomCommand::Unary(value) => {
                    let (b, l, bb, lb) = (
                        big.read_unary(),
                        little.read_unary(),
                        big_buff.read_unary(),
                        little_buff.read_unary(),
                    );
                    if succ {
                        assert_eq!(b.unwrap(), value as u64);
                        assert_eq!(l.unwrap(), value as u64);
                        assert_eq!(bb.unwrap(), value as u64);
                        assert_eq!(lb.unwrap(), value as u64);
                        assert_eq!(pos + value as u64 + 1, big.bit_pos().unwrap());
                        assert_eq!(pos + value as u64 + 1, little.bit_pos().unwrap());
                        assert_eq!(pos + value as u64 + 1, big_buff.bit_pos().unwrap());
                        assert_eq!(pos + value as u64 + 1, little_buff.bit_pos().unwrap());

                        assert_eq!(pos + value as u64 + 1, big.bit_pos().unwrap());
                        assert_eq!(pos + value as u64 + 1, little.bit_pos().unwrap());
                        assert_eq!(pos + value as u64 + 1, big_buff.bit_pos().unwrap());
                        assert_eq!(pos + value as u64 + 1, little_buff.bit_pos().unwrap());
                    } else {
                        assert!(b.is_err());
                        assert!(l.is_err());
                        assert!(bb.is_err());
                        assert!(lb.is_err());
                        assert_eq!(pos, big.bit_pos().unwrap());
                        assert_eq!(pos, little.bit_pos().unwrap());
                        assert_eq!(pos, big_buff.bit_pos().unwrap());
                        assert_eq!(pos, little_buff.bit_pos().unwrap());
                    }
                }

                RandomCommand::Gamma(value, read_tab, _) => {
                    let (b, l, bb, lb) = if read_tab {
                        (
                            big.read_gamma_param::<true>(),
                            little.read_gamma_param::<true>(),
                            big_buff.read_gamma_param::<true>(),
                            little_buff.read_gamma_param::<true>(),
                        )
                    } else {
                        (
                            big.read_gamma_param::<false>(),
                            little.read_gamma_param::<false>(),
                            big_buff.read_gamma_param::<false>(),
                            little_buff.read_gamma_param::<false>(),
                        )
                    };
                    if succ {
                        assert_eq!(b.unwrap(), value);
                        assert_eq!(l.unwrap(), value);
                        assert_eq!(bb.unwrap(), value);
                        assert_eq!(lb.unwrap(), value);
                        assert_eq!(
                            pos + len_gamma_param::<false>(value) as u64,
                            big.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_gamma_param::<false>(value) as u64,
                            little.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_gamma_param::<false>(value) as u64,
                            big_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_gamma_param::<false>(value) as u64,
                            little_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_gamma_param::<true>(value) as u64,
                            big.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_gamma_param::<true>(value) as u64,
                            little.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_gamma_param::<true>(value) as u64,
                            big_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_gamma_param::<true>(value) as u64,
                            little_buff.bit_pos().unwrap()
                        );
                    } else {
                        assert!(b.is_err());
                        assert!(l.is_err());
                        assert!(bb.is_err());
                        assert!(lb.is_err());
                        assert_eq!(pos, big.bit_pos().unwrap());
                        assert_eq!(pos, little.bit_pos().unwrap());
                        assert_eq!(pos, big_buff.bit_pos().unwrap());
                        assert_eq!(pos, little_buff.bit_pos().unwrap());
                    }
                }

                RandomCommand::Delta(value, read_tab, _) => {
                    let (b, l, bb, lb) = if read_tab {
                        (
                            big.read_delta_param::<true, false>(),
                            little.read_delta_param::<true, false>(),
                            big_buff.read_delta_param::<true, false>(),
                            little_buff.read_delta_param::<true, false>(),
                        )
                    } else {
                        (
                            big.read_delta_param::<false, false>(),
                            little.read_delta_param::<false, false>(),
                            big_buff.read_delta_param::<false, false>(),
                            little_buff.read_delta_param::<false, false>(),
                        )
                    };
                    if succ {
                        assert_eq!(b.unwrap(), value);
                        assert_eq!(l.unwrap(), value);
                        assert_eq!(bb.unwrap(), value);
                        assert_eq!(lb.unwrap(), value);
                        assert_eq!(
                            pos + len_delta_param::<true, true>(value) as u64,
                            big.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_delta_param::<true, true>(value) as u64,
                            little.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_delta_param::<true, true>(value) as u64,
                            big_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_delta_param::<true, true>(value) as u64,
                            little_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_delta_param::<false, true>(value) as u64,
                            big.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_delta_param::<false, true>(value) as u64,
                            little.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_delta_param::<false, true>(value) as u64,
                            big_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_delta_param::<false, true>(value) as u64,
                            little_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_delta_param::<true, false>(value) as u64,
                            big.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_delta_param::<true, false>(value) as u64,
                            little.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_delta_param::<true, false>(value) as u64,
                            big_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_delta_param::<true, false>(value) as u64,
                            little_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_delta_param::<false, false>(value) as u64,
                            big.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_delta_param::<false, false>(value) as u64,
                            little.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_delta_param::<false, false>(value) as u64,
                            big_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_delta_param::<false, false>(value) as u64,
                            little_buff.bit_pos().unwrap()
                        );
                    } else {
                        assert!(b.is_err());
                        assert!(l.is_err());
                        assert!(bb.is_err());
                        assert!(lb.is_err());
                        assert_eq!(pos, big.bit_pos().unwrap());
                        assert_eq!(pos, little.bit_pos().unwrap());
                        assert_eq!(pos, big_buff.bit_pos().unwrap());
                        assert_eq!(pos, little_buff.bit_pos().unwrap());
                    }
                }

                RandomCommand::Zeta(value, k, read_tab, _) => {
                    let (b, l, bb, lb) = if k == 3 {
                        if read_tab {
                            (
                                big.read_zeta3_param::<true>(),
                                little.read_zeta3_param::<true>(),
                                big_buff.read_zeta3_param::<true>(),
                                little_buff.read_zeta3_param::<true>(),
                            )
                        } else {
                            (
                                big.read_zeta3_param::<false>(),
                                little.read_zeta3_param::<false>(),
                                big_buff.read_zeta3_param::<false>(),
                                little_buff.read_zeta3_param::<false>(),
                            )
                        }
                    } else {
                        (
                            big.read_zeta_param(k),
                            little.read_zeta_param(k),
                            big_buff.read_zeta_param(k),
                            little_buff.read_zeta_param(k),
                        )
                    };
                    if succ {
                        assert_eq!(bb.unwrap(), value);
                        assert_eq!(lb.unwrap(), value);
                        assert_eq!(b.unwrap(), value);
                        assert_eq!(l.unwrap(), value);
                        assert_eq!(
                            pos + len_zeta_param::<false>(value, k) as u64,
                            big.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_zeta_param::<false>(value, k) as u64,
                            little.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_zeta_param::<false>(value, k) as u64,
                            big_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_zeta_param::<false>(value, k) as u64,
                            little_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_zeta_param::<true>(value, k) as u64,
                            big.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_zeta_param::<true>(value, k) as u64,
                            little.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_zeta_param::<true>(value, k) as u64,
                            big_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_zeta_param::<true>(value, k) as u64,
                            little_buff.bit_pos().unwrap()
                        );
                    } else {
                        assert!(b.is_err());
                        assert!(l.is_err());
                        assert!(bb.is_err());
                        assert!(lb.is_err());
                        assert_eq!(pos, big.bit_pos().unwrap());
                        assert_eq!(pos, little.bit_pos().unwrap());
                        assert_eq!(pos, big_buff.bit_pos().unwrap());
                        assert_eq!(pos, little_buff.bit_pos().unwrap());
                    }
                }
                RandomCommand::Golomb(value, b_par) => {
                    let (b, l, bb, lb) = (
                        big.read_golomb(b_par),
                        little.read_golomb(b_par),
                        big_buff.read_golomb(b_par),
                        little_buff.read_golomb(b_par),
                    );
                    if succ {
                        assert_eq!(b.unwrap(), value as u64);
                        assert_eq!(l.unwrap(), value as u64);
                        assert_eq!(bb.unwrap(), value as u64);
                        assert_eq!(lb.unwrap(), value as u64);
                        assert_eq!(
                            pos + len_golomb(value, b_par) as u64,
                            big.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_golomb(value, b_par) as u64,
                            little.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_golomb(value, b_par) as u64,
                            big_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_golomb(value, b_par) as u64,
                            little_buff.bit_pos().unwrap()
                        );

                        assert_eq!(
                            pos + len_golomb(value, b_par) as u64,
                            big.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_golomb(value, b_par) as u64,
                            little.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_golomb(value, b_par) as u64,
                            big_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_golomb(value, b_par) as u64,
                            little_buff.bit_pos().unwrap()
                        );
                    } else {
                        assert!(b.is_err());
                        assert!(l.is_err());
                        assert!(bb.is_err());
                        assert!(lb.is_err());
                        assert_eq!(pos, big.bit_pos().unwrap());
                        assert_eq!(pos, little.bit_pos().unwrap());
                        assert_eq!(pos, big_buff.bit_pos().unwrap());
                        assert_eq!(pos, little_buff.bit_pos().unwrap());
                    }
                }
                RandomCommand::Rice(value, k) => {
                    let (b, l, bb, lb) = (
                        big.read_rice(k),
                        little.read_rice(k),
                        big_buff.read_rice(k),
                        little_buff.read_rice(k),
                    );
                    if succ {
                        assert_eq!(b.unwrap(), value as u64);
                        assert_eq!(l.unwrap(), value as u64);
                        assert_eq!(bb.unwrap(), value as u64);
                        assert_eq!(lb.unwrap(), value as u64);
                        assert_eq!(pos + len_rice(value, k) as u64, big.bit_pos().unwrap());
                        assert_eq!(pos + len_rice(value, k) as u64, little.bit_pos().unwrap());
                        assert_eq!(pos + len_rice(value, k) as u64, big_buff.bit_pos().unwrap());
                        assert_eq!(
                            pos + len_rice(value, k) as u64,
                            little_buff.bit_pos().unwrap()
                        );

                        assert_eq!(pos + len_rice(value, k) as u64, big.bit_pos().unwrap());
                        assert_eq!(pos + len_rice(value, k) as u64, little.bit_pos().unwrap());
                        assert_eq!(pos + len_rice(value, k) as u64, big_buff.bit_pos().unwrap());
                        assert_eq!(
                            pos + len_rice(value, k) as u64,
                            little_buff.bit_pos().unwrap()
                        );
                    } else {
                        assert!(b.is_err());
                        assert!(l.is_err());
                        assert!(bb.is_err());
                        assert!(lb.is_err());
                        assert_eq!(pos, big.bit_pos().unwrap());
                        assert_eq!(pos, little.bit_pos().unwrap());
                        assert_eq!(pos, big_buff.bit_pos().unwrap());
                        assert_eq!(pos, little_buff.bit_pos().unwrap());
                    }
                }
                RandomCommand::ExpGolomb(value, k) => {
                    let (b, l, bb, lb) = (
                        big.read_exp_golomb(k),
                        little.read_exp_golomb(k),
                        big_buff.read_exp_golomb(k),
                        little_buff.read_exp_golomb(k),
                    );
                    if succ {
                        assert_eq!(b.unwrap(), value as u64);
                        assert_eq!(l.unwrap(), value as u64);
                        assert_eq!(bb.unwrap(), value as u64);
                        assert_eq!(lb.unwrap(), value as u64);
                        assert_eq!(
                            pos + len_exp_golomb(value, k) as u64,
                            big.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_exp_golomb(value, k) as u64,
                            little.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_exp_golomb(value, k) as u64,
                            big_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_exp_golomb(value, k) as u64,
                            little_buff.bit_pos().unwrap()
                        );

                        assert_eq!(
                            pos + len_exp_golomb(value, k) as u64,
                            big.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_exp_golomb(value, k) as u64,
                            little.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_exp_golomb(value, k) as u64,
                            big_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_exp_golomb(value, k) as u64,
                            little_buff.bit_pos().unwrap()
                        );
                    } else {
                        assert!(b.is_err());
                        assert!(l.is_err());
                        assert!(bb.is_err());
                        assert!(lb.is_err());
                        assert_eq!(pos, big.bit_pos().unwrap());
                        assert_eq!(pos, little.bit_pos().unwrap());
                        assert_eq!(pos, big_buff.bit_pos().unwrap());
                        assert_eq!(pos, little_buff.bit_pos().unwrap());
                    }
                }
                RandomCommand::VByte(value) => {
                    let (b, l, bb, lb) = (
                        big.read_vbyte(),
                        little.read_vbyte(),
                        big_buff.read_vbyte(),
                        little_buff.read_vbyte(),
                    );
                    if succ {
                        assert_eq!(b.unwrap(), value as u64, "b");
                        assert_eq!(l.unwrap(), value as u64, "l");
                        assert_eq!(bb.unwrap(), value as u64, "bb");
                        assert_eq!(lb.unwrap(), value as u64, "lb");
                        assert_eq!(pos + len_vbyte(value) as u64, big.bit_pos().unwrap());
                        assert_eq!(pos + len_vbyte(value) as u64, little.bit_pos().unwrap());
                        assert_eq!(pos + len_vbyte(value) as u64, big_buff.bit_pos().unwrap());
                        assert_eq!(
                            pos + len_vbyte(value) as u64,
                            little_buff.bit_pos().unwrap()
                        );

                        assert_eq!(pos + len_vbyte(value) as u64, big.bit_pos().unwrap());
                        assert_eq!(pos + len_vbyte(value) as u64, little.bit_pos().unwrap());
                        assert_eq!(pos + len_vbyte(value) as u64, big_buff.bit_pos().unwrap());
                        assert_eq!(
                            pos + len_vbyte(value) as u64,
                            little_buff.bit_pos().unwrap()
                        );
                    } else {
                        assert!(b.is_err());
                        assert!(l.is_err());
                        assert!(bb.is_err());
                        assert!(lb.is_err());
                        assert_eq!(pos, big.bit_pos().unwrap());
                        assert_eq!(pos, little.bit_pos().unwrap());
                        assert_eq!(pos, big_buff.bit_pos().unwrap());
                        assert_eq!(pos, little_buff.bit_pos().unwrap());
                    }
                }
                RandomCommand::Bytes(bytes) => {
                    let mut b_buffer = vec![0; bytes.len()];
                    let b = big.read_exact(&mut b_buffer);
                    let mut l_buffer = vec![0; bytes.len()];
                    let l = little.read_exact(&mut l_buffer);
                    let mut bb_buffer = vec![0; bytes.len()];
                    let bb = big_buff.read_exact(&mut bb_buffer);
                    let mut lb_buffer = vec![0; bytes.len()];
                    let lb = little_buff.read_exact(&mut lb_buffer);

                    if succ {
                        assert_eq!(&b_buffer, &bytes);
                        assert_eq!(&l_buffer, &bytes);
                        assert_eq!(&bb_buffer, &bytes);
                        assert_eq!(&lb_buffer, &bytes);
                        assert_eq!(pos + bytes.len() as u64 * 8, big.bit_pos().unwrap());
                        assert_eq!(pos + bytes.len() as u64 * 8, little.bit_pos().unwrap());
                        assert_eq!(pos + bytes.len() as u64 * 8, big_buff.bit_pos().unwrap());
                        assert_eq!(pos + bytes.len() as u64 * 8, little_buff.bit_pos().unwrap());

                        assert_eq!(pos + bytes.len() as u64 * 8, big.bit_pos().unwrap());
                        assert_eq!(pos + bytes.len() as u64 * 8, little.bit_pos().unwrap());
                        assert_eq!(pos + bytes.len() as u64 * 8, big_buff.bit_pos().unwrap());
                        assert_eq!(pos + bytes.len() as u64 * 8, little_buff.bit_pos().unwrap());
                    } else {
                        assert!(b.is_err());
                        assert!(l.is_err());
                        assert!(bb.is_err());
                        assert!(lb.is_err());
                        assert_eq!(pos, big.bit_pos().unwrap());
                        assert_eq!(pos, little.bit_pos().unwrap());
                        assert_eq!(pos, big_buff.bit_pos().unwrap());
                        assert_eq!(pos, little_buff.bit_pos().unwrap());
                    }
                }
                RandomCommand::Omega(value) => {
                    let (b, l, bb, lb) = (
                        big.read_omega(),
                        little.read_omega(),
                        big_buff.read_omega(),
                        little_buff.read_omega(),
                    );
                    if succ {
                        assert_eq!(b.unwrap(), value as u64, "b");
                        assert_eq!(l.unwrap(), value as u64, "l");
                        assert_eq!(bb.unwrap(), value as u64, "bb");
                        assert_eq!(lb.unwrap(), value as u64, "lb");
                        assert_eq!(pos + len_omega(value) as u64, big.bit_pos().unwrap());
                        assert_eq!(pos + len_omega(value) as u64, little.bit_pos().unwrap());
                        assert_eq!(pos + len_omega(value) as u64, big_buff.bit_pos().unwrap());
                        assert_eq!(
                            pos + len_omega(value) as u64,
                            little_buff.bit_pos().unwrap()
                        );

                        assert_eq!(pos + len_omega(value) as u64, big.bit_pos().unwrap());
                        assert_eq!(pos + len_omega(value) as u64, little.bit_pos().unwrap());
                        assert_eq!(pos + len_omega(value) as u64, big_buff.bit_pos().unwrap());
                        assert_eq!(
                            pos + len_omega(value) as u64,
                            little_buff.bit_pos().unwrap()
                        );
                    } else {
                        assert!(b.is_err());
                        assert!(l.is_err());
                        assert!(bb.is_err());
                        assert!(lb.is_err());
                        assert_eq!(pos, big.bit_pos().unwrap());
                        assert_eq!(pos, little.bit_pos().unwrap());
                        assert_eq!(pos, big_buff.bit_pos().unwrap());
                        assert_eq!(pos, little_buff.bit_pos().unwrap());
                    }
                }
                RandomCommand::Pi(value, k) => {
                    let (b, l, bb, lb) = (
                        big.read_pi(k),
                        little.read_pi(k),
                        big_buff.read_pi(k),
                        little_buff.read_pi(k),
                    );
                    if succ {
                        assert_eq!(b.unwrap(), value as u64);
                        assert_eq!(l.unwrap(), value as u64);
                        assert_eq!(bb.unwrap(), value as u64);
                        assert_eq!(lb.unwrap(), value as u64);
                        assert_eq!(pos + len_pi(value, k) as u64, big.bit_pos().unwrap());
                        assert_eq!(pos + len_pi(value, k) as u64, little.bit_pos().unwrap());
                        assert_eq!(pos + len_pi(value, k) as u64, big_buff.bit_pos().unwrap());
                        assert_eq!(
                            pos + len_pi(value, k) as u64,
                            little_buff.bit_pos().unwrap()
                        );

                        assert_eq!(pos + len_pi(value, k) as u64, big.bit_pos().unwrap());
                        assert_eq!(pos + len_pi(value, k) as u64, little.bit_pos().unwrap());
                        assert_eq!(pos + len_pi(value, k) as u64, big_buff.bit_pos().unwrap());
                        assert_eq!(
                            pos + len_pi(value, k) as u64,
                            little_buff.bit_pos().unwrap()
                        );
                    } else {
                        assert!(b.is_err());
                        assert!(l.is_err());
                        assert!(bb.is_err());
                        assert!(lb.is_err());
                        assert_eq!(pos, big.bit_pos().unwrap());
                        assert_eq!(pos, little.bit_pos().unwrap());
                        assert_eq!(pos, big_buff.bit_pos().unwrap());
                        assert_eq!(pos, little_buff.bit_pos().unwrap());
                    }
                }
                RandomCommand::PiWeb(value, k) => {
                    let (b, l, bb, lb) = (
                        big.read_pi_web(k),
                        little.read_pi_web(k),
                        big_buff.read_pi_web(k),
                        little_buff.read_pi_web(k),
                    );
                    if succ {
                        assert_eq!(b.unwrap(), value as u64);
                        assert_eq!(l.unwrap(), value as u64);
                        assert_eq!(bb.unwrap(), value as u64);
                        assert_eq!(lb.unwrap(), value as u64);
                        assert_eq!(pos + len_pi_web(value, k) as u64, big.bit_pos().unwrap());
                        assert_eq!(pos + len_pi_web(value, k) as u64, little.bit_pos().unwrap());
                        assert_eq!(
                            pos + len_pi_web(value, k) as u64,
                            big_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_pi_web(value, k) as u64,
                            little_buff.bit_pos().unwrap()
                        );

                        assert_eq!(pos + len_pi_web(value, k) as u64, big.bit_pos().unwrap());
                        assert_eq!(pos + len_pi_web(value, k) as u64, little.bit_pos().unwrap());
                        assert_eq!(
                            pos + len_pi_web(value, k) as u64,
                            big_buff.bit_pos().unwrap()
                        );
                        assert_eq!(
                            pos + len_pi_web(value, k) as u64,
                            little_buff.bit_pos().unwrap()
                        );
                    } else {
                        assert!(b.is_err());
                        assert!(l.is_err());
                        assert!(bb.is_err());
                        assert!(lb.is_err());
                        assert_eq!(pos, big.bit_pos().unwrap());
                        assert_eq!(pos, little.bit_pos().unwrap());
                        assert_eq!(pos, big_buff.bit_pos().unwrap());
                        assert_eq!(pos, little_buff.bit_pos().unwrap());
                    }
                }
            };
        }
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/impls/mem_word_reader.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

use crate::prelude::*;
use core::convert::Infallible;
#[cfg(feature = "mem_dbg")]
use mem_dbg::{MemDbg, MemSize};

/**

An implementation of [`WordRead`] and [`WordSeek`] for a slice.

The implementation depends on the `INF` parameter: if true, the reader will
behave as if the slice is infinitely extended with zeros.
If false, the reader will return an error when reading
beyond the end of the slice. You can create a zero-extended
reader with [`MemWordReader::new`] and a strict reader with
[`MemWordReader::new_strict`].

The zero-extended reader is usually much faster than the strict reader, but
it might loop infinitely when reading beyond the end of the slice.

# Examples

```rust
# fn main() -> Result<(), Box<dyn std::error::Error>> {
use dsi_bitstream::prelude::*;

let words: [u32; 2] = [1, 2];

let mut word_reader = MemWordReader::new(&words);
assert_eq!(1, word_reader.read_word()?);
assert_eq!(2, word_reader.read_word()?);
assert_eq!(0, word_reader.read_word()?);
assert_eq!(0, word_reader.read_word()?);

let mut word_reader = MemWordReader::new_strict(&words);
assert_eq!(1, word_reader.read_word()?);
assert_eq!(2, word_reader.read_word()?);
assert!(word_reader.read_word().is_err());
# Ok(())
# }
```
*/
#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct MemWordReader<W: Word, B: AsRef<[W]>, const INF: bool = true> {
    data: B,
    word_index: usize,
    _marker: core::marker::PhantomData<W>,
}

impl<W: Word, B: AsRef<[W]>> MemWordReader<W, B> {
    /// Create a new [`MemWordReader`] from a slice of data
    #[must_use]
    pub fn new(data: B) -> Self {
        Self {
            data,
            word_index: 0,
            _marker: Default::default(),
        }
    }

    pub fn into_inner(self) -> B {
        self.data
    }
}

impl<W: Word, B: AsRef<[W]>> MemWordReader<W, B, false> {
    /// Create a new [`MemWordReader`] from a slice of data
    #[must_use]
    pub fn new_strict(data: B) -> Self {
        Self {
            data,
            word_index: 0,
            _marker: Default::default(),
        }
    }
}

impl<W: Word, B: AsRef<[W]>> WordRead for MemWordReader<W, B, true> {
    type Error = Infallible;
    type Word = W;

    #[inline(always)]
    fn read_word(&mut self) -> Result<W, Infallible> {
        let res = self
            .data
            .as_ref()
            .get(self.word_index)
            .copied()
            .unwrap_or(Self::Word::ZERO);

        self.word_index += 1;
        Ok(res)
    }
}

impl<W: Word, B: AsRef<[W]>> WordRead for MemWordReader<W, B, false> {
    type Error = std::io::Error;
    type Word = W;

    #[inline(always)]
    fn read_word(&mut self) -> Result<W, std::io::Error> {
        let res = self
            .data
            .as_ref()
            .get(self.word_index)
            .ok_or(std::io::Error::new(
                std::io::ErrorKind::UnexpectedEof,
                "Unexpected end of slice",
            ))?;

        self.word_index += 1;
        Ok(*res)
    }
}

impl<W: Word, B: AsRef<[W]>> WordSeek for MemWordReader<W, B, true> {
    type Error = Infallible;

    #[inline(always)]
    fn word_pos(&mut self) -> Result<u64, Infallible> {
        Ok(self.word_index as u64)
    }

    #[inline(always)]
    fn set_word_pos(&mut self, word_index: u64) -> Result<(), Infallible> {
        // This is dirty but it's infallible
        self.word_index = word_index.min(usize::MAX as u64) as usize;
        Ok(())
    }
}

impl<W: Word, B: AsRef<[W]>> WordSeek for MemWordReader<W, B, false> {
    type Error = std::io::Error;

    #[inline(always)]
    fn word_pos(&mut self) -> Result<u64, std::io::Error> {
        Ok(self.word_index as u64)
    }
    #[inline(always)]
    fn set_word_pos(&mut self, word_index: u64) -> Result<(), std::io::Error> {
        return if word_index > self.data.as_ref().len() as u64 {
            Err(std::io::Error::new(
                std::io::ErrorKind::UnexpectedEof,
                format_args!(
                    "Position beyond end of slice: {} > {}",
                    word_index,
                    self.data.as_ref().len()
                )
                .to_string(),
            ))
        } else {
            self.word_index = word_index as usize;
            Ok(())
        };
    }
}

#[test]

fn test_eof_table_read() {
    use crate::codes::{DeltaReadParam, DeltaWrite};
    let mut words: [u64; 1] = [0];
    let mut writer = crate::prelude::BufBitWriter::<crate::prelude::LE, _>::new(
        MemWordWriterSlice::new(&mut words),
    );
    for _ in 0..16 {
        writer.write_delta(1).unwrap();
    }
    writer.flush().unwrap();
    drop(writer);

    let mut reader =
        crate::prelude::BufBitReader::<crate::prelude::LE, _>::new(MemWordReader::new(&words));
    for _ in 0..16 {
        // Here the last table read make peek_bits return Ok(None)
        assert_eq!(1, reader.read_delta_param::<true, true>().unwrap());
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/impls/mem_word_writer.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

use core::convert::Infallible;
#[cfg(feature = "mem_dbg")]
use mem_dbg::{MemDbg, MemSize};

use crate::traits::*;

/// An implementation of [`WordRead`], [`WordWrite`], and [`WordSeek`] for a
/// mutable slice.
///
/// Writing beyond the end of the slice will return an error.
///
/// # Example
/// ```
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// use dsi_bitstream::prelude::*;
///
/// let mut words: [u64; 2] = [
///     0x0043b59fcdf16077,
///     0x702863e6f9739b86,
/// ];
///
/// let mut word_writer = MemWordWriterSlice::new(&mut words);
///
/// // the stream is read sequentially
/// assert_eq!(word_writer.word_pos()?, 0);
/// assert_eq!(word_writer.read_word()?, 0x0043b59fcdf16077);
/// assert_eq!(word_writer.word_pos()?, 1);
/// assert_eq!(word_writer.read_word()?, 0x702863e6f9739b86);
/// assert_eq!(word_writer.word_pos()?, 2);
/// assert!(word_writer.read_word().is_err());
///
/// // you can change position
/// assert!(word_writer.set_word_pos(1).is_ok());
/// assert_eq!(word_writer.word_pos()?, 1);
/// assert_eq!(word_writer.read_word()?, 0x702863e6f9739b86);
///
/// // errored set position doesn't change the current position
/// assert_eq!(word_writer.word_pos()?, 2);
/// assert!(word_writer.set_word_pos(100).is_err());
/// assert_eq!(word_writer.word_pos()?, 2);
///
/// // we can write and read back!
/// assert!(word_writer.set_word_pos(0).is_ok());
/// assert!(word_writer.write_word(0x0b801b2bf696e8d2).is_ok());
/// assert_eq!(word_writer.word_pos()?, 1);
/// assert!(word_writer.set_word_pos(0).is_ok());
/// assert_eq!(word_writer.read_word()?, 0x0b801b2bf696e8d2);
/// assert_eq!(word_writer.word_pos()?, 1);
/// # Ok(())
/// # }
/// ```
#[derive(Debug, PartialEq)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct MemWordWriterSlice<W: Word, B: AsMut<[W]>> {
    data: B,
    word_index: usize,
    _marker: core::marker::PhantomData<W>,
}

impl<W: Word, B: AsMut<[W]> + AsRef<[W]>> MemWordWriterSlice<W, B> {
    /// Create a new [`MemWordWriterSlice`] from a slice of **ZERO INITIALIZED** data
    #[must_use]
    pub fn new(data: B) -> Self {
        Self {
            data,
            word_index: 0,
            _marker: Default::default(),
        }
    }

    pub fn len(&self) -> usize {
        self.data.as_ref().len()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn into_inner(self) -> B {
        self.data
    }
}

/// An implementation of [`WordRead`], [`WordWrite`], and [`WordSeek`]
/// for a mutable vector.
///
/// The vector will be extended as new data is written.
///
/// # Example
/// ```
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// use dsi_bitstream::prelude::*;
///
/// let mut words: Vec<u64> = vec![
///     0x0043b59fcdf16077,
/// ];
///
/// let mut word_writer = MemWordWriterVec::new(&mut words);
///
/// // the stream is read sequentially
/// assert_eq!(word_writer.word_pos()?, 0);
/// assert!(word_writer.write_word(0).is_ok());
/// assert_eq!(word_writer.word_pos()?, 1);
/// assert!(word_writer.write_word(1).is_ok());
/// assert_eq!(word_writer.word_pos()?, 2);
/// # Ok(())
/// # }
/// ```
#[derive(Debug, PartialEq)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
#[cfg(feature = "alloc")]
pub struct MemWordWriterVec<W: Word, B: AsMut<alloc::vec::Vec<W>>> {
    data: B,
    word_index: usize,
    _marker: core::marker::PhantomData<W>,
}

#[cfg(feature = "alloc")]
impl<W: Word, B: AsMut<alloc::vec::Vec<W>> + AsRef<alloc::vec::Vec<W>>> MemWordWriterVec<W, B> {
    /// Create a new [`MemWordWriterSlice`] from a slice of **ZERO INITIALIZED** data
    #[must_use]
    pub fn new(data: B) -> Self {
        Self {
            data,
            word_index: 0,
            _marker: Default::default(),
        }
    }

    pub fn len(&self) -> usize {
        self.data.as_ref().len()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    pub fn into_inner(self) -> B {
        self.data
    }
}

impl<W: Word, B: AsMut<[W]>> WordRead for MemWordWriterSlice<W, B> {
    type Error = std::io::Error;
    type Word = W;

    #[inline]
    fn read_word(&mut self) -> Result<W, std::io::Error> {
        match self.data.as_mut().get(self.word_index) {
            Some(word) => {
                self.word_index += 1;
                Ok(*word)
            }
            None => Err(std::io::Error::new(
                std::io::ErrorKind::UnexpectedEof,
                "Cannot read next word as the underlying memory ended",
            )),
        }
    }
}

impl<W: Word, B: AsRef<[W]> + AsMut<[W]>> WordSeek for MemWordWriterSlice<W, B> {
    type Error = std::io::Error;

    #[inline(always)]
    fn word_pos(&mut self) -> Result<u64, std::io::Error> {
        Ok(self.word_index as u64)
    }

    #[inline(always)]
    fn set_word_pos(&mut self, word_index: u64) -> Result<(), std::io::Error> {
        return if word_index > self.data.as_ref().len() as u64 {
            Err(std::io::Error::new(
                std::io::ErrorKind::UnexpectedEof,
                format_args!(
                    "Position beyond end of vector: {} > {}",
                    word_index,
                    self.data.as_ref().len()
                )
                .to_string(),
            ))
        } else {
            self.word_index = word_index as usize;
            Ok(())
        };
    }
}

impl<W: Word, B: AsMut<[W]>> WordWrite for MemWordWriterSlice<W, B> {
    type Error = std::io::Error;
    type Word = W;

    #[inline]
    fn write_word(&mut self, word: W) -> Result<(), std::io::Error> {
        match self.data.as_mut().get_mut(self.word_index) {
            Some(word_ref) => {
                self.word_index += 1;
                *word_ref = word;
                Ok(())
            }
            None => Err(std::io::Error::new(
                std::io::ErrorKind::UnexpectedEof,
                "Cannot write next word as the underlying memory ended",
            )),
        }
    }

    fn flush(&mut self) -> Result<(), Self::Error> {
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl<W: Word, B: AsMut<alloc::vec::Vec<W>>> WordWrite for MemWordWriterVec<W, B> {
    type Error = Infallible;
    type Word = W;

    #[inline]
    fn write_word(&mut self, word: W) -> Result<(), Infallible> {
        if self.word_index >= self.data.as_mut().len() {
            self.data.as_mut().resize(self.word_index + 1, W::ZERO);
        }
        self.data.as_mut()[self.word_index] = word;
        self.word_index += 1;
        Ok(())
    }

    fn flush(&mut self) -> Result<(), Self::Error> {
        Ok(())
    }
}

#[cfg(feature = "alloc")]
impl<W: Word, B: AsMut<alloc::vec::Vec<W>>> WordRead for MemWordWriterVec<W, B> {
    type Error = std::io::Error;
    type Word = W;

    #[inline]
    fn read_word(&mut self) -> Result<W, std::io::Error> {
        match self.data.as_mut().get(self.word_index) {
            Some(word) => {
                self.word_index += 1;
                Ok(*word)
            }
            None => Err(std::io::Error::new(
                std::io::ErrorKind::UnexpectedEof,
                "Cannot read next word as the underlying memory ended",
            )),
        }
    }
}

#[cfg(feature = "alloc")]
impl<W: Word, B: AsMut<alloc::vec::Vec<W>> + AsRef<alloc::vec::Vec<W>>> WordSeek
    for MemWordWriterVec<W, B>
{
    type Error = std::io::Error;

    #[inline(always)]
    fn word_pos(&mut self) -> Result<u64, std::io::Error> {
        Ok(self.word_index as u64)
    }

    #[inline(always)]
    fn set_word_pos(&mut self, word_index: u64) -> Result<(), std::io::Error> {
        return if word_index > self.data.as_ref().len() as u64 {
            Err(std::io::Error::new(
                std::io::ErrorKind::UnexpectedEof,
                format_args!(
                    "Position beyond end of vector: {} > {}",
                    word_index,
                    self.data.as_ref().len()
                )
                .to_string(),
            ))
        } else {
            self.word_index = word_index as usize;
            Ok(())
        };
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/impls/mod.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

/*!

Implementations of bit and word (seekable) streams.

Implementations of bit streams read from word streams, that is,
implementations of [`WordRead`](crate::traits::WordRead) and
[`WordWrite`](crate::traits::WordWrite). If you have a standard
[`Read`](std::io::Read) or [`Write`](std::io::Write) byte stream
you can wrap it into a [`WordAdapter`] to turn it into a word stream.

In instead you want to read or write words directly from memory, you can use
[`MemWordReader`] and [`MemWordWriterVec`]/[`MemWordWriterSlice`],
which read from a slice and write to a vector/slice.

In all cases, you must specify a word type, which is the type of the words
you want to read or write. In the case of [`WordAdapter`], the word type
is arbitrary; in the case of [`MemWordReader`] and
[`MemWordWriterVec`]/[`MemWordWriterSlice`],
it must match the type of the elements of the slice or vector,
and will be usually filled in by type inference.

Once you have a way to read or write by words, you can use [`BufBitReader`] and
[`BufBitWriter`] to read or write bits. Both have a statically
selectable endianness and use an internal bit buffer to store bits that are not
yet read or written. In the case of [`BufBitReader`], the bit buffer is
twice large as the word type, so we suggest to use a type that is half of `usize` as word type,
whereas in the case of [`BufBitWriter`] the bit buffer is as large as the word,
so we suggest to use `usize` as word type.

[`BitReader`] reads memory directly, without using a bit buffer, but it is
usually significantly slower than [`BufBitReader`].

If you want to optimize these choices for your architecture, we suggest to
run the benchmarks in the `benchmarks` directory.

## Examples

### Reading from a file

```rust
# fn main() -> Result<(), Box<dyn std::error::Error>> {
use dsi_bitstream::prelude::*;
use std::io::BufReader;

let file = std::fs::File::open("README.md")?;
// Adapt to word type u32, select little endianness
let mut reader = BufBitReader::<LE, _>::new(WordAdapter::<u32, _>::new(BufReader::new(file)));
reader.read_gamma()?;
# Ok(())
# }
```

### Writing to and reading from a vector

```rust
# fn main() -> Result<(), Box<dyn std::error::Error>> {
use dsi_bitstream::prelude::*;

let mut v: Vec<u64> = vec![];
// Automatically chooses word type u64, select big endianness
let mut writer = BufBitWriter::<BE, _>::new(MemWordWriterVec::new(&mut v));
writer.write_gamma(42)?;
writer.flush()?;
drop(writer); // We must drop the writer release the borrow on v

let mut reader = BufBitReader::<BE, _>::new(MemWordReader::new(&v));
assert_eq!(reader.read_gamma()?, 42);
# Ok(())
# }
```

*/

mod mem_word_reader;
pub use mem_word_reader::*;

mod mem_word_writer;
pub use mem_word_writer::*;

#[cfg(feature = "std")]
mod word_adapter;
#[cfg(feature = "std")]
pub use word_adapter::*;

mod bit_reader;
pub use bit_reader::BitReader;

mod buf_bit_reader;
pub use buf_bit_reader::BufBitReader;

mod buf_bit_writer;
pub use buf_bit_writer::BufBitWriter;

```````

`/home/zom/Github/dsi-bitstream-rs/src/impls/word_adapter.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

use crate::traits::*;
use common_traits::*;
#[cfg(feature = "mem_dbg")]
use mem_dbg::{MemDbg, MemSize};
use std::io::{ErrorKind, Read, Seek, SeekFrom, Write};

/// An adapter from [`Read`], [`Write`], and [`Seek`], to [`WordRead`],
/// [`WordWrite`], and [`WordSeek`], respectively.
///
/// Instances of this struct can be created using [`WordAdapter::new`]. They
/// turn every standard (possibly seekable) source or destination of bytes (such
/// as [`std::fs::File`], [`std::io::BufReader`], sockets, etc.) into a source
/// or destination of words.
///
/// Due to the necessity of managing files whose length is not a multiple of the
/// word length, [`read_word`](WordAdapter::read_word) will return a partially
/// read word extended with zeros at the end of such files.
///
/// To provide a sensible value after such a read,
/// [`word_pos`](WordAdapter::word_pos) will always return the position
/// of the underlying [`Seek`] rounded up to the next multiple of `W::Bytes`.
/// This approach, however, requires that if you adapt a [`Seek`], its current position must be
/// a multiple of `W::Bytes`, or the results of [`word_pos`](WordAdapter::word_pos)
/// will be shifted by the rounding.
#[derive(Debug, Clone)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct WordAdapter<W: UnsignedInt + FromBytes + ToBytes, B> {
    backend: B,
    _marker: core::marker::PhantomData<W>,
}

impl<W: UnsignedInt + FromBytes + ToBytes, B> WordAdapter<W, B> {
    /// Create a new WordAdapter
    pub fn new(backend: B) -> Self {
        Self {
            backend,
            _marker: core::marker::PhantomData,
        }
    }

    pub fn into_inner(self) -> B {
        self.backend
    }
}

impl<W: UnsignedInt + ToBytes + FromBytes + FiniteRangeNumber, B: Read> WordRead
    for WordAdapter<W, B>
{
    type Error = std::io::Error;
    type Word = W;

    #[inline(always)]
    fn read_word(&mut self) -> Result<W, std::io::Error> {
        let mut res: W::Bytes = Default::default();
        match self.backend.read_exact(res.as_mut()) {
            Ok(()) => Ok(W::from_ne_bytes(res)),
            // We must guarantee zero-extension
            Err(e) if e.kind() == ErrorKind::UnexpectedEof => Ok(W::from_ne_bytes(res)),
            Err(e) => Err(e),
        }
    }
}

impl<W: UnsignedInt + ToBytes + FromBytes + FiniteRangeNumber, B: Write> WordWrite
    for WordAdapter<W, B>
{
    type Error = std::io::Error;
    type Word = W;

    #[inline]
    fn write_word(&mut self, word: W) -> Result<(), std::io::Error> {
        let _ = self.backend.write(word.to_ne_bytes().as_ref())?;
        Ok(())
    }

    fn flush(&mut self) -> Result<(), Self::Error> {
        self.backend.flush()
    }
}

impl<W: UnsignedInt + ToBytes + FromBytes + FiniteRangeNumber, B: Seek> WordSeek
    for WordAdapter<W, B>
{
    type Error = std::io::Error;

    #[inline(always)]
    fn word_pos(&mut self) -> Result<u64, std::io::Error> {
        Ok(self.backend.stream_position()?.align_to(W::BYTES as u64))
    }

    #[inline(always)]
    fn set_word_pos(&mut self, word_index: u64) -> Result<(), std::io::Error> {
        self.backend
            .seek(SeekFrom::Start(word_index * W::BYTES as u64))?;
        Ok(())
    }
}

#[cfg(test)]
mod test {
    use crate::prelude::*;
    #[test]
    fn test_word_adapter() {
        let data: Vec<u32> = vec![
            0xa6032421, 0xc9d01b28, 0x168b4ecd, 0xc5ccbed9, 0xfd007100, 0x08469d41, 0x989fd8c2,
            0x954d351a, 0x3225ec9f, 0xbca253f9, 0x915aad84, 0x274c0de1, 0x4bfc6982, 0x59a47341,
            0x4e32a33a, 0x9e0d2208,
        ];
        let path = std::env::temp_dir().join("test_file_adapter");
        {
            let mut writer = <WordAdapter<u32, _>>::new(std::fs::File::create(&path).unwrap());
            for value in &data {
                writer.write_word(*value).unwrap();
            }
        }
        {
            let mut reader = <WordAdapter<u32, _>>::new(std::fs::File::open(&path).unwrap());
            for value in &data {
                assert_eq!(*value, reader.read_word().unwrap());
            }
        }
    }

    #[test]
    fn test_word_adapter_codes() {
        let data: Vec<u8> = vec![
            0x5f, 0x68, 0xdb, 0xca, 0x79, 0x17, 0xf3, 0x37, 0x2c, 0x46, 0x63, 0xf7, 0xf3, 0x28,
            0xa4, 0x8d, 0x29, 0x3b, 0xb6, 0xd5, 0xc7, 0xe2, 0x22, 0x3f, 0x6e, 0xb5, 0xf2, 0xda,
            0x13, 0x1d, 0x37, 0x18, 0x5b, 0xf8, 0x45, 0x59, 0x33, 0x38, 0xaf, 0xc4, 0x8a, 0x1d,
            0x78, 0x81, 0xc8, 0xc3, 0xdb, 0xab, 0x23, 0xe1, 0x13, 0xb0, 0x04, 0xd7, 0x3c, 0x21,
            0x0e, 0xba, 0x5d, 0xfc, 0xac, 0x4f, 0x04, 0x2d,
        ];
        let path = std::env::temp_dir().join("test_file_adapter_codes");
        {
            let mut writer = <BufBitWriter<BE, _>>::new(<WordAdapter<u64, _>>::new(
                std::fs::File::create(&path).unwrap(),
            ));
            for value in &data {
                writer.write_gamma(*value as _).unwrap();
            }
        }
        {
            let mut reader = <BufBitReader<BE, _>>::new(<WordAdapter<u32, _>>::new(
                std::fs::File::open(&path).unwrap(),
            ));
            for value in &data {
                assert_eq!(*value as u64, reader.read_gamma().unwrap());
            }
        }
        {
            let mut writer = <BufBitWriter<LE, _>>::new(<WordAdapter<u64, _>>::new(
                std::fs::File::create(&path).unwrap(),
            ));
            for value in &data {
                writer.write_gamma(*value as _).unwrap();
            }
        }
        {
            let mut reader = <BufBitReader<LE, _>>::new(<WordAdapter<u32, _>>::new(
                std::fs::File::open(&path).unwrap(),
            ));
            for value in &data {
                assert_eq!(*value as u64, reader.read_gamma().unwrap());
            }
        }
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/impls/bit_reader.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

use core::convert::Infallible;
#[cfg(feature = "mem_dbg")]
use mem_dbg::{MemDbg, MemSize};
use std::error::Error;

use crate::codes::params::{DefaultReadParams, ReadParams};
use crate::traits::*;

/// An implementation of [`BitRead`] for a [`WordRead`] with word `u64` and of
/// [`BitSeek`] for a [`WordSeek`].
///
/// This implementation accesses randomly the underlying [`WordRead`] without
/// any buffering. It is usually slower than
/// [`BufBitReader`](crate::impls::BufBitReader).
///
/// The peek word is `u32`. The value returned by
/// [`peek_bits`](crate::traits::BitRead::peek_bits) contains at least 32 bits
/// (extended with zeros beyond end of stream), that is, a full peek word.
///
/// The additional type parameter `RP` is used to select the parameters for the
/// instantanous codes, but the casual user should be happy with the default
/// value. See [`ReadParams`] for more details.
///
/// For additional flexibility, this structures implements [`std::io::Read`].
/// Note that because of coherence rules it is not possible to implement
/// [`std::io::Read`] for a generic [`BitRead`].

#[derive(Debug, Clone)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct BitReader<E: Endianness, WR, RP: ReadParams = DefaultReadParams> {
    /// The stream which we will read words from.
    data: WR,
    /// The index of the current bit.
    bit_index: u64,
    _marker: core::marker::PhantomData<(E, RP)>,
}

impl<E: Endianness, WR, RP: ReadParams> BitReader<E, WR, RP> {
    pub fn new(data: WR) -> Self {
        check_tables(32);
        Self {
            data,
            bit_index: 0,
            _marker: core::marker::PhantomData,
        }
    }
}

impl<
        E: Error + Send + Sync + 'static,
        WR: WordRead<Error = E, Word = u64> + WordSeek<Error = E>,
        RP: ReadParams,
    > BitRead<BE> for BitReader<BE, WR, RP>
{
    type Error = <WR as WordRead>::Error;
    type PeekWord = u32;

    #[inline]
    fn skip_bits(&mut self, n_bits: usize) -> Result<(), Self::Error> {
        self.bit_index += n_bits as u64;
        Ok(())
    }

    #[inline]
    fn read_bits(&mut self, n_bits: usize) -> Result<u64, Self::Error> {
        if n_bits == 0 {
            return Ok(0);
        }

        assert!(n_bits <= 64);

        self.data.set_word_pos(self.bit_index / 64)?;
        let in_word_offset = (self.bit_index % 64) as usize;

        let res = if (in_word_offset + n_bits) <= 64 {
            // single word access
            let word = self.data.read_word()?.to_be();
            (word << in_word_offset) >> (64 - n_bits)
        } else {
            // double word access
            let high_word = self.data.read_word()?.to_be();
            let low_word = self.data.read_word()?.to_be();
            let shamt1 = 64 - n_bits;
            let shamt2 = 128 - in_word_offset - n_bits;
            ((high_word << in_word_offset) >> shamt1) | (low_word >> shamt2)
        };
        self.bit_index += n_bits as u64;
        Ok(res)
    }

    #[inline]
    fn peek_bits(&mut self, n_bits: usize) -> Result<u32, Self::Error> {
        if n_bits == 0 {
            return Ok(0);
        }

        assert!(n_bits <= 32);

        self.data.set_word_pos(self.bit_index / 64)?;
        let in_word_offset = (self.bit_index % 64) as usize;

        let res = if (in_word_offset + n_bits) <= 64 {
            // single word access
            let word = self.data.read_word()?.to_be();
            (word << in_word_offset) >> (64 - n_bits)
        } else {
            // double word access
            let high_word = self.data.read_word()?.to_be();
            let low_word = self.data.read_word()?.to_be();
            let shamt1 = 64 - n_bits;
            let shamt2 = 128 - in_word_offset - n_bits;
            ((high_word << in_word_offset) >> shamt1) | (low_word >> shamt2)
        };
        Ok(res as u32)
    }

    #[inline]
    fn read_unary(&mut self) -> Result<u64, Self::Error> {
        self.data.set_word_pos(self.bit_index / 64)?;
        let in_word_offset = self.bit_index % 64;
        let mut bits_in_word = 64 - in_word_offset;
        let mut total = 0;

        let mut word = self.data.read_word()?.to_be();
        word <<= in_word_offset;
        loop {
            let zeros = word.leading_zeros() as u64;
            // the unary code fits in the word
            if zeros < bits_in_word {
                self.bit_index += total + zeros + 1;
                return Ok(total + zeros);
            }
            total += bits_in_word;
            bits_in_word = 64;
            word = self.data.read_word()?.to_be();
        }
    }

    fn skip_bits_after_table_lookup(&mut self, n: usize) {
        self.bit_index += n as u64;
    }
}

impl<WR: WordSeek, RP: ReadParams> BitSeek for BitReader<LE, WR, RP> {
    type Error = Infallible;

    fn bit_pos(&mut self) -> Result<u64, Self::Error> {
        Ok(self.bit_index)
    }

    fn set_bit_pos(&mut self, bit_index: u64) -> Result<(), Self::Error> {
        self.bit_index = bit_index;
        Ok(())
    }
}

impl<WR: WordSeek, RP: ReadParams> BitSeek for BitReader<BE, WR, RP> {
    type Error = Infallible;

    fn bit_pos(&mut self) -> Result<u64, Self::Error> {
        Ok(self.bit_index)
    }

    fn set_bit_pos(&mut self, bit_index: u64) -> Result<(), Self::Error> {
        self.bit_index = bit_index;
        Ok(())
    }
}

impl<
        E: Error + Send + Sync + 'static,
        WR: WordRead<Error = E, Word = u64> + WordSeek<Error = E>,
        RP: ReadParams,
    > BitRead<LE> for BitReader<LE, WR, RP>
{
    type Error = <WR as WordRead>::Error;
    type PeekWord = u32;

    #[inline]
    fn skip_bits(&mut self, n_bits: usize) -> Result<(), Self::Error> {
        self.bit_index += n_bits as u64;
        Ok(())
    }

    #[inline]
    fn read_bits(&mut self, n_bits: usize) -> Result<u64, Self::Error> {
        #[cfg(feature = "checks")]
        assert!(n_bits <= 64);

        if n_bits == 0 {
            return Ok(0);
        }

        self.data.set_word_pos(self.bit_index / 64)?;
        let in_word_offset = (self.bit_index % 64) as usize;

        let res = if (in_word_offset + n_bits) <= 64 {
            // single word access
            let word = self.data.read_word()?.to_le();
            let shamt = 64 - n_bits;
            (word << (shamt - in_word_offset)) >> shamt
        } else {
            // double word access
            let low_word = self.data.read_word()?.to_le();
            let high_word = self.data.read_word()?.to_le();
            let shamt1 = 128 - in_word_offset - n_bits;
            let shamt2 = 64 - n_bits;
            ((high_word << shamt1) >> shamt2) | (low_word >> in_word_offset)
        };
        self.bit_index += n_bits as u64;
        Ok(res)
    }

    #[inline]
    fn peek_bits(&mut self, n_bits: usize) -> Result<u32, Self::Error> {
        if n_bits == 0 {
            return Ok(0);
        }

        assert!(n_bits <= 32);

        self.data.set_word_pos(self.bit_index / 64)?;
        let in_word_offset = (self.bit_index % 64) as usize;

        let res = if (in_word_offset + n_bits) <= 64 {
            // single word access
            let word = self.data.read_word()?.to_le();
            let shamt = 64 - n_bits;
            (word << (shamt - in_word_offset)) >> shamt
        } else {
            // double word access
            let low_word = self.data.read_word()?.to_le();
            let high_word = self.data.read_word()?.to_le();
            let shamt1 = 128 - in_word_offset - n_bits;
            let shamt2 = 64 - n_bits;
            ((high_word << shamt1) >> shamt2) | (low_word >> in_word_offset)
        };
        Ok(res as u32)
    }

    #[inline]
    fn read_unary(&mut self) -> Result<u64, Self::Error> {
        self.data.set_word_pos(self.bit_index / 64)?;
        let in_word_offset = self.bit_index % 64;
        let mut bits_in_word = 64 - in_word_offset;
        let mut total = 0;

        let mut word = self.data.read_word()?.to_le();
        word >>= in_word_offset;
        loop {
            let zeros = word.trailing_zeros() as u64;
            // the unary code fits in the word
            if zeros < bits_in_word {
                self.bit_index += total + zeros + 1;
                return Ok(total + zeros);
            }
            total += bits_in_word;
            bits_in_word = 64;
            word = self.data.read_word()?.to_le();
        }
    }

    fn skip_bits_after_table_lookup(&mut self, n: usize) {
        self.bit_index += n as u64;
    }
}

impl<
        E: Error + Send + Sync + 'static,
        WR: WordRead<Error = E, Word = u64> + WordSeek<Error = E>,
        RP: ReadParams,
    > std::io::Read for BitReader<LE, WR, RP>
{
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        let mut iter = buf.chunks_exact_mut(8);

        for chunk in &mut iter {
            let word = self
                .read_bits(64)
                .map_err(|_| std::io::ErrorKind::UnexpectedEof)?;
            chunk.copy_from_slice(&word.to_le_bytes());
        }

        let rem = iter.into_remainder();
        if !rem.is_empty() {
            let word = self
                .read_bits(rem.len() * 8)
                .map_err(|_| std::io::ErrorKind::UnexpectedEof)?;
            rem.copy_from_slice(&word.to_le_bytes()[..rem.len()]);
        }

        Ok(buf.len())
    }
}

impl<
        E: Error + Send + Sync + 'static,
        WR: WordRead<Error = E, Word = u64> + WordSeek<Error = E>,
        RP: ReadParams,
    > std::io::Read for BitReader<BE, WR, RP>
{
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        let mut iter = buf.chunks_exact_mut(8);

        for chunk in &mut iter {
            let word = self
                .read_bits(64)
                .map_err(|_| std::io::ErrorKind::UnexpectedEof)?;
            chunk.copy_from_slice(&word.to_be_bytes());
        }

        let rem = iter.into_remainder();
        if !rem.is_empty() {
            let word = self
                .read_bits(rem.len() * 8)
                .map_err(|_| std::io::ErrorKind::UnexpectedEof)?;
            rem.copy_from_slice(&word.to_be_bytes()[8 - rem.len()..]);
        }

        Ok(buf.len())
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/impls/buf_bit_reader.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

use common_traits::*;

use crate::codes::params::{DefaultReadParams, ReadParams};
use crate::traits::*;
use core::convert::Infallible;
use core::{mem, ptr};
#[cfg(feature = "mem_dbg")]
use mem_dbg::{MemDbg, MemSize};
use std::error::Error;

/// An internal shortcut to the double type of the word of a
/// [`WordRead`].
type BB<WR> = <<WR as WordRead>::Word as DoubleType>::DoubleType;

/// An implementation of [`BitRead`] and [`BitSeek`] for a [`WordRead`] and a
/// [`WordSeek`].
///
/// This implementation uses a bit buffer to store bits that are not yet read.
/// The buffer is sized as twice the word size of the underlying [`WordRead`].
/// Typically, the best choice is to have a buffer that is sized as `usize`,
/// which means that the word of the underlying [`WordRead`] should be half of
/// that (i.e., `u32` for a 64-bit architecture). However, results will vary
/// depending on the CPU.
///
/// The peek word is equal to the bit buffer. The value returned
/// by [`peek_bits`](crate::traits::BitRead::peek_bits) contains at least as
/// many bits as the word size plus one (extended with zeros beyond end of
/// stream).
///
/// This implementation is usually faster than
/// [`BitReader`](crate::impls::BitReader).
///
/// The additional type parameter `RP` is used to select the parameters for the
/// instantanous codes, but the casual user should be happy with the default
/// value. See [`ReadParams`] for more details.
///
/// For additional flexibility, this structures implements [`std::io::Read`].
/// Note that because of coherence rules it is not possible to implement
/// [`std::io::Read`] for a generic [`BitRead`].

#[derive(Debug)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct BufBitReader<E: Endianness, WR: WordRead, RP: ReadParams = DefaultReadParams>
where
    WR::Word: DoubleType,
{
    /// The [`WordRead`] used to fill the buffer.
    backend: WR,
    /// The 2-word bit buffer that is used to read the codes. It is never full,
    /// but it may be empty. Only the upper (BE) or lower (LE)
    /// `bits_in_buffer` bits are valid; the other bits are always zeroes.
    buffer: BB<WR>,
    /// Number of valid upper (BE) or lower (LE) bits in the buffer.
    /// It is always smaller than `BB::<WR>::BITS`.
    bits_in_buffer: usize,
    _marker: core::marker::PhantomData<(E, RP)>,
}

impl<E: Endianness, WR: WordRead + Clone, RP: ReadParams> core::clone::Clone
    for BufBitReader<E, WR, RP>
where
    WR::Word: DoubleType,
{
    fn clone(&self) -> Self {
        Self {
            backend: self.backend.clone(),
            buffer: self.buffer,
            bits_in_buffer: self.bits_in_buffer,
            _marker: core::marker::PhantomData,
        }
    }
}

impl<E: Endianness, WR: WordRead, RP: ReadParams> BufBitReader<E, WR, RP>
where
    WR::Word: DoubleType,
{
    /// Create a new [`BufBitReader`] around a [`WordRead`].
    ///
    /// # Example
    /// ```
    /// use dsi_bitstream::prelude::*;
    /// let words: [u32; 2] = [0x0043b59f, 0xccf16077];
    /// let word_reader = MemWordReader::new(&words);
    /// let mut buf_bit_reader = <BufBitReader<BE, _>>::new(word_reader);
    /// ```
    #[must_use]
    pub fn new(backend: WR) -> Self {
        check_tables(WR::Word::BITS + 1);
        Self {
            backend,
            buffer: BB::<WR>::ZERO,
            bits_in_buffer: 0,
            _marker: core::marker::PhantomData,
        }
    }

    ///  Return the backend, consuming this reader.
    pub fn into_inner(self) -> Result<WR, Infallible> {
        // SAFETY: forget(self) prevents double dropping backend
        let backend = unsafe { ptr::read(&self.backend) };
        mem::forget(self);
        Ok(backend)
    }
}

//
// Big-endian implementation
//

impl<WR: WordRead, RP: ReadParams> BufBitReader<BE, WR, RP>
where
    WR::Word: DoubleType,
{
    /// Ensure that in the buffer there are at least `WR::Word::BITS` bits to read.
    /// This method can be called only if there are at least
    /// `WR::Word::BITS` free bits in the buffer.
    #[inline(always)]
    fn refill(&mut self) -> Result<(), <WR as WordRead>::Error> {
        debug_assert!(BB::<WR>::BITS - self.bits_in_buffer >= WR::Word::BITS);

        let new_word: BB<WR> = self.backend.read_word()?.to_be().upcast();
        self.bits_in_buffer += WR::Word::BITS;
        self.buffer |= new_word << (BB::<WR>::BITS - self.bits_in_buffer);
        Ok(())
    }
}

impl<WR: WordRead, RP: ReadParams> BitRead<BE> for BufBitReader<BE, WR, RP>
where
    WR::Word: DoubleType + UpcastableInto<u64>,
    BB<WR>: CastableInto<u64>,
{
    type Error = <WR as WordRead>::Error;
    type PeekWord = BB<WR>;

    #[inline(always)]
    fn peek_bits(&mut self, n_bits: usize) -> Result<Self::PeekWord, Self::Error> {
        debug_assert!(n_bits > 0);
        debug_assert!(n_bits <= Self::PeekWord::BITS);

        // A peek can do at most one refill, otherwise we might lose data
        if n_bits > self.bits_in_buffer {
            self.refill()?;
        }

        debug_assert!(n_bits <= self.bits_in_buffer);

        // Move the n_bits highest bits of the buffer to the lowest
        Ok(self.buffer >> (BB::<WR>::BITS - n_bits))
    }

    #[inline(always)]
    fn skip_bits_after_table_lookup(&mut self, n_bits: usize) {
        self.bits_in_buffer -= n_bits;
        self.buffer <<= n_bits;
    }

    #[inline]
    fn read_bits(&mut self, mut n_bits: usize) -> Result<u64, Self::Error> {
        debug_assert!(n_bits <= 64);
        debug_assert!(self.bits_in_buffer < BB::<WR>::BITS);

        // most common path, we just read the buffer
        if n_bits <= self.bits_in_buffer {
            // Valid right shift of BB::<WR>::BITS - n_bits, even when n_bits is zero
            let result: u64 = (self.buffer >> (BB::<WR>::BITS - n_bits - 1) >> 1_u32).cast();
            self.bits_in_buffer -= n_bits;
            self.buffer <<= n_bits;
            return Ok(result);
        }

        let mut result: u64 =
            (self.buffer >> (BB::<WR>::BITS - 1 - self.bits_in_buffer) >> 1_u8).cast();
        n_bits -= self.bits_in_buffer;

        // Directly read to the result without updating the buffer
        while n_bits > WR::Word::BITS {
            let new_word: u64 = self.backend.read_word()?.to_be().upcast();
            result = (result << WR::Word::BITS) | new_word;
            n_bits -= WR::Word::BITS;
        }

        debug_assert!(n_bits > 0);
        debug_assert!(n_bits <= WR::Word::BITS);

        // get the final word
        let new_word = self.backend.read_word()?.to_be();
        self.bits_in_buffer = WR::Word::BITS - n_bits;
        // compose the remaining bits
        let upcasted: u64 = new_word.upcast();
        let final_bits: u64 = (upcasted >> self.bits_in_buffer).downcast();
        result = (result << (n_bits - 1) << 1) | final_bits;
        // and put the rest in the buffer
        self.buffer = (UpcastableInto::<BB<WR>>::upcast(new_word)
            << (BB::<WR>::BITS - self.bits_in_buffer - 1))
            << 1;

        Ok(result)
    }

    #[inline]
    fn read_unary(&mut self) -> Result<u64, Self::Error> {
        debug_assert!(self.bits_in_buffer < BB::<WR>::BITS);

        // count the zeros from the left
        let zeros: usize = self.buffer.leading_zeros() as _;

        // if we encountered an 1 in the bits_in_buffer we can return
        if zeros < self.bits_in_buffer {
            self.buffer = self.buffer << zeros << 1;
            self.bits_in_buffer -= zeros + 1;
            return Ok(zeros as u64);
        }

        let mut result: u64 = self.bits_in_buffer as _;

        loop {
            let new_word = self.backend.read_word()?.to_be();

            if new_word != WR::Word::ZERO {
                let zeros: usize = new_word.leading_zeros() as _;
                self.buffer =
                    UpcastableInto::<BB<WR>>::upcast(new_word) << (WR::Word::BITS + zeros) << 1;
                self.bits_in_buffer = WR::Word::BITS - zeros - 1;
                return Ok(result + zeros as u64);
            }
            result += WR::Word::BITS as u64;
        }
    }

    #[inline]
    fn skip_bits(&mut self, mut n_bits: usize) -> Result<(), Self::Error> {
        debug_assert!(self.bits_in_buffer < BB::<WR>::BITS);
        // happy case, just shift the buffer
        if n_bits <= self.bits_in_buffer {
            self.bits_in_buffer -= n_bits;
            self.buffer <<= n_bits;
            return Ok(());
        }

        n_bits -= self.bits_in_buffer;

        // skip words as needed
        while n_bits > WR::Word::BITS {
            let _ = self.backend.read_word()?;
            n_bits -= WR::Word::BITS;
        }

        // get the final word
        let new_word = self.backend.read_word()?.to_be();
        self.bits_in_buffer = WR::Word::BITS - n_bits;

        self.buffer = UpcastableInto::<BB<WR>>::upcast(new_word)
            << (BB::<WR>::BITS - 1 - self.bits_in_buffer)
            << 1;

        Ok(())
    }

    #[cfg(not(feature = "no_copy_impls"))]
    fn copy_to<F: Endianness, W: BitWrite<F>>(
        &mut self,
        bit_write: &mut W,
        mut n: u64,
    ) -> Result<(), CopyError<Self::Error, W::Error>> {
        let from_buffer = Ord::min(n, self.bits_in_buffer as _);
        self.buffer = self.buffer.rotate_left(from_buffer as _);

        bit_write
            .write_bits(self.buffer.cast(), from_buffer as usize)
            .map_err(CopyError::WriteError)?;
        n -= from_buffer;

        if n == 0 {
            self.bits_in_buffer -= from_buffer as usize;
            return Ok(());
        }

        while n > WR::Word::BITS as u64 {
            bit_write
                .write_bits(
                    self.backend
                        .read_word()
                        .map_err(CopyError::ReadError)?
                        .to_be()
                        .upcast(),
                    WR::Word::BITS,
                )
                .map_err(CopyError::WriteError)?;
            n -= WR::Word::BITS as u64;
        }

        assert!(n > 0);
        let new_word = self
            .backend
            .read_word()
            .map_err(CopyError::ReadError)?
            .to_be();
        self.bits_in_buffer = WR::Word::BITS - n as usize;
        bit_write
            .write_bits((new_word >> self.bits_in_buffer).upcast(), n as usize)
            .map_err(CopyError::WriteError)?;
        self.buffer = UpcastableInto::<BB<WR>>::upcast(new_word)
            .rotate_right(WR::Word::BITS as u32 - n as u32);

        Ok(())
    }
}

impl<
        E: Error + Send + Sync + 'static,
        WR: WordRead<Error = E> + WordSeek<Error = E>,
        RP: ReadParams,
    > BitSeek for BufBitReader<BE, WR, RP>
where
    WR::Word: DoubleType,
{
    type Error = <WR as WordSeek>::Error;

    #[inline]
    fn bit_pos(&mut self) -> Result<u64, Self::Error> {
        Ok(self.backend.word_pos()? * WR::Word::BITS as u64 - self.bits_in_buffer as u64)
    }

    #[inline]
    fn set_bit_pos(&mut self, bit_index: u64) -> Result<(), Self::Error> {
        self.backend
            .set_word_pos(bit_index / WR::Word::BITS as u64)?;
        let bit_offset = (bit_index % WR::Word::BITS as u64) as usize;
        self.buffer = BB::<WR>::ZERO;
        self.bits_in_buffer = 0;
        if bit_offset != 0 {
            let new_word: BB<WR> = self.backend.read_word()?.to_be().upcast();
            self.bits_in_buffer = WR::Word::BITS - bit_offset;
            self.buffer = new_word << (BB::<WR>::BITS - self.bits_in_buffer);
        }
        Ok(())
    }
}

//
// Little-endian implementation
//

impl<WR: WordRead, RP: ReadParams> BufBitReader<LE, WR, RP>
where
    WR::Word: DoubleType,
{
    /// Ensure that in the buffer there are at least `WR::Word::BITS` bits to read.
    /// This method can be called only if there are at least
    /// `WR::Word::BITS` free bits in the buffer.
    #[inline(always)]
    fn refill(&mut self) -> Result<(), <WR as WordRead>::Error> {
        debug_assert!(BB::<WR>::BITS - self.bits_in_buffer >= WR::Word::BITS);

        let new_word: BB<WR> = self.backend.read_word()?.to_le().upcast();
        self.buffer |= new_word << self.bits_in_buffer;
        self.bits_in_buffer += WR::Word::BITS;
        Ok(())
    }
}

impl<WR: WordRead, RP: ReadParams> BitRead<LE> for BufBitReader<LE, WR, RP>
where
    WR::Word: DoubleType + UpcastableInto<u64>,
    BB<WR>: CastableInto<u64>,
{
    type Error = <WR as WordRead>::Error;
    type PeekWord = BB<WR>;

    #[inline(always)]
    fn peek_bits(&mut self, n_bits: usize) -> Result<Self::PeekWord, Self::Error> {
        debug_assert!(n_bits > 0);
        debug_assert!(n_bits <= Self::PeekWord::BITS);

        // A peek can do at most one refill, otherwise we might lose data
        if n_bits > self.bits_in_buffer {
            self.refill()?;
        }

        debug_assert!(n_bits <= self.bits_in_buffer);

        // Keep the n_bits lowest bits of the buffer
        let shamt = BB::<WR>::BITS - n_bits;
        Ok((self.buffer << shamt) >> shamt)
    }

    #[inline(always)]
    fn skip_bits_after_table_lookup(&mut self, n_bits: usize) {
        self.bits_in_buffer -= n_bits;
        self.buffer >>= n_bits;
    }

    #[inline]
    fn read_bits(&mut self, mut n_bits: usize) -> Result<u64, Self::Error> {
        debug_assert!(n_bits <= 64);
        debug_assert!(self.bits_in_buffer < BB::<WR>::BITS);

        // most common path, we just read the buffer
        if n_bits <= self.bits_in_buffer {
            let result: u64 = (self.buffer & ((BB::<WR>::ONE << n_bits) - BB::<WR>::ONE)).cast();
            self.bits_in_buffer -= n_bits;
            self.buffer >>= n_bits;
            return Ok(result);
        }

        let mut result: u64 = self.buffer.cast();
        let mut bits_in_res = self.bits_in_buffer;

        // Directly read to the result without updating the buffer
        while n_bits > WR::Word::BITS + bits_in_res {
            let new_word: u64 = self.backend.read_word()?.to_le().upcast();
            result |= new_word << bits_in_res;
            bits_in_res += WR::Word::BITS;
        }

        n_bits -= bits_in_res;

        debug_assert!(n_bits > 0);
        debug_assert!(n_bits <= WR::Word::BITS);

        // get the final word
        let new_word = self.backend.read_word()?.to_le();
        self.bits_in_buffer = WR::Word::BITS - n_bits;
        // compose the remaining bits
        let shamt = 64 - n_bits;
        let upcasted: u64 = new_word.upcast();
        let final_bits: u64 = ((upcasted << shamt) >> shamt).downcast();
        result |= final_bits << bits_in_res;
        // and put the rest in the buffer
        self.buffer = UpcastableInto::<BB<WR>>::upcast(new_word) >> n_bits;

        Ok(result)
    }

    #[inline]
    fn read_unary(&mut self) -> Result<u64, Self::Error> {
        debug_assert!(self.bits_in_buffer < BB::<WR>::BITS);

        // count the zeros from the right
        let zeros: usize = self.buffer.trailing_zeros() as usize;

        // if we encountered an 1 in the bits_in_buffer we can return
        if zeros < self.bits_in_buffer {
            self.buffer = self.buffer >> zeros >> 1;
            self.bits_in_buffer -= zeros + 1;
            return Ok(zeros as u64);
        }

        let mut result: u64 = self.bits_in_buffer as _;

        loop {
            let new_word = self.backend.read_word()?.to_le();

            if new_word != WR::Word::ZERO {
                let zeros: usize = new_word.trailing_zeros() as _;
                self.buffer = UpcastableInto::<BB<WR>>::upcast(new_word) >> zeros >> 1;
                self.bits_in_buffer = WR::Word::BITS - zeros - 1;
                return Ok(result + zeros as u64);
            }
            result += WR::Word::BITS as u64;
        }
    }

    #[inline]
    fn skip_bits(&mut self, mut n_bits: usize) -> Result<(), Self::Error> {
        debug_assert!(self.bits_in_buffer < BB::<WR>::BITS);
        // happy case, just shift the buffer
        if n_bits <= self.bits_in_buffer {
            self.bits_in_buffer -= n_bits;
            self.buffer >>= n_bits;
            return Ok(());
        }

        n_bits -= self.bits_in_buffer;

        // skip words as needed
        while n_bits > WR::Word::BITS {
            let _ = self.backend.read_word()?;
            n_bits -= WR::Word::BITS;
        }

        // get the final word
        let new_word = self.backend.read_word()?.to_le();
        self.bits_in_buffer = WR::Word::BITS - n_bits;
        self.buffer = UpcastableInto::<BB<WR>>::upcast(new_word) >> n_bits;

        Ok(())
    }

    #[cfg(not(feature = "no_copy_impls"))]
    fn copy_to<F: Endianness, W: BitWrite<F>>(
        &mut self,
        bit_write: &mut W,
        mut n: u64,
    ) -> Result<(), CopyError<Self::Error, W::Error>> {
        let from_buffer = Ord::min(n, self.bits_in_buffer as _);

        bit_write
            .write_bits(self.buffer.cast(), from_buffer as usize)
            .map_err(CopyError::WriteError)?;

        self.buffer >>= from_buffer;
        n -= from_buffer;

        if n == 0 {
            self.bits_in_buffer -= from_buffer as usize;
            return Ok(());
        }

        while n > WR::Word::BITS as u64 {
            bit_write
                .write_bits(
                    self.backend
                        .read_word()
                        .map_err(CopyError::ReadError)?
                        .to_le()
                        .upcast(),
                    WR::Word::BITS,
                )
                .map_err(CopyError::WriteError)?;
            n -= WR::Word::BITS as u64;
        }

        assert!(n > 0);
        let new_word = self
            .backend
            .read_word()
            .map_err(CopyError::ReadError)?
            .to_le();
        self.bits_in_buffer = WR::Word::BITS - n as usize;
        bit_write
            .write_bits(new_word.upcast(), n as usize)
            .map_err(CopyError::WriteError)?;
        self.buffer = UpcastableInto::<BB<WR>>::upcast(new_word) >> n;
        Ok(())
    }
}

impl<
        E: Error + Send + Sync + 'static,
        WR: WordRead<Error = E> + WordSeek<Error = E>,
        RP: ReadParams,
    > BitSeek for BufBitReader<LE, WR, RP>
where
    WR::Word: DoubleType,
{
    type Error = <WR as WordSeek>::Error;

    #[inline]
    fn bit_pos(&mut self) -> Result<u64, Self::Error> {
        Ok(self.backend.word_pos()? * WR::Word::BITS as u64 - self.bits_in_buffer as u64)
    }

    #[inline]
    fn set_bit_pos(&mut self, bit_index: u64) -> Result<(), Self::Error> {
        self.backend
            .set_word_pos(bit_index / WR::Word::BITS as u64)?;

        let bit_offset = (bit_index % WR::Word::BITS as u64) as usize;
        self.buffer = BB::<WR>::ZERO;
        self.bits_in_buffer = 0;
        if bit_offset != 0 {
            let new_word: BB<WR> = self.backend.read_word()?.to_le().upcast();
            self.bits_in_buffer = WR::Word::BITS - bit_offset;
            self.buffer = new_word >> bit_offset;
        }
        Ok(())
    }
}

impl<WR: WordRead, RP: ReadParams> std::io::Read for BufBitReader<LE, WR, RP>
where
    WR::Word: DoubleType + UpcastableInto<u64>,
    BB<WR>: CastableInto<u64>,
{
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        let mut iter = buf.chunks_exact_mut(8);

        for chunk in &mut iter {
            let word = self
                .read_bits(64)
                .map_err(|_| std::io::ErrorKind::UnexpectedEof)?;
            chunk.copy_from_slice(&word.to_le_bytes());
        }

        let rem = iter.into_remainder();
        if !rem.is_empty() {
            let word = self
                .read_bits(rem.len() * 8)
                .map_err(|_| std::io::ErrorKind::UnexpectedEof)?;
            rem.copy_from_slice(&word.to_le_bytes()[..rem.len()]);
        }

        Ok(buf.len())
    }
}

impl<WR: WordRead, RP: ReadParams> std::io::Read for BufBitReader<BE, WR, RP>
where
    WR::Word: DoubleType + UpcastableInto<u64>,
    BB<WR>: CastableInto<u64>,
{
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        let mut iter = buf.chunks_exact_mut(8);

        for chunk in &mut iter {
            let word = self
                .read_bits(64)
                .map_err(|_| std::io::ErrorKind::UnexpectedEof)?;
            chunk.copy_from_slice(&word.to_be_bytes());
        }

        let rem = iter.into_remainder();
        if !rem.is_empty() {
            let word = self
                .read_bits(rem.len() * 8)
                .map_err(|_| std::io::ErrorKind::UnexpectedEof)?;
            rem.copy_from_slice(&word.to_be_bytes()[8 - rem.len()..]);
        }

        Ok(buf.len())
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::prelude::{MemWordReader, MemWordWriterVec};
    use std::io::Read;

    #[test]
    fn test_read() {
        let data = [
            0x90, 0x2d, 0xd0, 0x26, 0xdf, 0x89, 0xbb, 0x7e, 0x3a, 0xd6, 0xc6, 0x96, 0x73, 0xe9,
            0x9d, 0xc9, 0x2a, 0x77, 0x82, 0xa9, 0xe6, 0x4b, 0x53, 0xcc, 0x83, 0x80, 0x4a, 0xf3,
            0xcd, 0xe3, 0x50, 0x4e, 0x45, 0x4a, 0x3a, 0x42, 0x00, 0x4b, 0x4d, 0xbe, 0x4c, 0x88,
            0x24, 0xf2, 0x4b, 0x6b, 0xbd, 0x79, 0xeb, 0x74, 0xbc, 0xe8, 0x7d, 0xff, 0x4b, 0x3d,
            0xa7, 0xd6, 0x0d, 0xef, 0x9c, 0x5b, 0xb3, 0xec, 0x94, 0x97, 0xcc, 0x8b, 0x41, 0xe1,
            0x9c, 0xcc, 0x1a, 0x03, 0x58, 0xc4, 0xfb, 0xd0, 0xc0, 0x10, 0xe2, 0xa0, 0xc9, 0xac,
            0xa7, 0xbb, 0x50, 0xf6, 0x5c, 0x87, 0x68, 0x0f, 0x42, 0x93, 0x3f, 0x2e, 0x28, 0x28,
            0x76, 0x83, 0x9b, 0xeb, 0x12, 0xe0, 0x4f, 0xc5, 0xb0, 0x8d, 0x14, 0xda, 0x3b, 0xdf,
            0xd3, 0x4b, 0x80, 0xd1, 0xfc, 0x87, 0x85, 0xae, 0x54, 0xc7, 0x45, 0xc9, 0x38, 0x43,
            0xa7, 0x9f, 0xdd, 0xa9, 0x71, 0xa7, 0x52, 0x36, 0x82, 0xff, 0x49, 0x55, 0xdb, 0x84,
            0xc2, 0x95, 0xad, 0x45, 0x80, 0xc6, 0x02, 0x80, 0xf8, 0xfc, 0x86, 0x79, 0xae, 0xb9,
            0x57, 0xe7, 0x3b, 0x33, 0x64, 0xa8,
        ];
        let data_u32 = unsafe { data.align_to::<u32>().1 };

        for i in 0..data.len() {
            let mut reader = BufBitReader::<LE, _>::new(MemWordReader::new(&data_u32));
            let mut buffer = vec![0; i];
            reader.read(&mut buffer).unwrap();
            assert_eq!(&buffer, &data[..i]);

            let mut reader = BufBitReader::<BE, _>::new(MemWordReader::new(&data_u32));
            let mut buffer = vec![0; i];
            reader.read(&mut buffer).unwrap();
            assert_eq!(&buffer, &data[..i]);
        }
    }

    macro_rules! test_buf_bit_reader {
        ($f: ident, $word:ty) => {
            #[test]
            fn $f() -> Result<(), Box<dyn Error + Send + Sync + 'static>> {
                #[allow(unused_imports)]
                use crate::{
                    codes::{GammaRead, GammaWrite},
                    prelude::{
                        len_delta, len_gamma, BufBitWriter, DeltaRead, DeltaWrite, MemWordReader,
                    },
                };
                use rand::Rng;
                use rand::{rngs::SmallRng, SeedableRng};

                let mut buffer_be: Vec<$word> = vec![];
                let mut buffer_le: Vec<$word> = vec![];
                let mut big = BufBitWriter::<BE, _>::new(MemWordWriterVec::new(&mut buffer_be));
                let mut little = BufBitWriter::<LE, _>::new(MemWordWriterVec::new(&mut buffer_le));

                let mut r = SmallRng::seed_from_u64(0);
                const ITER: usize = 1_000_000;

                for _ in 0..ITER {
                    let value = r.gen_range(0..128);
                    assert_eq!(big.write_gamma(value)?, len_gamma(value));
                    let value = r.gen_range(0..128);
                    assert_eq!(little.write_gamma(value)?, len_gamma(value));
                    let value = r.gen_range(0..128);
                    assert_eq!(big.write_gamma(value)?, len_gamma(value));
                    let value = r.gen_range(0..128);
                    assert_eq!(little.write_gamma(value)?, len_gamma(value));
                    let value = r.gen_range(0..128);
                    assert_eq!(big.write_delta(value)?, len_delta(value));
                    let value = r.gen_range(0..128);
                    assert_eq!(little.write_delta(value)?, len_delta(value));
                    let value = r.gen_range(0..128);
                    assert_eq!(big.write_delta(value)?, len_delta(value));
                    let value = r.gen_range(0..128);
                    assert_eq!(little.write_delta(value)?, len_delta(value));
                    let n_bits = r.gen_range(0..=64);
                    if n_bits == 0 {
                        big.write_bits(0, 0)?;
                    } else {
                        big.write_bits(1, n_bits)?;
                    }
                    let n_bits = r.gen_range(0..=64);
                    if n_bits == 0 {
                        little.write_bits(0, 0)?;
                    } else {
                        little.write_bits(1, n_bits)?;
                    }
                    let value = r.gen_range(0..128);
                    assert_eq!(big.write_unary(value)?, value as usize + 1);
                    let value = r.gen_range(0..128);
                    assert_eq!(little.write_unary(value)?, value as usize + 1);
                }

                drop(big);
                drop(little);

                type ReadWord = $word;
                let be_trans: &[ReadWord] = unsafe {
                    core::slice::from_raw_parts(
                        buffer_be.as_ptr() as *const ReadWord,
                        buffer_be.len()
                            * (core::mem::size_of::<$word>() / core::mem::size_of::<ReadWord>()),
                    )
                };
                let le_trans: &[ReadWord] = unsafe {
                    core::slice::from_raw_parts(
                        buffer_le.as_ptr() as *const ReadWord,
                        buffer_le.len()
                            * (core::mem::size_of::<$word>() / core::mem::size_of::<ReadWord>()),
                    )
                };

                let mut big_buff = BufBitReader::<BE, _>::new(MemWordReader::new(be_trans));
                let mut little_buff = BufBitReader::<LE, _>::new(MemWordReader::new(le_trans));

                let mut r = SmallRng::seed_from_u64(0);

                for _ in 0..ITER {
                    assert_eq!(big_buff.read_gamma()?, r.gen_range(0..128));
                    assert_eq!(little_buff.read_gamma()?, r.gen_range(0..128));
                    assert_eq!(big_buff.read_gamma()?, r.gen_range(0..128));
                    assert_eq!(little_buff.read_gamma()?, r.gen_range(0..128));
                    assert_eq!(big_buff.read_delta()?, r.gen_range(0..128));
                    assert_eq!(little_buff.read_delta()?, r.gen_range(0..128));
                    assert_eq!(big_buff.read_delta()?, r.gen_range(0..128));
                    assert_eq!(little_buff.read_delta()?, r.gen_range(0..128));
                    let n_bits = r.gen_range(0..=64);
                    if n_bits == 0 {
                        assert_eq!(big_buff.read_bits(0)?, 0);
                    } else {
                        assert_eq!(big_buff.read_bits(n_bits)?, 1);
                    }
                    let n_bits = r.gen_range(0..=64);
                    if n_bits == 0 {
                        assert_eq!(little_buff.read_bits(0)?, 0);
                    } else {
                        assert_eq!(little_buff.read_bits(n_bits)?, 1);
                    }

                    assert_eq!(big_buff.read_unary()?, r.gen_range(0..128));
                    assert_eq!(little_buff.read_unary()?, r.gen_range(0..128));
                }

                Ok(())
            }
        };
    }

    test_buf_bit_reader!(test_u64, u64);
    test_buf_bit_reader!(test_u32, u32);

    test_buf_bit_reader!(test_u16, u16);
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/impls/buf_bit_writer.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

use core::any::TypeId;
use core::{mem, ptr};

use crate::codes::params::{DefaultWriteParams, WriteParams};
use crate::traits::*;
use common_traits::{AsBytes, CastableInto, FiniteRangeNumber, Integer, Number};
#[cfg(feature = "mem_dbg")]
use mem_dbg::{MemDbg, MemSize};

/// An implementation of [`BitWrite`] for a [`WordWrite`].
///
/// This implementation uses a bit buffer to store bits that are not yet
/// written. The size of the bit buffer is the size of the word used by the
/// [`WordWrite`], which on most platform should be `usize`.
///
/// The additional type parameter `WP` is used to select the parameters for the
/// instantanous codes, but the casual user should be happy with the default
/// value. See [`WriteParams`] for more details.
///
/// For additional flexibility, this structures implements [`std::io::Write`].
/// Note that because of coherence rules it is not possible to implement
/// [`std::io::Write`] for a generic [`BitWrite`].

#[derive(Debug)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct BufBitWriter<E: Endianness, WW: WordWrite, WP: WriteParams = DefaultWriteParams> {
    /// The [`WordWrite`] to which we will write words.
    backend: WW,
    /// The buffer where we store bits until we have a word worth of them.
    /// It might be empty, but it is never full.
    /// Only the lower (BE) or upper (LE) `WW::Word::BITS - space_left_in_buffer`
    /// bits are valid: the rest have undefined value.
    buffer: WW::Word,
    /// Number of upper (BE) or lower (LE) free bits in the buffer. It is always greater than zero.
    space_left_in_buffer: usize,
    _marker_endianness: core::marker::PhantomData<(E, WP)>,
}

impl<E: Endianness, WW: WordWrite, WP: WriteParams> BufBitWriter<E, WW, WP>
where
    BufBitWriter<E, WW, WP>: BitWrite<E>,
{
    /// Create a new [`BufBitWriter`] around a [`WordWrite`].
    ///
    /// ### Example
    /// ```
    /// use dsi_bitstream::prelude::*;
    /// let buffer = Vec::<usize>::new();
    /// let word_writer = MemWordWriterVec::new(buffer);
    /// let mut buf_bit_writer = <BufBitWriter<BE, _>>::new(word_writer);
    pub fn new(backend: WW) -> Self {
        Self {
            backend,
            buffer: WW::Word::ZERO,
            space_left_in_buffer: WW::Word::BITS,
            _marker_endianness: core::marker::PhantomData,
        }
    }

    ///  Return the backend, consuming this writer after
    /// [flushing it](BufBitWriter::flush).
    pub fn into_inner(mut self) -> Result<WW, <Self as BitWrite<E>>::Error> {
        self.flush()?;
        // SAFETY: forget(self) prevents double dropping backend
        let backend = unsafe { ptr::read(&self.backend) };
        mem::forget(self);
        Ok(backend)
    }
}

impl<E: Endianness, WW: WordWrite, WP: WriteParams> core::ops::Drop for BufBitWriter<E, WW, WP> {
    fn drop(&mut self) {
        if TypeId::of::<E>() == TypeId::of::<LE>() {
            flush_le(self).unwrap();
        } else {
            // TypeId::of::<E>() = TypeId::of::<BE>()
            flush_be(self).unwrap();
        }
    }
}

/// Helper function flushing a [`BufBitWriter`] in big-endian fashion.
///
/// The endianness is hardwired because the function is called
/// from [`BufBitWriter::drop`] using a check on the
/// [`TypeId`] of the endianness.
fn flush_be<E: Endianness, WW: WordWrite, WP: WriteParams>(
    buf_bit_writer: &mut BufBitWriter<E, WW, WP>,
) -> Result<usize, WW::Error> {
    let to_flush = WW::Word::BITS - buf_bit_writer.space_left_in_buffer;
    if to_flush != 0 {
        buf_bit_writer.buffer <<= buf_bit_writer.space_left_in_buffer;
        buf_bit_writer
            .backend
            .write_word(buf_bit_writer.buffer.to_be())?;
        buf_bit_writer.space_left_in_buffer = WW::Word::BITS;
    }
    buf_bit_writer.backend.flush()?;
    Ok(to_flush)
}

impl<WW: WordWrite, WP: WriteParams> BitWrite<BE> for BufBitWriter<BE, WW, WP>
where
    u64: CastableInto<WW::Word>,
{
    type Error = <WW as WordWrite>::Error;

    fn flush(&mut self) -> Result<usize, Self::Error> {
        flush_be(self)
    }

    #[allow(unused_mut)]
    #[inline]
    fn write_bits(&mut self, mut value: u64, n_bits: usize) -> Result<usize, Self::Error> {
        debug_assert!(n_bits <= 64);
        #[cfg(feature = "checks")]
        assert!(
            value & (1_u128 << n_bits).wrapping_sub(1) as u64 == value,
            "Error: value {} does not fit in {} bits",
            value,
            n_bits
        );
        debug_assert!(self.space_left_in_buffer > 0);

        #[cfg(test)]
        if n_bits < 64 {
            // We put garbage in the higher bits for testing
            value |= u64::MAX << n_bits;
        }

        // Easy way out: we fit the buffer
        if n_bits < self.space_left_in_buffer {
            self.buffer <<= n_bits;
            // Clean up bits higher than n_bits
            self.buffer |= value.cast() & !(WW::Word::MAX << n_bits as u32);
            self.space_left_in_buffer -= n_bits;
            return Ok(n_bits);
        }

        // Load the bottom of the buffer, if necessary, and dump the whole buffer
        self.buffer = self.buffer << (self.space_left_in_buffer - 1) << 1;
        // The first shift discards bits higher than n_bits
        self.buffer |= (value << (64 - n_bits) >> (64 - self.space_left_in_buffer)).cast();
        self.backend.write_word(self.buffer.to_be())?;

        let mut to_write = n_bits - self.space_left_in_buffer;

        for _ in 0..to_write / WW::Word::BITS {
            to_write -= WW::Word::BITS;
            self.backend
                .write_word((value >> to_write).cast().to_be())?;
        }

        self.space_left_in_buffer = WW::Word::BITS - to_write;
        self.buffer = value.cast();
        Ok(n_bits)
    }

    #[inline]
    #[allow(clippy::collapsible_if)]
    fn write_unary(&mut self, mut value: u64) -> Result<usize, Self::Error> {
        debug_assert_ne!(value, u64::MAX);
        debug_assert!(self.space_left_in_buffer > 0);

        let code_length = value + 1;

        // Easy way out: we fit the buffer
        if code_length <= self.space_left_in_buffer as u64 {
            self.space_left_in_buffer -= code_length as usize;
            self.buffer = self.buffer << value << 1;
            self.buffer |= WW::Word::ONE;
            if self.space_left_in_buffer == 0 {
                self.backend.write_word(self.buffer.to_be())?;
                self.space_left_in_buffer = WW::Word::BITS;
            }
            return Ok(code_length as usize);
        }

        self.buffer = self.buffer << (self.space_left_in_buffer - 1) << 1;
        self.backend.write_word(self.buffer.to_be())?;

        value -= self.space_left_in_buffer as u64;

        for _ in 0..value / WW::Word::BITS as u64 {
            self.backend.write_word(WW::Word::ZERO)?;
        }

        value %= WW::Word::BITS as u64;

        if value == WW::Word::BITS as u64 - 1 {
            self.backend.write_word(WW::Word::ONE.to_be())?;
            self.space_left_in_buffer = WW::Word::BITS;
        } else {
            self.buffer = WW::Word::ONE;
            self.space_left_in_buffer = WW::Word::BITS - (value as usize + 1);
        }

        Ok(code_length as usize)
    }

    #[cfg(not(feature = "no_copy_impls"))]
    fn copy_from<F: Endianness, R: BitRead<F>>(
        &mut self,
        bit_read: &mut R,
        mut n: u64,
    ) -> Result<(), CopyError<R::Error, Self::Error>> {
        if n < self.space_left_in_buffer as u64 {
            self.buffer = self.buffer << n
                | bit_read
                    .read_bits(n as usize)
                    .map_err(CopyError::ReadError)?
                    .cast();
            self.space_left_in_buffer -= n as usize;
            return Ok(());
        }

        self.buffer = self.buffer << (self.space_left_in_buffer - 1) << 1
            | bit_read
                .read_bits(self.space_left_in_buffer)
                .map_err(CopyError::ReadError)?
                .cast();
        n -= self.space_left_in_buffer as u64;

        self.backend
            .write_word(self.buffer.to_be())
            .map_err(CopyError::WriteError)?;

        for _ in 0..n / WW::Word::BITS as u64 {
            self.backend
                .write_word(
                    bit_read
                        .read_bits(WW::Word::BITS)
                        .map_err(CopyError::ReadError)?
                        .cast()
                        .to_be(),
                )
                .map_err(CopyError::WriteError)?;
        }

        n %= WW::Word::BITS as u64;
        self.buffer = bit_read
            .read_bits(n as usize)
            .map_err(CopyError::ReadError)?
            .cast();
        self.space_left_in_buffer = WW::Word::BITS - n as usize;

        Ok(())
    }
}

/// Helper function flushing a [`BufBitWriter`] in big-endian fashion.
///
/// The endianness is hardwired because the function is called
/// from [`BufBitWriter::drop`] using a check on the
/// [`TypeId`] of the endianness.
fn flush_le<E: Endianness, WW: WordWrite, WP: WriteParams>(
    buf_bit_writer: &mut BufBitWriter<E, WW, WP>,
) -> Result<usize, WW::Error> {
    let to_flush = WW::Word::BITS - buf_bit_writer.space_left_in_buffer;
    if to_flush != 0 {
        buf_bit_writer.buffer >>= buf_bit_writer.space_left_in_buffer;
        buf_bit_writer
            .backend
            .write_word(buf_bit_writer.buffer.to_le())?;
        buf_bit_writer.space_left_in_buffer = WW::Word::BITS;
    }
    buf_bit_writer.backend.flush()?;
    Ok(to_flush)
}

impl<WW: WordWrite, WP: WriteParams> BitWrite<LE> for BufBitWriter<LE, WW, WP>
where
    u64: CastableInto<WW::Word>,
{
    type Error = <WW as WordWrite>::Error;

    fn flush(&mut self) -> Result<usize, Self::Error> {
        flush_le(self)
    }

    #[inline]
    fn write_bits(&mut self, mut value: u64, n_bits: usize) -> Result<usize, Self::Error> {
        debug_assert!(n_bits <= 64);
        #[cfg(feature = "checks")]
        assert!(
            value & (1_u128 << n_bits).wrapping_sub(1) as u64 == value,
            "Error: value {} does not fit in {} bits",
            value,
            n_bits
        );
        debug_assert!(self.space_left_in_buffer > 0);

        #[cfg(test)]
        if n_bits < 64 {
            // We put garbage in the higher bits for testing
            value |= u64::MAX << n_bits;
        }

        // Easy way out: we fit the buffer
        if n_bits < self.space_left_in_buffer {
            self.buffer >>= n_bits;
            // Clean up bits higher than n_bits
            self.buffer |=
                (value.cast() & !(WW::Word::MAX << n_bits as u32)).rotate_right(n_bits as u32);
            self.space_left_in_buffer -= n_bits;
            return Ok(n_bits);
        }

        // Load the top of the buffer, if necessary, and dump the whole buffer
        self.buffer = self.buffer >> (self.space_left_in_buffer - 1) >> 1;
        self.buffer |= value.cast() << (WW::Word::BITS - self.space_left_in_buffer);
        self.backend.write_word(self.buffer.to_le())?;

        let to_write = n_bits - self.space_left_in_buffer;
        value = value >> (self.space_left_in_buffer - 1) >> 1;

        for _ in 0..to_write / WW::Word::BITS {
            self.backend.write_word(value.cast().to_le())?;
            // This cannot be executed with WW::Word::BITS >= 64
            value >>= WW::Word::BITS;
        }

        self.space_left_in_buffer = WW::Word::BITS - to_write % WW::Word::BITS;
        self.buffer = value.cast().rotate_right(to_write as u32);
        Ok(n_bits)
    }

    #[inline]
    #[allow(clippy::collapsible_if)]
    fn write_unary(&mut self, mut value: u64) -> Result<usize, Self::Error> {
        debug_assert_ne!(value, u64::MAX);
        debug_assert!(self.space_left_in_buffer > 0);

        let code_length = value + 1;

        // Easy way out: we fit the buffer
        if code_length <= self.space_left_in_buffer as u64 {
            self.space_left_in_buffer -= code_length as usize;
            self.buffer = self.buffer >> value >> 1;
            self.buffer |= WW::Word::ONE << (WW::Word::BITS - 1);
            if self.space_left_in_buffer == 0 {
                self.backend.write_word(self.buffer.to_le())?;
                self.space_left_in_buffer = WW::Word::BITS;
            }
            return Ok(code_length as usize);
        }

        self.buffer = self.buffer >> (self.space_left_in_buffer - 1) >> 1;
        self.backend.write_word(self.buffer.to_le())?;

        value -= self.space_left_in_buffer as u64;

        for _ in 0..value / WW::Word::BITS as u64 {
            self.backend.write_word(WW::Word::ZERO)?;
        }

        value %= WW::Word::BITS as u64;

        if value == WW::Word::BITS as u64 - 1 {
            self.backend
                .write_word((WW::Word::ONE << (WW::Word::BITS - 1)).to_le())?;
            self.space_left_in_buffer = WW::Word::BITS;
        } else {
            self.buffer = WW::Word::ONE << (WW::Word::BITS - 1);
            self.space_left_in_buffer = WW::Word::BITS - (value as usize + 1);
        }

        Ok(code_length as usize)
    }

    #[cfg(not(feature = "no_copy_impls"))]

    fn copy_from<F: Endianness, R: BitRead<F>>(
        &mut self,
        bit_read: &mut R,
        mut n: u64,
    ) -> Result<(), CopyError<R::Error, Self::Error>> {
        if n < self.space_left_in_buffer as u64 {
            self.buffer = self.buffer >> n
                | (bit_read
                    .read_bits(n as usize)
                    .map_err(CopyError::ReadError)?)
                .cast()
                .rotate_right(n as u32);
            self.space_left_in_buffer -= n as usize;
            return Ok(());
        }

        self.buffer = self.buffer >> (self.space_left_in_buffer - 1) >> 1
            | (bit_read
                .read_bits(self.space_left_in_buffer)
                .map_err(CopyError::ReadError)?
                .cast())
            .rotate_right(self.space_left_in_buffer as u32);
        n -= self.space_left_in_buffer as u64;

        self.backend
            .write_word(self.buffer.to_le())
            .map_err(CopyError::WriteError)?;

        for _ in 0..n / WW::Word::BITS as u64 {
            self.backend
                .write_word(
                    bit_read
                        .read_bits(WW::Word::BITS)
                        .map_err(CopyError::ReadError)?
                        .cast()
                        .to_le(),
                )
                .map_err(CopyError::WriteError)?;
        }

        n %= WW::Word::BITS as u64;
        self.buffer = bit_read
            .read_bits(n as usize)
            .map_err(CopyError::ReadError)?
            .cast()
            .rotate_right(n as u32);
        self.space_left_in_buffer = WW::Word::BITS - n as usize;

        Ok(())
    }
}

impl<WW: WordWrite, WP: WriteParams> std::io::Write for BufBitWriter<BE, WW, WP>
where
    u64: CastableInto<WW::Word>,
{
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        let mut iter = buf.chunks_exact(WW::Word::BYTES);

        for word in &mut iter {
            self.write_bits(u64::from_be_bytes(word.try_into().unwrap()), 64)
                .map_err(|_| {
                    std::io::Error::new(std::io::ErrorKind::Other, "Could not write bits to stream")
                })?;
        }

        let rem = iter.remainder();
        if !rem.is_empty() {
            let mut word = 0;
            let bits = rem.len() * 8;
            for byte in rem.iter() {
                word <<= 8;
                word |= *byte as u64;
            }
            self.write_bits(word, bits).map_err(|_| {
                std::io::Error::new(std::io::ErrorKind::Other, "Could not write bits to stream")
            })?;
        }

        Ok(buf.len())
    }

    fn flush(&mut self) -> std::io::Result<()> {
        flush_be(self).map_err(|_| {
            std::io::Error::new(std::io::ErrorKind::Other, "Could not flush bits to stream")
        })?;
        Ok(())
    }
}

impl<WW: WordWrite, WP: WriteParams> std::io::Write for BufBitWriter<LE, WW, WP>
where
    u64: CastableInto<WW::Word>,
{
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        let mut iter = buf.chunks_exact(WW::Word::BYTES);

        for word in &mut iter {
            self.write_bits(u64::from_le_bytes(word.try_into().unwrap()), 64)
                .map_err(|_| {
                    std::io::Error::new(std::io::ErrorKind::Other, "Could not write bits to stream")
                })?;
        }

        let rem = iter.remainder();
        if !rem.is_empty() {
            let mut word = 0;
            let bits = rem.len() * 8;
            for byte in rem.iter().rev() {
                word <<= 8;
                word |= *byte as u64;
            }
            self.write_bits(word, bits).map_err(|_| {
                std::io::Error::new(std::io::ErrorKind::Other, "Could not write bits to stream")
            })?;
        }

        Ok(buf.len())
    }

    fn flush(&mut self) -> std::io::Result<()> {
        flush_le(self).map_err(|_| {
            std::io::Error::new(std::io::ErrorKind::Other, "Could not flush bits to stream")
        })?;
        Ok(())
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::prelude::MemWordWriterVec;
    use std::io::Write;

    #[test]
    fn test_write() {
        let data = [
            0x90, 0x2d, 0xd0, 0x26, 0xdf, 0x89, 0xbb, 0x7e, 0x3a, 0xd6, 0xc6, 0x96, 0x73, 0xe9,
            0x9d, 0xc9, 0x2a, 0x77, 0x82, 0xa9, 0xe6, 0x4b, 0x53, 0xcc, 0x83, 0x80, 0x4a, 0xf3,
            0xcd, 0xe3, 0x50, 0x4e, 0x45, 0x4a, 0x3a, 0x42, 0x00, 0x4b, 0x4d, 0xbe, 0x4c, 0x88,
            0x24, 0xf2, 0x4b, 0x6b, 0xbd, 0x79, 0xeb, 0x74, 0xbc, 0xe8, 0x7d, 0xff, 0x4b, 0x3d,
            0xa7, 0xd6, 0x0d, 0xef, 0x9c, 0x5b, 0xb3, 0xec, 0x94, 0x97, 0xcc, 0x8b, 0x41, 0xe1,
            0x9c, 0xcc, 0x1a, 0x03, 0x58, 0xc4, 0xfb, 0xd0, 0xc0, 0x10, 0xe2, 0xa0, 0xc9, 0xac,
            0xa7, 0xbb, 0x50, 0xf6, 0x5c, 0x87, 0x68, 0x0f, 0x42, 0x93, 0x3f, 0x2e, 0x28, 0x28,
            0x76, 0x83, 0x9b, 0xeb, 0x12, 0xe0, 0x4f, 0xc5, 0xb0, 0x8d, 0x14, 0xda, 0x3b, 0xdf,
            0xd3, 0x4b, 0x80, 0xd1, 0xfc, 0x87, 0x85, 0xae, 0x54, 0xc7, 0x45, 0xc9, 0x38, 0x43,
            0xa7, 0x9f, 0xdd, 0xa9, 0x71, 0xa7, 0x52, 0x36, 0x82, 0xff, 0x49, 0x55, 0xdb, 0x84,
            0xc2, 0x95, 0xad, 0x45, 0x80, 0xc6, 0x02, 0x80, 0xf8, 0xfc, 0x86, 0x79, 0xae, 0xb9,
            0x57, 0xe7, 0x3b, 0x33, 0x64, 0xa8,
        ];

        for i in 0..data.len() {
            let mut buffer = Vec::<u64>::new();
            let mut writer = BufBitWriter::<BE, _>::new(MemWordWriterVec::new(&mut buffer));

            writer.write_all(&data[..i]).unwrap();
            std::io::Write::flush(&mut writer).unwrap();

            let buffer = writer.into_inner().unwrap().into_inner();
            assert_eq!(unsafe { &buffer.align_to::<u8>().1[..i] }, &data[..i]);

            let mut buffer = Vec::<u64>::new();
            let mut writer = BufBitWriter::<LE, _>::new(MemWordWriterVec::new(&mut buffer));

            writer.write_all(&data[..i]).unwrap();
            std::io::Write::flush(&mut writer).unwrap();

            let buffer = writer.into_inner().unwrap().into_inner();
            assert_eq!(unsafe { &buffer.align_to::<u8>().1[..i] }, &data[..i]);
        }
    }

    macro_rules! test_buf_bit_writer {
        ($f: ident, $word:ty) => {
            #[test]
            fn $f() -> Result<(), Box<dyn std::error::Error + Send + Sync + 'static>> {
                #[allow(unused_imports)]
                use crate::{
                    codes::{GammaRead, GammaWrite},
                    prelude::{
                        len_delta, len_gamma, BufBitReader, DeltaRead, DeltaWrite, MemWordReader,
                    },
                };
                use rand::Rng;
                use rand::{rngs::SmallRng, SeedableRng};

                let mut buffer_be: Vec<$word> = vec![];
                let mut buffer_le: Vec<$word> = vec![];
                let mut big = BufBitWriter::<BE, _>::new(MemWordWriterVec::new(&mut buffer_be));
                let mut little = BufBitWriter::<LE, _>::new(MemWordWriterVec::new(&mut buffer_le));

                let mut r = SmallRng::seed_from_u64(0);
                const ITER: usize = 1_000_000;

                for _ in 0..ITER {
                    let value = r.gen_range(0..128);
                    assert_eq!(big.write_gamma(value)?, len_gamma(value));
                    let value = r.gen_range(0..128);
                    assert_eq!(little.write_gamma(value)?, len_gamma(value));
                    let value = r.gen_range(0..128);
                    assert_eq!(big.write_gamma(value)?, len_gamma(value));
                    let value = r.gen_range(0..128);
                    assert_eq!(little.write_gamma(value)?, len_gamma(value));
                    let value = r.gen_range(0..128);
                    assert_eq!(big.write_delta(value)?, len_delta(value));
                    let value = r.gen_range(0..128);
                    assert_eq!(little.write_delta(value)?, len_delta(value));
                    let value = r.gen_range(0..128);
                    assert_eq!(big.write_delta(value)?, len_delta(value));
                    let value = r.gen_range(0..128);
                    assert_eq!(little.write_delta(value)?, len_delta(value));
                    let n_bits = r.gen_range(0..=64);
                    if n_bits == 0 {
                        big.write_bits(0, 0)?;
                    } else {
                        big.write_bits(r.gen::<u64>() & u64::MAX >> 64 - n_bits, n_bits)?;
                    }
                    let n_bits = r.gen_range(0..=64);
                    if n_bits == 0 {
                        little.write_bits(0, 0)?;
                    } else {
                        little.write_bits(r.gen::<u64>() & u64::MAX >> 64 - n_bits, n_bits)?;
                    }
                    let value = r.gen_range(0..128);
                    assert_eq!(big.write_unary(value)?, value as usize + 1);
                    let value = r.gen_range(0..128);
                    assert_eq!(little.write_unary(value)?, value as usize + 1);
                }

                drop(big);
                drop(little);

                type ReadWord = u16;
                let be_trans: &[ReadWord] = unsafe {
                    core::slice::from_raw_parts(
                        buffer_be.as_ptr() as *const ReadWord,
                        buffer_be.len()
                            * (core::mem::size_of::<$word>() / core::mem::size_of::<ReadWord>()),
                    )
                };
                let le_trans: &[ReadWord] = unsafe {
                    core::slice::from_raw_parts(
                        buffer_le.as_ptr() as *const ReadWord,
                        buffer_le.len()
                            * (core::mem::size_of::<$word>() / core::mem::size_of::<ReadWord>()),
                    )
                };

                let mut big_buff = BufBitReader::<BE, _>::new(MemWordReader::new(be_trans));
                let mut little_buff = BufBitReader::<LE, _>::new(MemWordReader::new(le_trans));

                let mut r = SmallRng::seed_from_u64(0);

                for _ in 0..ITER {
                    assert_eq!(big_buff.read_gamma()?, r.gen_range(0..128));
                    assert_eq!(little_buff.read_gamma()?, r.gen_range(0..128));
                    assert_eq!(big_buff.read_gamma()?, r.gen_range(0..128));
                    assert_eq!(little_buff.read_gamma()?, r.gen_range(0..128));
                    assert_eq!(big_buff.read_delta()?, r.gen_range(0..128));
                    assert_eq!(little_buff.read_delta()?, r.gen_range(0..128));
                    assert_eq!(big_buff.read_delta()?, r.gen_range(0..128));
                    assert_eq!(little_buff.read_delta()?, r.gen_range(0..128));
                    let n_bits = r.gen_range(0..=64);
                    if n_bits == 0 {
                        assert_eq!(big_buff.read_bits(0)?, 0);
                    } else {
                        assert_eq!(
                            big_buff.read_bits(n_bits)?,
                            r.gen::<u64>() & u64::MAX >> 64 - n_bits
                        );
                    }
                    let n_bits = r.gen_range(0..=64);
                    if n_bits == 0 {
                        assert_eq!(little_buff.read_bits(0)?, 0);
                    } else {
                        assert_eq!(
                            little_buff.read_bits(n_bits)?,
                            r.gen::<u64>() & u64::MAX >> 64 - n_bits
                        );
                    }

                    assert_eq!(big_buff.read_unary()?, r.gen_range(0..128));
                    assert_eq!(little_buff.read_unary()?, r.gen_range(0..128));
                }

                Ok(())
            }
        };
    }

    test_buf_bit_writer!(test_u128, u128);
    test_buf_bit_writer!(test_u64, u64);
    test_buf_bit_writer!(test_u32, u32);

    test_buf_bit_writer!(test_u16, u16);
    test_buf_bit_writer!(test_usize, usize);
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/lib.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

#![doc = include_str!("../README.md")]
#![cfg_attr(not(feature = "std"), no_std)]
#[cfg(feature = "alloc")]
extern crate alloc;

pub mod codes;
pub mod impls;
pub mod traits;
pub mod utils;

#[cfg(feature = "fuzz")]
pub mod fuzz;

pub mod prelude {
    pub use crate::codes::*;
    pub use crate::impls::*;
    pub use crate::traits::*;
    pub use crate::utils::*;
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/traits/endianness.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

/// Inner private trait used to make implementing [`Endianness`]
/// impossible for other structs.
mod private {
    /// This is a [SealedTrait](https://predr.ag/blog/definitive-guide-to-sealed-traits-in-rust/).
    pub trait Endianness: 'static {
        /// The name of the endianness.
        const _NAME: &'static str;
        /// Whether the endianness is little-endian.
        const _IS_LITTLE: bool;
        /// Whether the endianness is big-endian.
        const _IS_BIG: bool;
    }
}

impl<T: private::Endianness> Endianness for T {
    const NAME: &'static str = T::_NAME;
    const IS_LITTLE: bool = T::_IS_LITTLE;
    const IS_BIG: bool = T::_IS_BIG;
}

/// Marker trait for endianness selector types.
///
/// Its only implementations are [`LittleEndian`] and [`BigEndian`]
///
/// Note that in principle marker traits are not necessary to use
/// selector types, but they are useful to avoid that the user specifies
/// a nonsensical type, and to document the meaning of type parameters.
pub trait Endianness: private::Endianness {
    /// The name of the endianness.
    const NAME: &'static str;
    /// Whether the endianness is little-endian.
    const IS_LITTLE: bool;
    /// Whether the endianness is big-endian.
    const IS_BIG: bool;
}

impl core::fmt::Display for LE {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(LE::NAME)
    }
}

impl core::fmt::Display for BE {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(BE::NAME)
    }
}

/// Selector type for little-endian streams.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct LittleEndian;

/// Selector type for big-endian streams.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct BigEndian;

impl private::Endianness for LittleEndian {
    const _NAME: &'static str = "little";
    const _IS_LITTLE: bool = true;
    const _IS_BIG: bool = false;
}

impl private::Endianness for BigEndian {
    const _NAME: &'static str = "big";
    const _IS_LITTLE: bool = false;
    const _IS_BIG: bool = true;
}

/// Alias for [`BigEndian`]
pub type BE = BigEndian;

/// Alias for [`LittleEndian`]
pub type LE = LittleEndian;

#[cfg(target_endian = "little")]
/// A type alias for the native endianness of the target platform.
pub type NativeEndian = LittleEndian;
#[cfg(target_endian = "big")]
/// A type alias for the native endianness of the target platform.
pub type NativeEndian = BigEndian;

/// An Alias for [`NativeEndian`]
pub type NE = NativeEndian;

```````

`/home/zom/Github/dsi-bitstream-rs/src/traits/mod.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

/*!

Traits for operating on streams of bits.

We provide three bit-based traits, [`BitRead`], [`BitWrite`], and
[`BitSeek`], analogous to [`std::io::Read`], [`std::io::Write`],
and [`std::io::Seek`], respectively. They provide read/write operations
on fixed-width blocks of bits and unary codes. More complex operations,
such as [reading instantaneous codes](crate::codes::GammaReadParam),
are built on these basic traits.

The endianness of a bit stream specified by using the selector types
[`BigEndian`] (AKA [`LE`]) and [`LittleEndian`] (AKA [`BE`]), which
are the only implementations of the sealed marker trait [`Endianness`].

The implementations we provide for these traits (e.g.,
[`BufBitReader`](crate::impls::BufBitReader)) are based on
[`WordRead`], [`WordWrite`], and [`WordSeek`], which provide word-based operations,
as reading or writing multiple bytes at a time is usually much faster than
reading or writing single bytes, in particular when interacting with memory.
For example, [`MemWordRead`](crate::impls::MemWordReader) is a [`WordRead`]
that reads word-by-word from a slice.

All traits have an internal error type `Error`, which usually propagates the
error of the underlying backend. However, in some cases (e.g., [`MemWordRead`](crate::impls::MemWordReader)
with infinite zero extension) the error type is [`Infallible`](core::convert::Infallible),
in which case the compiler is able to perform several further optimizations.

Note that methods returning a [`Result`] will return a [`Result::Err`] variant
only if there is an error in the underlying backend: errors in the parameters to the
methods will generally result in panics.

## Bit and byte order

The endianness parameter specifies at the same byte the endianness of the byte
stream and of the bits in each byte: in the little-endian case, the first bit
of the stream is the least significant bit of the first byte, while in the
big-endian case it is the most significant bit of the first byte. Albeit in principle
one can mix independently the two orders, having the same order for both bytes
and bits is usually more convenient and makes for more efficient implementations.

Byte-level endianness is used to read memory word-by-word, greatly reducing the number
of memory accesses when reading from slices. However, it is important to note that
fixed-width values have thair least significant bit always stored at the lowest bit position,
independently of endianness, as current CPUs always use big-endian bit order.
In particular, reversing the order of the bits of each byte of a file containing
a sequence of fixed-width integers or instantaneous codes
will not in general yield a file containing the same sequence of integers or codes
with the opposite endianness.

For example, if we write just the value 6 to a big-endian bit stream, we will
get as first byte `110xxxxx`, while if we write it to a little-endian bit stream
we will obtain the byte `xxxxx110`. Clearly, reversing the order of the bits
of each byte will not give the other byte. (There are however a few exceptions
for which reversing works, such as palindromic bit writes and unary codes.)

The situation becomes even more intricated when considering instantaneous codes.
For example, the minimal(-redundancy) binary code of order seven has
code words `00`, `010`, `011`, `100`, `101`, `110`, and `111`.
To decode such a code efficiently, one first reads two
bits, and then decides, based on their value, whether to read a further
bit and add it on the right. But this means
that we have to encode `011` as `011xxxx` in the big-endian case, and
as `xxxx101` in the little-endian case. If we were to encode the
little-endian case as `xxxx110`, the first two bits we read would have
a reversed representation.

*/

mod bits;
pub use bits::*;

mod words;
pub use words::*;

mod endianness;
pub use endianness::*;

```````

`/home/zom/Github/dsi-bitstream-rs/src/traits/words.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

use std::error::Error;

use common_traits::*;

/// This is a trait alias for all the properties that we need words of memory
/// read and wrote by either a [`WordRead`] or [`WordWrite`], respectively.
pub trait Word: UnsignedInt + ToBytes + FromBytes + FiniteRangeNumber {}
impl<W: UnsignedInt + ToBytes + FromBytes + FiniteRangeNumber> Word for W {}

/// Sequential, streaming word-by-word reads.
pub trait WordRead {
    type Error: Error + Send + Sync + 'static;

    /// The word type (the type of the result of [`WordRead::read_word`]).
    type Word: Word;

    /// Read a word and advance the current position.
    fn read_word(&mut self) -> Result<Self::Word, Self::Error>;
}

/// Sequential, streaming word-by-word writes.
pub trait WordWrite {
    type Error: Error + Send + Sync + 'static;

    /// The word type (the type of the argument of [`WordWrite::write_word`]).
    type Word: Word;

    /// Write a word and advance the current position.
    fn write_word(&mut self, word: Self::Word) -> Result<(), Self::Error>;

    /// Flush the stream.
    fn flush(&mut self) -> Result<(), Self::Error>;
}

/// Seekability for [`WordRead`] and [`WordWrite`] streams.
pub trait WordSeek {
    type Error: Error + Send + Sync + 'static;
    /// Get the current position in words from the start of the file.
    fn word_pos(&mut self) -> Result<u64, Self::Error>;

    /// Set the current position in words from the start of the file to `word_pos`.
    fn set_word_pos(&mut self, word_pos: u64) -> Result<(), Self::Error>;
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/traits/bits.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Tommaso Fontana
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

use core::fmt::{Display, Formatter};
use std::error::Error;

use crate::{
    prelude::{delta_tables, gamma_tables, zeta_tables},
    traits::*,
};
use common_traits::CastableInto;

pub trait Peek<const N: usize> {}
macro_rules! impl_peekable {
    ($($n:literal),*) => {$(
        impl<T: Peek<{$n + 1}>> Peek<$n> for T {}
    )*};
}

impl_peekable!(
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
    26, 27, 28, 29, 30, 31, 32
);

/// The error returned by the bit copy methods [`BitRead::copy_to`] and [`BitWrite::copy_from`].
///
/// It can be a read or a write error, depending on which stream (source or
/// destination) generated the error.
#[derive(Debug, Clone)]
pub enum CopyError<RE: Error + Send + Sync + 'static, WE: Error + Send + Sync + 'static> {
    ReadError(RE),
    WriteError(WE),
}

impl<RE: Error + Send + Sync + 'static, WE: Error + Send + Sync + 'static> Display
    for CopyError<RE, WE>
{
    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
        match self {
            CopyError::ReadError(e) => write!(f, "Read error while copying: {}", e),
            CopyError::WriteError(e) => write!(f, "Write error while copying: {}", e),
        }
    }
}

impl<RE: Error + Send + Sync + 'static, WE: Error + Send + Sync + 'static> Error
    for CopyError<RE, WE>
{
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            CopyError::ReadError(e) => Some(e),
            CopyError::WriteError(e) => Some(e),
        }
    }
}

/// Sequential, streaming bit-by-bit reads.
///
/// This trait specify basic operation over which codes can be implemented by
/// traits such as [`GammaReadParam`](crate::codes::GammaReadParam).
///
/// To read quickly complex codes, such traits may use the
/// [`peek_bits`](BitRead::peek_bits) method to read a few bits in advance and
/// then use a table to decode them. For this to happen correctly,
/// [`peek_bits`](BitRead::peek_bits) must return a sufficient number of bits.
/// It is unfortunately difficult at the time being to check statically that
/// this is the case, but in test mode an assertion will be triggered if the
/// number of bits returned by [`peek_bits`](BitRead::peek_bits) is not
/// sufficient.
///
/// Implementors are invited to call [`check_tables`] at construction time to
/// provide a warning to the user if the peek word is not large enough.
///
/// Please see the documentation of the [`impls`](crate::impls) module for more
/// details.
pub trait BitRead<E: Endianness> {
    type Error: Error + Send + Sync + 'static;

    /// The type we can read from the stream without advancing.
    type PeekWord: CastableInto<u64>;

    /// Read `n` bits and return them in the lowest bits.
    ///
    /// Implementors should check the value of `n` when in test mode
    /// and panic if it is greater than 64.
    fn read_bits(&mut self, n: usize) -> Result<u64, Self::Error>;

    /// Peeks at `n` bits without advancing the stream position.
    /// `n` must be nonzero, and at most `PeekWord::BITS`.
    fn peek_bits(&mut self, n: usize) -> Result<Self::PeekWord, Self::Error>;

    /// Skip `n` bits from the stream.
    ///
    /// When moving forward by a small amount of bits, this method might be
    /// more efficient than [`BitSeek::set_bit_pos`].
    fn skip_bits(&mut self, n: usize) -> Result<(), Self::Error>;

    #[doc(hidden)]
    /// Skip bits form the stream after a call to [`BitRead::peek_bits`].
    ///
    /// This is an internal optimization used to skip bits we know
    /// are already in some internal buffer as we [peeked](BitRead::peek_bits)
    /// at them. Please don't use.
    fn skip_bits_after_table_lookup(&mut self, n: usize);

    /// Read a unary code.
    fn read_unary(&mut self) -> Result<u64, Self::Error>;

    fn copy_to<F: Endianness, W: BitWrite<F>>(
        &mut self,
        bit_write: &mut W,
        mut n: u64,
    ) -> Result<(), CopyError<Self::Error, W::Error>> {
        while n > 0 {
            let to_read = core::cmp::min(n, 64) as usize;
            let read = self.read_bits(to_read).map_err(CopyError::ReadError)?;
            bit_write
                .write_bits(read, to_read)
                .map_err(CopyError::WriteError)?;
            n -= to_read as u64;
        }
        Ok(())
    }
}

/// Sequential, streaming bit-by-bit writes.
///
/// This trait specify basic operation over which codes can be implemented
/// by traits such as [`crate::codes::GammaWriteParam`].
pub trait BitWrite<E: Endianness> {
    type Error: Error + Send + Sync + 'static;

    /// Write the lowest `n` bits of `value` to the stream and return the number
    /// of bits written, that is, `n`.
    ///
    ///
    /// Implementors should check the value of `n` in test mode and panic if it
    /// is greater than 64. Moreover, if the feature `checks` is enabled they
    /// should check that the remaining bits of `value` are zero.
    fn write_bits(&mut self, value: u64, n: usize) -> Result<usize, Self::Error>;

    /// Write `value` as a unary code to the stream and return the number of
    /// bits written, that is, `value` plus one.
    fn write_unary(&mut self, value: u64) -> Result<usize, Self::Error>;

    /// Flush the buffer, consuming the bit stream.
    ///
    /// Returns the number of bits written from the bit buffer (not including padding).
    fn flush(&mut self) -> Result<usize, Self::Error>;

    fn copy_from<F: Endianness, R: BitRead<F>>(
        &mut self,
        bit_read: &mut R,
        mut n: u64,
    ) -> Result<(), CopyError<R::Error, Self::Error>> {
        while n > 0 {
            let to_read = core::cmp::min(n, 64) as usize;
            let read = bit_read.read_bits(to_read).map_err(CopyError::ReadError)?;
            self.write_bits(read, to_read)
                .map_err(CopyError::WriteError)?;
            n -= to_read as u64;
        }
        Ok(())
    }
}

/// Seekability for [`BitRead`] and [`BitWrite`] streams.
pub trait BitSeek {
    type Error: Error + Send + Sync + 'static;
    /// Get the current position in bits from the start of the stream.
    fn bit_pos(&mut self) -> Result<u64, Self::Error>;

    /// Set the current position in bits from the start of the stream to `bit_pos`.
    ///
    /// Note that moving forward by a small amount of bits may be accomplished
    /// more efficiently by calling [`BitRead::skip_bits`].
    fn set_bit_pos(&mut self, bit_pos: u64) -> Result<(), Self::Error>;
}

/// Utility function to check that the peek word is large enough.
///
/// It **strongly suggested** that this function is called by the
/// creation methods of types implementing [`BitRead`].
pub fn check_tables(peek_bits: usize) {
    if peek_bits < gamma_tables::READ_BITS {
        eprintln!(
            "DANGER: your BitRead can peek at {} bits, but the tables for γ codes use {} bits",
            peek_bits,
            gamma_tables::READ_BITS
        );
    }
    if peek_bits < delta_tables::READ_BITS {
        eprintln!(
            "DANGER: your BitRead can peek at {} bits, but the tables for δ codes use {} bits",
            peek_bits,
            delta_tables::READ_BITS
        );
    }
    if peek_bits < zeta_tables::READ_BITS {
        eprintln!(
            "DANGER: your BitRead can peek at {} bits, but the tables for ζ₃ codes use {} bits",
            peek_bits,
            zeta_tables::READ_BITS
        );
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/utils/stats.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 * SPDX-FileCopyrightText: 2024 Tommaso Fontana
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */
#[cfg(feature = "mem_dbg")]
use mem_dbg::{MemDbg, MemSize};

use crate::prelude::code::{CodeRead, CodeReadDispatch, CodeWrite, CodeWriteDispatch};
use crate::prelude::Endianness;
use crate::prelude::{
    len_delta, len_exp_golomb, len_gamma, len_golomb, len_omega, len_pi, len_pi_web, len_rice,
    len_vbyte, len_zeta, Code, ReadCodes, WriteCodes,
};
use anyhow::Result;
use core::error::Error;
use core::fmt::Debug;
use std::sync::Mutex;

/// Keeps track of the space needed to store a stream of integers using
/// different codes.
///
/// This structure can be used to determine empirically which code provides the
/// best compression for a given stream. You have to [update the
/// structure](Self::update) with the integers in the stream; at any time, you
/// can examine the statistics or call [`best_code`](Self::best_code) to get the
/// best code.
#[derive(Debug, Copy, Clone)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct CodesStats<
    // How many ζ codes to consider.
    const ZETA: usize = 10,
    // How many Golomb codes to consider.
    const GOLOMB: usize = 20,
    // How many Exponential Golomb codes to consider.
    const EXP_GOLOMB: usize = 10,
    // How many Rice codes to consider.
    const RICE: usize = 10,
    // How many Pi and Pi web codes to consider.
    const PI: usize = 10,
> {
    pub unary: u64,
    pub gamma: u64,
    pub delta: u64,
    pub omega: u64,
    pub vbyte: u64,
    pub zeta: [u64; ZETA],
    pub golomb: [u64; GOLOMB],
    pub exp_golomb: [u64; EXP_GOLOMB],
    pub rice: [u64; RICE],
    pub pi: [u64; PI],
    pub pi_web: [u64; PI],
}

impl<
        const ZETA: usize,
        const GOLOMB: usize,
        const EXP_GOLOMB: usize,
        const RICE: usize,
        const PI: usize,
    > core::default::Default for CodesStats<ZETA, GOLOMB, EXP_GOLOMB, RICE, PI>
{
    fn default() -> Self {
        Self {
            unary: 0,
            gamma: 0,
            delta: 0,
            omega: 0,
            vbyte: 0,
            zeta: [0; ZETA],
            golomb: [0; GOLOMB],
            exp_golomb: [0; EXP_GOLOMB],
            rice: [0; RICE],
            pi: [0; PI],
            pi_web: [0; PI],
        }
    }
}

impl<
        const ZETA: usize,
        const GOLOMB: usize,
        const EXP_GOLOMB: usize,
        const RICE: usize,
        const PI: usize,
    > CodesStats<ZETA, GOLOMB, EXP_GOLOMB, RICE, PI>
{
    /// Update the stats with the lengths of the codes for `n` and return
    /// `n` for convenience.
    pub fn update(&mut self, n: u64) -> u64 {
        self.update_many(n, 1)
    }

    #[inline]
    pub fn update_many(&mut self, n: u64, count: u64) -> u64 {
        self.unary += (n + 1) * count;
        self.gamma += len_gamma(n) as u64 * count;
        self.delta += len_delta(n) as u64 * count;
        self.omega += len_omega(n) as u64 * count;
        self.vbyte += len_vbyte(n) as u64 * count;

        for (k, val) in self.zeta.iter_mut().enumerate() {
            *val += (len_zeta(n, (k + 1) as _) as u64) * count;
        }
        for (b, val) in self.golomb.iter_mut().enumerate() {
            *val += (len_golomb(n, (b + 1) as _) as u64) * count;
        }
        for (k, val) in self.exp_golomb.iter_mut().enumerate() {
            *val += (len_exp_golomb(n, k as _) as u64) * count;
        }
        for (log2_b, val) in self.rice.iter_mut().enumerate() {
            *val += (len_rice(n, log2_b as _) as u64) * count;
        }
        // +2 because π0 = gamma and π1 = zeta_2
        for (k, val) in self.pi.iter_mut().enumerate() {
            *val += (len_pi(n, (k + 2) as _) as u64) * count;
        }
        for (k, val) in self.pi_web.iter_mut().enumerate() {
            *val += (len_pi_web(n, k as _) as u64) * count;
        }
        n
    }

    // Combines additively this stats with another one.
    pub fn add(&mut self, rhs: &Self) {
        self.unary += rhs.unary;
        self.gamma += rhs.gamma;
        self.delta += rhs.delta;
        self.omega += rhs.omega;
        self.vbyte += rhs.vbyte;
        for (a, b) in self.zeta.iter_mut().zip(rhs.zeta.iter()) {
            *a += *b;
        }
        for (a, b) in self.golomb.iter_mut().zip(rhs.golomb.iter()) {
            *a += *b;
        }
        for (a, b) in self.exp_golomb.iter_mut().zip(rhs.exp_golomb.iter()) {
            *a += *b;
        }
        for (a, b) in self.rice.iter_mut().zip(rhs.rice.iter()) {
            *a += *b;
        }
        for (a, b) in self.pi.iter_mut().zip(rhs.pi.iter()) {
            *a += *b;
        }
        for (a, b) in self.pi_web.iter_mut().zip(rhs.pi_web.iter()) {
            *a += *b;
        }
    }

    /// Return the best code for the stream and its space usage.
    pub fn best_code(&self) -> (Code, u64) {
        let mut best = self.unary;
        let mut best_code = Code::Unary;

        macro_rules! check {
            ($code:expr, $len:expr) => {
                if $len < best {
                    best = $len;
                    best_code = $code;
                }
            };
        }

        check!(Code::Gamma, self.gamma);
        check!(Code::Delta, self.delta);
        check!(Code::Omega, self.omega);
        check!(Code::VByte, self.vbyte);

        for (k, val) in self.zeta.iter().enumerate() {
            check!(Code::Zeta { k: (k + 1) as _ }, *val);
        }
        for (b, val) in self.golomb.iter().enumerate() {
            check!(Code::Golomb { b: (b + 1) as _ }, *val);
        }
        for (k, val) in self.exp_golomb.iter().enumerate() {
            check!(Code::ExpGolomb { k: k as _ }, *val);
        }
        for (log2_b, val) in self.rice.iter().enumerate() {
            check!(
                Code::Rice {
                    log2_b: log2_b as _
                },
                *val
            );
        }
        for (k, val) in self.pi.iter().enumerate() {
            check!(Code::Pi { k: (k + 2) as _ }, *val);
        }
        for (k, val) in self.pi_web.iter().enumerate() {
            check!(Code::PiWeb { k: k as _ }, *val);
        }

        (best_code, best)
    }
}

/// Combines additively this stats with another one.
impl<
        const ZETA: usize,
        const GOLOMB: usize,
        const EXP_GOLOMB: usize,
        const RICE: usize,
        const PI: usize,
    > core::ops::AddAssign for CodesStats<ZETA, GOLOMB, EXP_GOLOMB, RICE, PI>
{
    fn add_assign(&mut self, rhs: Self) {
        self.add(&rhs);
    }
}

/// Combines additively this stats with another one creating a new one.
impl<
        const ZETA: usize,
        const GOLOMB: usize,
        const EXP_GOLOMB: usize,
        const RICE: usize,
        const PI: usize,
    > core::ops::Add for CodesStats<ZETA, GOLOMB, EXP_GOLOMB, RICE, PI>
{
    type Output = Self;

    fn add(self, rhs: Self) -> Self {
        let mut res = self;
        res += rhs;
        res
    }
}

/// Allow to call .sum() on an iterator of CodesStats.
impl<
        const ZETA: usize,
        const GOLOMB: usize,
        const EXP_GOLOMB: usize,
        const RICE: usize,
        const PI: usize,
    > core::iter::Sum for CodesStats<ZETA, GOLOMB, EXP_GOLOMB, RICE, PI>
{
    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {
        iter.fold(Self::default(), |a, b| a + b)
    }
}

#[derive(Debug)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
/// A struct that can wrap `Code` and compute `CodesStats` for a given stream.
pub struct CodesStatsWrapper<
    W,
    // How many ζ codes to consider.
    const ZETA: usize = 10,
    // How many Golomb codes to consider.
    const GOLOMB: usize = 20,
    // How many Exponential Golomb codes to consider.
    const EXP_GOLOMB: usize = 10,
    // How many Rice codes to consider.
    const RICE: usize = 10,
    // How many Pi and Pi web codes to consider.
    const PI: usize = 10,
> {
    // TODO!: figure out how we can do this without a lock.
    // This is needed because the `CodeRead` and `CodeWrite` traits must have
    // &self and not &mut self.
    stats: Mutex<CodesStats<ZETA, GOLOMB, EXP_GOLOMB, RICE, PI>>,
    wrapped: W,
}

impl<
        W,
        const ZETA: usize,
        const GOLOMB: usize,
        const EXP_GOLOMB: usize,
        const RICE: usize,
        const PI: usize,
    > CodesStatsWrapper<W, ZETA, GOLOMB, EXP_GOLOMB, RICE, PI>
{
    /// Create a new `CodesStatsWrapper` with the given wrapped value.
    pub fn new(wrapped: W) -> Self {
        Self {
            stats: Mutex::new(CodesStats::default()),
            wrapped,
        }
    }

    /// Returns a reference to the stats.
    pub fn stats(&self) -> &Mutex<CodesStats<ZETA, GOLOMB, EXP_GOLOMB, RICE, PI>> {
        &self.stats
    }

    /// Consumes the wrapper and returns the inner wrapped value and the stats.
    pub fn into_inner(self) -> (W, CodesStats<ZETA, GOLOMB, EXP_GOLOMB, RICE, PI>) {
        (self.wrapped, self.stats.into_inner().unwrap())
    }
}

impl<
        W,
        const ZETA: usize,
        const GOLOMB: usize,
        const EXP_GOLOMB: usize,
        const RICE: usize,
        const PI: usize,
    > CodeRead for CodesStatsWrapper<W, ZETA, GOLOMB, EXP_GOLOMB, RICE, PI>
where
    W: CodeRead,
{
    type Error<CRE> = W::Error<CRE>
    where
        CRE: Error + Debug + Send + Sync + 'static;
    #[inline]
    fn read<E: Endianness, CR: ReadCodes<E> + ?Sized>(
        &self,
        reader: &mut CR,
    ) -> Result<u64, Self::Error<CR::Error>> {
        let res = self.wrapped.read(reader)?;
        self.stats.lock().unwrap().update(res);
        Ok(res)
    }
}

impl<
        W,
        const ZETA: usize,
        const GOLOMB: usize,
        const EXP_GOLOMB: usize,
        const RICE: usize,
        const PI: usize,
        E: Endianness,
        CR: ReadCodes<E> + ?Sized,
    > CodeReadDispatch<E, CR> for CodesStatsWrapper<W, ZETA, GOLOMB, EXP_GOLOMB, RICE, PI>
where
    W: CodeReadDispatch<E, CR>,
{
    type Error<CRE> = W::Error<CRE>
    where
        CRE: Error + Debug + Send + Sync + 'static;
    #[inline]
    fn read_dispatch(&self, reader: &mut CR) -> Result<u64, Self::Error<CR::Error>> {
        let res = self.wrapped.read_dispatch(reader)?;
        self.stats.lock().unwrap().update(res);
        Ok(res)
    }
}

impl<
        W,
        const ZETA: usize,
        const GOLOMB: usize,
        const EXP_GOLOMB: usize,
        const RICE: usize,
        const PI: usize,
    > CodeWrite for CodesStatsWrapper<W, ZETA, GOLOMB, EXP_GOLOMB, RICE, PI>
where
    W: CodeWrite,
{
    type Error<CWE> = W::Error<CWE>
    where
        CWE: Error + Debug + Send + Sync + 'static;
    #[inline]
    fn write<E: Endianness, CW: WriteCodes<E> + ?Sized>(
        &self,
        writer: &mut CW,
        value: u64,
    ) -> Result<usize, Self::Error<CW::Error>> {
        let res = self.wrapped.write(writer, value)?;
        self.stats.lock().unwrap().update(value);
        Ok(res)
    }
}

impl<
        W,
        const ZETA: usize,
        const GOLOMB: usize,
        const EXP_GOLOMB: usize,
        const RICE: usize,
        const PI: usize,
        E: Endianness,
        CW: WriteCodes<E> + ?Sized,
    > CodeWriteDispatch<E, CW> for CodesStatsWrapper<W, ZETA, GOLOMB, EXP_GOLOMB, RICE, PI>
where
    W: CodeWriteDispatch<E, CW>,
{
    type Error<CWE> = W::Error<CWE>
    where
        CWE: Error + Debug + Send + Sync + 'static;
    #[inline]
    fn write_dispatch(&self, writer: &mut CW, value: u64) -> Result<usize, Self::Error<CW::Error>> {
        let res = self.wrapped.write_dispatch(writer, value)?;
        self.stats.lock().unwrap().update(value);
        Ok(res)
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/utils/count.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

use crate::{
    prelude::{
        len_delta, len_gamma, len_zeta, DeltaRead, DeltaWrite, GammaRead, GammaWrite, ZetaRead,
        ZetaWrite,
    },
    traits::*,
};
#[cfg(feature = "mem_dbg")]
use mem_dbg::{MemDbg, MemSize};

/// A wrapper around a [`BitWrite`] that keeps track of the number of
/// bits written and optionally prints on standard error the operations performed on the stream.
#[derive(Debug, Clone)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct CountBitWriter<E: Endianness, BW: BitWrite<E>, const PRINT: bool = false> {
    bit_write: BW,
    /// The number of bits written so far on the underlying [`BitWrite`].
    pub bits_written: usize,
    _marker: core::marker::PhantomData<E>,
}

impl<E: Endianness, BW: BitWrite<E>, const PRINT: bool> CountBitWriter<E, BW, PRINT> {
    pub fn new(bit_write: BW) -> Self {
        Self {
            bit_write,
            bits_written: 0,
            _marker: core::marker::PhantomData,
        }
    }
}

impl<E: Endianness, BW: BitWrite<E>, const PRINT: bool> BitWrite<E>
    for CountBitWriter<E, BW, PRINT>
{
    type Error = <BW as BitWrite<E>>::Error;

    fn write_bits(&mut self, value: u64, n_bits: usize) -> Result<usize, Self::Error> {
        self.bit_write.write_bits(value, n_bits).inspect(|x| {
            self.bits_written += *x;
            if PRINT {
                eprintln!(
                    "write_bits({:#016x}, {}) = {} (total = {})",
                    value, n_bits, x, self.bits_written
                );
            }
        })
    }

    fn write_unary(&mut self, value: u64) -> Result<usize, Self::Error> {
        self.bit_write.write_unary(value).inspect(|x| {
            self.bits_written += *x;
            if PRINT {
                eprintln!(
                    "write_unary({}) = {} (total = {})",
                    value, x, self.bits_written
                );
            }
        })
    }

    fn flush(&mut self) -> Result<usize, Self::Error> {
        self.bit_write.flush().inspect(|x| {
            self.bits_written += *x;
            if PRINT {
                eprintln!("flush() = {} (total = {})", x, self.bits_written);
            }
        })
    }
}

impl<E: Endianness, BW: BitWrite<E> + GammaWrite<E>, const PRINT: bool> GammaWrite<E>
    for CountBitWriter<E, BW, PRINT>
{
    fn write_gamma(&mut self, value: u64) -> Result<usize, BW::Error> {
        self.bit_write.write_gamma(value).inspect(|x| {
            self.bits_written += *x;
            if PRINT {
                eprintln!(
                    "write_gamma({}) = {} (total = {})",
                    value, x, self.bits_written
                );
            }
        })
    }
}

impl<E: Endianness, BW: BitWrite<E> + DeltaWrite<E>, const PRINT: bool> DeltaWrite<E>
    for CountBitWriter<E, BW, PRINT>
{
    fn write_delta(&mut self, value: u64) -> Result<usize, BW::Error> {
        self.bit_write.write_delta(value).inspect(|x| {
            self.bits_written += *x;
            if PRINT {
                eprintln!(
                    "write_delta({}) = {} (total = {})",
                    value, x, self.bits_written
                );
            }
        })
    }
}

impl<E: Endianness, BW: BitWrite<E> + ZetaWrite<E>, const PRINT: bool> ZetaWrite<E>
    for CountBitWriter<E, BW, PRINT>
{
    fn write_zeta(&mut self, value: u64, k: u64) -> Result<usize, BW::Error> {
        self.bit_write.write_zeta(value, k).inspect(|x| {
            self.bits_written += *x;
            if PRINT {
                eprintln!(
                    "write_zeta({}, {}) = {} (total = {})",
                    value, x, k, self.bits_written
                );
            }
        })
    }

    fn write_zeta3(&mut self, value: u64) -> Result<usize, BW::Error> {
        self.bit_write.write_zeta3(value).inspect(|x| {
            self.bits_written += *x;
            if PRINT {
                eprintln!(
                    "write_zeta({}) = {} (total = {})",
                    value, x, self.bits_written
                );
            }
        })
    }
}

impl<E: Endianness, BR: BitWrite<E> + BitSeek, const PRINT: bool> BitSeek
    for CountBitWriter<E, BR, PRINT>
{
    type Error = <BR as BitSeek>::Error;

    fn bit_pos(&mut self) -> Result<u64, Self::Error> {
        self.bit_write.bit_pos()
    }

    fn set_bit_pos(&mut self, bit_pos: u64) -> Result<(), Self::Error> {
        self.bit_write.set_bit_pos(bit_pos)
    }
}

/// A wrapper around a [`BitRead`] that keeps track of the number of
/// bits read and optionally prints on standard error the operations performed on the stream.
#[derive(Debug, Clone)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct CountBitReader<E: Endianness, BR: BitRead<E>, const PRINT: bool = false> {
    bit_read: BR,
    /// The number of bits read (or skipped) so far from the underlying [`BitRead`].
    pub bits_read: usize,
    _marker: core::marker::PhantomData<E>,
}

impl<E: Endianness, BR: BitRead<E>, const PRINT: bool> CountBitReader<E, BR, PRINT> {
    pub fn new(bit_read: BR) -> Self {
        Self {
            bit_read,
            bits_read: 0,
            _marker: core::marker::PhantomData,
        }
    }
}

impl<E: Endianness, BR: BitRead<E>, const PRINT: bool> BitRead<E> for CountBitReader<E, BR, PRINT> {
    type Error = <BR as BitRead<E>>::Error;
    type PeekWord = BR::PeekWord;

    fn read_bits(&mut self, n_bits: usize) -> Result<u64, Self::Error> {
        self.bit_read.read_bits(n_bits).inspect(|x| {
            self.bits_read += n_bits;
            if PRINT {
                eprintln!(
                    "read_bits({}) = {:#016x} (total = {})",
                    n_bits, x, self.bits_read
                );
            }
        })
    }

    fn read_unary(&mut self) -> Result<u64, Self::Error> {
        self.bit_read.read_unary().inspect(|x| {
            self.bits_read += *x as usize + 1;
            if PRINT {
                eprintln!("read_unary() = {} (total = {})", x, self.bits_read);
            }
        })
    }

    fn peek_bits(&mut self, n_bits: usize) -> Result<Self::PeekWord, Self::Error> {
        self.bit_read.peek_bits(n_bits)
    }

    fn skip_bits(&mut self, n_bits: usize) -> Result<(), Self::Error> {
        self.bits_read += n_bits;
        if PRINT {
            eprintln!("skip_bits({}) (total = {})", n_bits, self.bits_read);
        }
        self.bit_read.skip_bits(n_bits)
    }

    fn skip_bits_after_table_lookup(&mut self, n: usize) {
        self.bit_read.skip_bits_after_table_lookup(n)
    }
}

impl<E: Endianness, BR: BitRead<E> + GammaRead<E>, const PRINT: bool> GammaRead<E>
    for CountBitReader<E, BR, PRINT>
{
    fn read_gamma(&mut self) -> Result<u64, BR::Error> {
        self.bit_read.read_gamma().inspect(|x| {
            self.bits_read += len_gamma(*x);
            if PRINT {
                eprintln!("read_gamma() = {} (total = {})", x, self.bits_read);
            }
        })
    }
}

impl<E: Endianness, BR: BitRead<E> + DeltaRead<E>, const PRINT: bool> DeltaRead<E>
    for CountBitReader<E, BR, PRINT>
{
    fn read_delta(&mut self) -> Result<u64, BR::Error> {
        self.bit_read.read_delta().inspect(|x| {
            self.bits_read += len_delta(*x);
            if PRINT {
                eprintln!("read_delta() = {} (total = {})", x, self.bits_read);
            }
        })
    }
}

impl<E: Endianness, BR: BitRead<E> + ZetaRead<E>, const PRINT: bool> ZetaRead<E>
    for CountBitReader<E, BR, PRINT>
{
    fn read_zeta(&mut self, k: u64) -> Result<u64, BR::Error> {
        self.bit_read.read_zeta(k).inspect(|x| {
            self.bits_read += len_zeta(*x, k);
            if PRINT {
                eprintln!("read_zeta({}) = {} (total = {})", k, x, self.bits_read);
            }
        })
    }

    fn read_zeta3(&mut self) -> Result<u64, BR::Error> {
        self.bit_read.read_zeta3().inspect(|x| {
            self.bits_read += len_zeta(*x, 3);
            if PRINT {
                eprintln!("read_zeta3() = {} (total = {})", x, self.bits_read);
            }
        })
    }
}

impl<E: Endianness, BR: BitRead<E> + BitSeek, const PRINT: bool> BitSeek
    for CountBitReader<E, BR, PRINT>
{
    type Error = <BR as BitSeek>::Error;

    fn bit_pos(&mut self) -> Result<u64, Self::Error> {
        self.bit_read.bit_pos()
    }

    fn set_bit_pos(&mut self, bit_pos: u64) -> Result<(), Self::Error> {
        self.bit_read.set_bit_pos(bit_pos)
    }
}

#[cfg(test)]
#[test]
fn test_count() -> Result<(), Box<dyn std::error::Error + Send + Sync + 'static>> {
    use crate::prelude::*;
    let mut buffer = <Vec<u64>>::new();
    let bit_write = <BufBitWriter<LE, _>>::new(MemWordWriterVec::new(&mut buffer));
    let mut count_bit_write = CountBitWriter::<_, _, true>::new(bit_write);

    count_bit_write.write_unary(5)?;
    assert_eq!(count_bit_write.bits_written, 6);
    count_bit_write.write_unary(100)?;
    assert_eq!(count_bit_write.bits_written, 107);
    count_bit_write.write_bits(1, 20)?;
    assert_eq!(count_bit_write.bits_written, 127);
    count_bit_write.write_bits(1, 33)?;
    assert_eq!(count_bit_write.bits_written, 160);
    count_bit_write.write_gamma(2)?;
    assert_eq!(count_bit_write.bits_written, 163);
    count_bit_write.write_delta(1)?;
    assert_eq!(count_bit_write.bits_written, 167);
    count_bit_write.write_zeta(0, 4)?;
    assert_eq!(count_bit_write.bits_written, 171);
    count_bit_write.write_zeta3(0)?;
    assert_eq!(count_bit_write.bits_written, 174);
    count_bit_write.flush()?;
    drop(count_bit_write);

    let bit_read = <BufBitReader<LE, _>>::new(MemWordReader::<u64, _>::new(&buffer));
    let mut count_bit_read = CountBitReader::<_, _, true>::new(bit_read);

    assert_eq!(count_bit_read.peek_bits(5)?, 0);
    assert_eq!(count_bit_read.read_unary()?, 5);
    assert_eq!(count_bit_read.bits_read, 6);
    assert_eq!(count_bit_read.read_unary()?, 100);
    assert_eq!(count_bit_read.bits_read, 107);
    assert_eq!(count_bit_read.read_bits(20)?, 1);
    assert_eq!(count_bit_read.bits_read, 127);
    count_bit_read.skip_bits(33)?;
    assert_eq!(count_bit_read.bits_read, 160);
    assert_eq!(count_bit_read.read_gamma()?, 2);
    assert_eq!(count_bit_read.bits_read, 163);
    assert_eq!(count_bit_read.read_delta()?, 1);
    assert_eq!(count_bit_read.bits_read, 167);
    assert_eq!(count_bit_read.read_zeta(4)?, 0);
    assert_eq!(count_bit_read.bits_read, 171);
    assert_eq!(count_bit_read.read_zeta3()?, 0);
    assert_eq!(count_bit_read.bits_read, 174);

    Ok(())
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/utils/dbg_codes.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Inria
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

use crate::prelude::*;
use crate::traits::*;
#[cfg(feature = "mem_dbg")]
use mem_dbg::{MemDbg, MemSize};

/// A wrapper over a [`BitRead`] that report on standard error all operations performed,
/// including all code reads.
#[derive(Debug, Clone)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct DbgBitReader<E: Endianness, R> {
    reader: R,
    _marker: core::marker::PhantomData<E>,
}

impl<E: Endianness, R> DbgBitReader<E, R> {
    pub fn new(cr: R) -> Self {
        Self {
            reader: cr,
            _marker: Default::default(),
        }
    }
}

impl<E: Endianness, R: BitRead<E>> BitRead<E> for DbgBitReader<E, R>
where
    R::PeekWord: core::fmt::Display,
{
    type Error = R::Error;
    type PeekWord = R::PeekWord;

    fn peek_bits(&mut self, n_bits: usize) -> Result<Self::PeekWord, Self::Error> {
        let value = self.reader.peek_bits(n_bits)?;
        eprintln!("peek_bits({}): {}", n_bits, value);
        Ok(value)
    }

    fn skip_bits(&mut self, n_bits: usize) -> Result<(), Self::Error> {
        eprintln!("skip_bits({})", n_bits);
        self.reader.skip_bits(n_bits)
    }

    fn read_bits(&mut self, n_bits: usize) -> Result<u64, Self::Error> {
        let value = self.reader.read_bits(n_bits)?;
        eprintln!("read_bits({}): {}", n_bits, value);
        Ok(value)
    }

    fn read_unary(&mut self) -> Result<u64, Self::Error> {
        let value = self.reader.read_unary()?;
        eprintln!("{{U:{}}}", value);
        Ok(value)
    }

    fn skip_bits_after_table_lookup(&mut self, n: usize) {
        self.reader.skip_bits_after_table_lookup(n)
    }
}

impl<E: Endianness, R: GammaRead<E>> GammaRead<E> for DbgBitReader<E, R>
where
    R::PeekWord: core::fmt::Display,
{
    fn read_gamma(&mut self) -> Result<u64, R::Error> {
        let value = self.reader.read_gamma()?;
        eprintln!("{{g:{}}}", value);
        Ok(value)
    }
}

impl<E: Endianness, R: DeltaRead<E>> DeltaRead<E> for DbgBitReader<E, R>
where
    R::PeekWord: core::fmt::Display,
{
    fn read_delta(&mut self) -> Result<u64, R::Error> {
        let value = self.reader.read_delta()?;
        eprintln!("{{d:{}}}", value);
        Ok(value)
    }
}

impl<E: Endianness, R: ZetaRead<E>> ZetaRead<E> for DbgBitReader<E, R>
where
    R::PeekWord: core::fmt::Display,
{
    fn read_zeta3(&mut self) -> Result<u64, R::Error> {
        let value = self.reader.read_zeta3()?;
        eprintln!("{{z3:{}}}", value);
        Ok(value)
    }

    fn read_zeta(&mut self, k: u64) -> Result<u64, R::Error> {
        let value = self.reader.read_zeta(k)?;
        eprintln!("{{z{}:{}}}", k, value);
        Ok(value)
    }
}

/// A wrapper over a [`BitWrite`] that report on standard error all operations performed,
/// including all code writes.
#[derive(Debug, Clone)]
#[cfg_attr(feature = "mem_dbg", derive(MemDbg, MemSize))]
pub struct DbgBitWriter<E: Endianness, W> {
    writer: W,
    _marker: core::marker::PhantomData<E>,
}

impl<E: Endianness, W> DbgBitWriter<E, W> {
    pub fn new(cw: W) -> Self {
        Self {
            writer: cw,
            _marker: Default::default(),
        }
    }
}

impl<E: Endianness, W: BitWrite<E>> BitWrite<E> for DbgBitWriter<E, W> {
    type Error = W::Error;

    fn write_bits(&mut self, value: u64, n_bits: usize) -> Result<usize, Self::Error> {
        eprintln!("write_bits({}, {})", value, n_bits);
        self.writer.write_bits(value, n_bits)
    }

    fn write_unary(&mut self, value: u64) -> Result<usize, Self::Error> {
        eprintln!("{{U:{}}}", value);
        self.writer.write_unary(value)
    }

    fn flush(&mut self) -> Result<usize, Self::Error> {
        self.writer.flush()
    }
}

impl<E: Endianness, W: GammaWrite<E>> GammaWrite<E> for DbgBitWriter<E, W> {
    fn write_gamma(&mut self, value: u64) -> Result<usize, W::Error> {
        eprintln!("{{g:{}}}", value);
        self.writer.write_gamma(value)
    }
}

impl<E: Endianness, W: DeltaWrite<E>> DeltaWrite<E> for DbgBitWriter<E, W> {
    fn write_delta(&mut self, value: u64) -> Result<usize, W::Error> {
        eprintln!("{{d:{}}}", value);
        self.writer.write_delta(value)
    }
}

impl<E: Endianness, W: ZetaWrite<E>> ZetaWrite<E> for DbgBitWriter<E, W> {
    fn write_zeta(&mut self, value: u64, k: u64) -> Result<usize, W::Error> {
        eprintln!("{{z{}:{}}}", value, k);
        self.writer.write_zeta(value, k)
    }
    fn write_zeta3(&mut self, value: u64) -> Result<usize, W::Error> {
        eprintln!("{{z3:{}}}", value);
        self.writer.write_zeta3(value)
    }
}

```````

`/home/zom/Github/dsi-bitstream-rs/src/utils/mod.rs`:

```````rs
/*
 * SPDX-FileCopyrightText: 2023 Sebastiano Vigna
 *
 * SPDX-License-Identifier: Apache-2.0 OR LGPL-2.1-or-later
 */

/*!

Debug helpers and statistics.

[`CountBitReader`] and [`CountBitWriter`] keep track of the number
of bits read or written to a [`BitRead`](crate::traits::BitRead)
and [`BitWrite`](crate::traits::BitWrite), respectively,
optionally printing on standard error the operations performed on the stream.

[`DbgBitReader`] and [`DbgBitWriter`] print on standard error all
operation beformed by a [`BitRead`](crate::traits::BitRead) or
[`BitWrite`](crate::traits::BitWrite).

[`CodesStats`] keeps track of the space needed to store a stream of
integers using different codes.

*/

mod count;
pub use count::*;

mod dbg_codes;
pub use dbg_codes::*;

pub mod stats;
pub use stats::{CodesStats, CodesStatsWrapper};

```````